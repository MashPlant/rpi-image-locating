From 90c904c8c9cd91548f98721fdd0457bef64be3d8 Mon Sep 17 00:00:00 2001
From: MashPlant <740678788@qq.com>
Date: Tue, 24 Nov 2020 18:36:45 +0800
Subject: [PATCH] mashplant modification

---
 .../include/opencv2/core/bindings_utils.hpp   |   29 +-
 .../include/opencv2/core/utils/logger.hpp     |   44 +-
 modules/core/src/async.cpp                    |   25 +-
 modules/core/src/bindings_utils.cpp           |  211 --
 modules/core/src/command_line_parser.cpp      |  557 ----
 modules/core/src/glob.cpp                     |   17 +-
 modules/core/src/matrix.cpp                   |   38 +-
 modules/core/src/pca.cpp                      |   38 +-
 modules/core/src/persistence.cpp              | 2669 -----------------
 modules/core/src/persistence.hpp              |  202 --
 modules/core/src/persistence_json.cpp         |  786 -----
 modules/core/src/persistence_types.cpp        |  319 --
 modules/core/src/persistence_xml.cpp          |  850 ------
 modules/core/src/persistence_yml.cpp          |  859 ------
 modules/core/src/system.cpp                   |   22 +-
 modules/core/src/umatrix.cpp                  |   34 +-
 modules/core/src/utils/filesystem.cpp         |   15 +-
 modules/gapi/include/opencv2/gapi/imgproc.hpp |   41 +-
 modules/gapi/src/api/kernels_imgproc.cpp      |    7 -
 modules/gapi/src/backends/cpu/gcpuimgproc.cpp |   11 -
 .../gapi/test/common/gapi_imgproc_tests.hpp   |    2 -
 .../test/common/gapi_imgproc_tests_inl.hpp    |   23 -
 .../gapi/test/common/gapi_tests_common.hpp    |   19 -
 .../gapi/test/cpu/gapi_imgproc_tests_cpu.cpp  |   24 -
 modules/imgcodecs/src/bitstrm.cpp             |    4 +-
 modules/imgcodecs/src/exif.cpp                |   23 +-
 modules/imgcodecs/src/grfmt_bmp.cpp           |   35 +-
 modules/imgcodecs/src/grfmt_bmp.hpp           |    5 +
 modules/imgcodecs/src/loadsave.cpp            |  488 +--
 modules/imgproc/src/color.cpp                 |    3 +-
 modules/imgproc/src/contours.cpp              | 1866 ------------
 modules/imgproc/src/resize.cpp                |    3 +-
 modules/imgproc/src/templmatch.cpp            |    5 +-
 modules/videoio/src/backend_plugin.cpp        |   73 +-
 modules/videoio/src/cap.cpp                   |  171 +-
 modules/videoio/src/cap_images.cpp            |  187 +-
 modules/videoio/src/cap_v4l.cpp               |   23 +-
 modules/videoio/src/container_avi.cpp         |    4 +-
 platforms/linux/arm-musleabi.toolchain.cmake  |  101 +
 platforms/linux/arm.toolchain.cmake           |    7 +-
 40 files changed, 772 insertions(+), 9068 deletions(-)
 delete mode 100644 modules/core/src/bindings_utils.cpp
 delete mode 100644 modules/core/src/command_line_parser.cpp
 delete mode 100644 modules/core/src/persistence.cpp
 delete mode 100644 modules/core/src/persistence.hpp
 delete mode 100644 modules/core/src/persistence_json.cpp
 delete mode 100644 modules/core/src/persistence_types.cpp
 delete mode 100644 modules/core/src/persistence_xml.cpp
 delete mode 100644 modules/core/src/persistence_yml.cpp
 delete mode 100644 modules/imgproc/src/contours.cpp
 create mode 100644 platforms/linux/arm-musleabi.toolchain.cmake

diff --git a/modules/core/include/opencv2/core/bindings_utils.hpp b/modules/core/include/opencv2/core/bindings_utils.hpp
index f693dc8c65..50ea265576 100644
--- a/modules/core/include/opencv2/core/bindings_utils.hpp
+++ b/modules/core/include/opencv2/core/bindings_utils.hpp
@@ -66,20 +66,21 @@ AsyncArray testAsyncArray(InputArray argument)
     return p.getArrayResult();
 }
 
-CV_WRAP static inline
-AsyncArray testAsyncException()
-{
-    AsyncPromise p;
-    try
-    {
-        CV_Error(Error::StsOk, "Test: Generated async error");
-    }
-    catch (const cv::Exception& e)
-    {
-        p.setException(e);
-    }
-    return p.getArrayResult();
-}
+// mashplant:
+// CV_WRAP static inline
+// AsyncArray testAsyncException()
+// {
+//     AsyncPromise p;
+//     try
+//     {
+//         CV_Error(Error::StsOk, "Test: Generated async error");
+//     }
+//     catch (const cv::Exception& e)
+//     {
+//         p.setException(e);
+//     }
+//     return p.getArrayResult();
+// }
 
 //! @}
 }} // namespace
diff --git a/modules/core/include/opencv2/core/utils/logger.hpp b/modules/core/include/opencv2/core/utils/logger.hpp
index accb860ada..bf30271f5c 100644
--- a/modules/core/include/opencv2/core/utils/logger.hpp
+++ b/modules/core/include/opencv2/core/utils/logger.hpp
@@ -104,27 +104,29 @@ struct LogTagAuto
 // non-null. Do not re-define.
 #define CV_LOGTAG_GLOBAL cv::utils::logging::internal::getGlobalLogTag()
 
-#define CV_LOG_WITH_TAG(tag, msgLevel, extra_check0, extra_check1, ...) \
-    for(;;) { \
-        extra_check0; \
-        const auto cv_temp_msglevel = (cv::utils::logging::LogLevel)(msgLevel); \
-        if (cv_temp_msglevel >= (CV_LOG_STRIP_LEVEL)) break; \
-        auto cv_temp_logtagptr = CV_LOGTAG_PTR_CAST(CV_LOGTAG_EXPAND_NAME(tag)); \
-        if (!cv_temp_logtagptr) cv_temp_logtagptr = CV_LOGTAG_PTR_CAST(CV_LOGTAG_FALLBACK); \
-        if (!cv_temp_logtagptr) cv_temp_logtagptr = CV_LOGTAG_PTR_CAST(CV_LOGTAG_GLOBAL); \
-        if (cv_temp_logtagptr && (cv_temp_msglevel > cv_temp_logtagptr->level)) break; \
-        extra_check1; \
-        std::stringstream cv_temp_logstream; \
-        cv_temp_logstream << __VA_ARGS__; \
-        cv::utils::logging::internal::writeLogMessageEx( \
-            cv_temp_msglevel, \
-            (cv_temp_logtagptr ? cv_temp_logtagptr->name : nullptr), \
-            __FILE__, \
-            __LINE__, \
-            CV_Func, \
-            cv_temp_logstream.str().c_str()); \
-        break; \
-    }
+// mashplant:
+#define CV_LOG_WITH_TAG(...)
+// #define CV_LOG_WITH_TAG(tag, msgLevel, extra_check0, extra_check1, ...) \
+//     for(;;) { \
+//         extra_check0; \
+//         const auto cv_temp_msglevel = (cv::utils::logging::LogLevel)(msgLevel); \
+//         if (cv_temp_msglevel >= (CV_LOG_STRIP_LEVEL)) break; \
+//         auto cv_temp_logtagptr = CV_LOGTAG_PTR_CAST(CV_LOGTAG_EXPAND_NAME(tag)); \
+//         if (!cv_temp_logtagptr) cv_temp_logtagptr = CV_LOGTAG_PTR_CAST(CV_LOGTAG_FALLBACK); \
+//         if (!cv_temp_logtagptr) cv_temp_logtagptr = CV_LOGTAG_PTR_CAST(CV_LOGTAG_GLOBAL); \
+//         if (cv_temp_logtagptr && (cv_temp_msglevel > cv_temp_logtagptr->level)) break; \
+//         extra_check1; \
+//         std::stringstream cv_temp_logstream; \
+//         cv_temp_logstream << __VA_ARGS__; \
+//         cv::utils::logging::internal::writeLogMessageEx( \
+//             cv_temp_msglevel, \
+//             (cv_temp_logtagptr ? cv_temp_logtagptr->name : nullptr), \
+//             __FILE__, \
+//             __LINE__, \
+//             CV_Func, \
+//             cv_temp_logstream.str().c_str()); \
+//         break; \
+//     }
 
 #define CV_LOG_FATAL(tag, ...)   CV_LOG_WITH_TAG(tag, cv::utils::logging::LOG_LEVEL_FATAL, , , __VA_ARGS__)
 #define CV_LOG_ERROR(tag, ...)   CV_LOG_WITH_TAG(tag, cv::utils::logging::LOG_LEVEL_ERROR, , , __VA_ARGS__)
diff --git a/modules/core/src/async.cpp b/modules/core/src/async.cpp
index a2f4612365..c7753ae651 100644
--- a/modules/core/src/async.cpp
+++ b/modules/core/src/async.cpp
@@ -108,18 +108,19 @@ struct AsyncArray::Impl
                 result_is_fetched = true;
                 return true;
             }
-#if CV__EXCEPTION_PTR
-            if (has_exception && exception)
-            {
-                result_is_fetched = true;
-                std::rethrow_exception(exception);
-            }
-#endif
-            if (has_exception)
-            {
-                result_is_fetched = true;
-                throw cv_exception;
-            }
+            // mashplant:
+// #if CV__EXCEPTION_PTR
+//             if (has_exception && exception)
+//             {
+//                 result_is_fetched = true;
+//                 std::rethrow_exception(exception);
+//             }
+// #endif
+//             if (has_exception)
+//             {
+//                 result_is_fetched = true;
+//                 throw cv_exception;
+//             }
             CV_Error(Error::StsInternal, "AsyncArray: invalid state of 'has_result = true'");
         }
         CV_Assert(!has_result);
diff --git a/modules/core/src/bindings_utils.cpp b/modules/core/src/bindings_utils.cpp
deleted file mode 100644
index 050b7247f8..0000000000
--- a/modules/core/src/bindings_utils.cpp
+++ /dev/null
@@ -1,211 +0,0 @@
-// This file is part of OpenCV project.
-// It is subject to the license terms in the LICENSE file found in the top-level directory
-// of this distribution and at http://opencv.org/license.html.
-
-#include "precomp.hpp"
-#include "opencv2/core/bindings_utils.hpp"
-#include <sstream>
-
-namespace cv { namespace utils {
-
-String dumpInputArray(InputArray argument)
-{
-    if (&argument == &noArray())
-        return "InputArray: noArray()";
-    std::ostringstream ss;
-    ss << "InputArray:";
-    try {
-        do {
-            ss << (argument.empty() ? " empty()=true" : " empty()=false");
-            ss << cv::format(" kind=0x%08llx", (long long int)argument.kind());
-            ss << cv::format(" flags=0x%08llx", (long long int)argument.getFlags());
-            if (argument.getObj() == NULL)
-            {
-                ss << " obj=NULL";
-                break; // done
-            }
-            ss << cv::format(" total(-1)=%lld", (long long int)argument.total(-1));
-            int dims = argument.dims(-1);
-            ss << cv::format(" dims(-1)=%d", dims);
-            if (dims <= 2)
-            {
-                Size size = argument.size(-1);
-                ss << cv::format(" size(-1)=%dx%d", size.width, size.height);
-            }
-            else
-            {
-                int sz[CV_MAX_DIM] = {0};
-                argument.sizend(sz, -1);
-                ss << " size(-1)=[";
-                for (int i = 0; i < dims; i++)
-                {
-                    if (i > 0)
-                        ss << ' ';
-                    ss << sz[i];
-                }
-                ss << "]";
-            }
-            ss << " type(-1)=" << cv::typeToString(argument.type(-1));
-        } while (0);
-    }
-    catch (...)
-    {
-        ss << " ERROR: exception occurred, dump is non-complete";  // need to properly support different kinds
-    }
-    return ss.str();
-}
-
-CV_EXPORTS_W String dumpInputArrayOfArrays(InputArrayOfArrays argument)
-{
-    if (&argument == &noArray())
-        return "InputArrayOfArrays: noArray()";
-    std::ostringstream ss;
-    ss << "InputArrayOfArrays:";
-    try {
-        do {
-            ss << (argument.empty() ? " empty()=true" : " empty()=false");
-            ss << cv::format(" kind=0x%08llx", (long long int)argument.kind());
-            ss << cv::format(" flags=0x%08llx", (long long int)argument.getFlags());
-            if (argument.getObj() == NULL)
-            {
-                ss << " obj=NULL";
-                break; // done
-            }
-            ss << cv::format(" total(-1)=%lld", (long long int)argument.total(-1));
-            ss << cv::format(" dims(-1)=%d", argument.dims(-1));
-            Size size = argument.size(-1);
-            ss << cv::format(" size(-1)=%dx%d", size.width, size.height);
-            if (argument.total(-1) > 0)
-            {
-                ss << " type(0)=" << cv::typeToString(argument.type(0));
-                int dims = argument.dims(0);
-                ss << cv::format(" dims(0)=%d", dims);
-                if (dims <= 2)
-                {
-                    Size size0 = argument.size(0);
-                    ss << cv::format(" size(0)=%dx%d", size0.width, size0.height);
-                }
-                else
-                {
-                    int sz[CV_MAX_DIM] = {0};
-                    argument.sizend(sz, 0);
-                    ss << " size(0)=[";
-                    for (int i = 0; i < dims; i++)
-                    {
-                        if (i > 0)
-                            ss << ' ';
-                        ss << sz[i];
-                    }
-                    ss << "]";
-                }
-            }
-        } while (0);
-    }
-    catch (...)
-    {
-        ss << " ERROR: exception occurred, dump is non-complete";  // need to properly support different kinds
-    }
-    return ss.str();
-}
-
-CV_EXPORTS_W String dumpInputOutputArray(InputOutputArray argument)
-{
-    if (&argument == &noArray())
-        return "InputOutputArray: noArray()";
-    std::ostringstream ss;
-    ss << "InputOutputArray:";
-    try {
-        do {
-            ss << (argument.empty() ? " empty()=true" : " empty()=false");
-            ss << cv::format(" kind=0x%08llx", (long long int)argument.kind());
-            ss << cv::format(" flags=0x%08llx", (long long int)argument.getFlags());
-            if (argument.getObj() == NULL)
-            {
-                ss << " obj=NULL";
-                break; // done
-            }
-            ss << cv::format(" total(-1)=%lld", (long long int)argument.total(-1));
-            int dims = argument.dims(-1);
-            ss << cv::format(" dims(-1)=%d", dims);
-            if (dims <= 2)
-            {
-                Size size = argument.size(-1);
-                ss << cv::format(" size(-1)=%dx%d", size.width, size.height);
-            }
-            else
-            {
-                int sz[CV_MAX_DIM] = {0};
-                argument.sizend(sz, -1);
-                ss << " size(-1)=[";
-                for (int i = 0; i < dims; i++)
-                {
-                    if (i > 0)
-                        ss << ' ';
-                    ss << sz[i];
-                }
-                ss << "]";
-            }
-            ss << " type(-1)=" << cv::typeToString(argument.type(-1));
-        } while (0);
-    }
-    catch (...)
-    {
-        ss << " ERROR: exception occurred, dump is non-complete";  // need to properly support different kinds
-    }
-    return ss.str();
-}
-
-CV_EXPORTS_W String dumpInputOutputArrayOfArrays(InputOutputArrayOfArrays argument)
-{
-    if (&argument == &noArray())
-        return "InputOutputArrayOfArrays: noArray()";
-    std::ostringstream ss;
-    ss << "InputOutputArrayOfArrays:";
-    try {
-        do {
-            ss << (argument.empty() ? " empty()=true" : " empty()=false");
-            ss << cv::format(" kind=0x%08llx", (long long int)argument.kind());
-            ss << cv::format(" flags=0x%08llx", (long long int)argument.getFlags());
-            if (argument.getObj() == NULL)
-            {
-                ss << " obj=NULL";
-                break; // done
-            }
-            ss << cv::format(" total(-1)=%lld", (long long int)argument.total(-1));
-            ss << cv::format(" dims(-1)=%d", argument.dims(-1));
-            Size size = argument.size(-1);
-            ss << cv::format(" size(-1)=%dx%d", size.width, size.height);
-            if (argument.total(-1) > 0)
-            {
-                ss << " type(0)=" << cv::typeToString(argument.type(0));
-                int dims = argument.dims(0);
-                ss << cv::format(" dims(0)=%d", dims);
-                if (dims <= 2)
-                {
-                    Size size0 = argument.size(0);
-                    ss << cv::format(" size(0)=%dx%d", size0.width, size0.height);
-                }
-                else
-                {
-                    int sz[CV_MAX_DIM] = {0};
-                    argument.sizend(sz, 0);
-                    ss << " size(0)=[";
-                    for (int i = 0; i < dims; i++)
-                    {
-                        if (i > 0)
-                            ss << ' ';
-                        ss << sz[i];
-                    }
-                    ss << "]";
-                }
-            }
-        } while (0);
-    }
-    catch (...)
-    {
-        ss << " ERROR: exception occurred, dump is non-complete";  // need to properly support different kinds
-    }
-    return ss.str();
-}
-
-}} // namespace
diff --git a/modules/core/src/command_line_parser.cpp b/modules/core/src/command_line_parser.cpp
deleted file mode 100644
index af97232db6..0000000000
--- a/modules/core/src/command_line_parser.cpp
+++ /dev/null
@@ -1,557 +0,0 @@
-// This file is part of OpenCV project.
-// It is subject to the license terms in the LICENSE file found in the top-level directory
-// of this distribution and at http://opencv.org/license.html.
-#include "precomp.hpp"
-#include <sstream>
-
-namespace cv
-{
-
-namespace {
-static const char* noneValue = "<none>";
-
-static String cat_string(const String& str)
-{
-    int left = 0, right = (int)str.length();
-    while( left < right && str[left] == ' ' )
-        left++;
-    while( right > left && str[right-1] == ' ' )
-        right--;
-    return left >= right ? String("") : str.substr(left, right-left);
-}
-}
-
-struct CommandLineParserParams
-{
-public:
-    String help_message;
-    String def_value;
-    std::vector<String> keys;
-    int number;
-};
-
-
-struct CommandLineParser::Impl
-{
-    bool error;
-    String error_message;
-    String about_message;
-
-    String path_to_app;
-    String app_name;
-
-    std::vector<CommandLineParserParams> data;
-
-    std::vector<String> split_range_string(const String& str, char fs, char ss) const;
-    std::vector<String> split_string(const String& str, char symbol = ' ', bool create_empty_item = false) const;
-
-    void apply_params(const String& key, const String& value);
-    void apply_params(int i, String value);
-
-    void sort_params();
-    int refcount;
-};
-
-
-static const char* get_type_name(Param type)
-{
-    if( type == Param::INT )
-        return "int";
-    if( type == Param::BOOLEAN )
-        return "bool";
-    if( type == Param::UNSIGNED_INT )
-        return "unsigned";
-    if( type == Param::UINT64 )
-        return "unsigned long long";
-    if( type == Param::FLOAT )
-        return "float";
-    if( type == Param::REAL )
-        return "double";
-    if( type == Param::STRING )
-        return "string";
-    return "unknown";
-}
-
-static bool parse_bool(std::string str)
-{
-    std::transform(str.begin(), str.end(), str.begin(), details::char_tolower);
-    std::istringstream is(str);
-    bool b;
-    is >> (str.size() > 1 ? std::boolalpha : std::noboolalpha) >> b;
-    return b;
-}
-
-static void from_str(const String& str, Param type, void* dst)
-{
-    std::stringstream ss(str.c_str());
-    if( type == Param::INT )
-        ss >> *(int*)dst;
-    else if( type == Param::BOOLEAN )
-    {
-        std::string temp;
-        ss >> temp;
-        *(bool*) dst = parse_bool(temp);
-    }
-    else if( type == Param::UNSIGNED_INT )
-        ss >> *(unsigned*)dst;
-    else if( type == Param::UINT64 )
-        ss >> *(uint64*)dst;
-    else if( type == Param::FLOAT )
-        ss >> *(float*)dst;
-    else if( type == Param::REAL )
-        ss >> *(double*)dst;
-    else if( type == Param::STRING )
-        *(String*)dst = str;
-    else if( type == Param::SCALAR)
-    {
-        Scalar& scalar = *(Scalar*)dst;
-        for (int i = 0; i < 4 && !ss.eof(); ++i)
-            ss >> scalar[i];
-    }
-    else
-        CV_Error(Error::StsBadArg, "unknown/unsupported parameter type");
-
-    if (ss.fail())
-    {
-        CV_Error_(Error::StsBadArg, ("can not convert: [%s] to [%s]", str.c_str(), get_type_name(type)));
-    }
-}
-
-void CommandLineParser::getByName(const String& name, bool space_delete, Param type, void* dst) const
-{
-    try
-    {
-        for (size_t i = 0; i < impl->data.size(); i++)
-        {
-            for (size_t j = 0; j < impl->data[i].keys.size(); j++)
-            {
-                if (name == impl->data[i].keys[j])
-                {
-                    String v = impl->data[i].def_value;
-                    if (space_delete)
-                        v = cat_string(v);
-
-                    // the key was neither specified nor has a default value
-                    if((v.empty() && type != Param::STRING) || v == noneValue) {
-                        impl->error = true;
-                        impl->error_message = impl->error_message + "Missing parameter: '" + name + "'\n";
-                        return;
-                    }
-
-                    from_str(v, type, dst);
-                    return;
-                }
-            }
-        }
-    }
-    catch (const Exception& e)
-    {
-        impl->error = true;
-        impl->error_message = impl->error_message + "Parameter '"+ name + "': " + e.err + "\n";
-        return;
-    }
-
-    CV_Error_(Error::StsBadArg, ("undeclared key '%s' requested", name.c_str()));
-}
-
-
-void CommandLineParser::getByIndex(int index, bool space_delete, Param type, void* dst) const
-{
-    try
-    {
-        for (size_t i = 0; i < impl->data.size(); i++)
-        {
-            if (impl->data[i].number == index)
-            {
-                String v = impl->data[i].def_value;
-                if (space_delete == true) v = cat_string(v);
-
-                // the key was neither specified nor has a default value
-                if((v.empty() && type != Param::STRING) || v == noneValue) {
-                    impl->error = true;
-                    impl->error_message = impl->error_message + format("Missing parameter #%d\n", index);
-                    return;
-                }
-                from_str(v, type, dst);
-                return;
-            }
-        }
-    }
-    catch (const Exception& e)
-    {
-        impl->error = true;
-        impl->error_message = impl->error_message + format("Parameter #%d: ", index) + e.err + "\n";
-        return;
-    }
-
-    CV_Error_(Error::StsBadArg, ("undeclared position %d requested", index));
-}
-
-static bool cmp_params(const CommandLineParserParams & p1, const CommandLineParserParams & p2)
-{
-    if (p1.number < p2.number)
-        return true;
-
-    if (p1.number > p2.number)
-        return false;
-
-    return p1.keys[0].compare(p2.keys[0]) < 0;
-}
-
-CommandLineParser::CommandLineParser(int argc, const char* const argv[], const String& keys)
-{
-    impl = new Impl;
-    impl->refcount = 1;
-
-    // path to application
-    size_t pos_s = String(argv[0]).find_last_of("/\\");
-    if (pos_s == String::npos)
-    {
-        impl->path_to_app = "";
-        impl->app_name = String(argv[0]);
-    }
-    else
-    {
-        impl->path_to_app = String(argv[0]).substr(0, pos_s);
-        impl->app_name = String(argv[0]).substr(pos_s + 1, String(argv[0]).length() - pos_s);
-    }
-
-    impl->error = false;
-    impl->error_message = "";
-
-    // parse keys
-    std::vector<String> k = impl->split_range_string(keys, '{', '}');
-
-    int jj = 0;
-    for (size_t i = 0; i < k.size(); i++)
-    {
-        std::vector<String> l = impl->split_string(k[i], '|', true);
-        CommandLineParserParams p;
-        p.keys = impl->split_string(l[0]);
-        p.def_value = l[1];
-        p.help_message = cat_string(l[2]);
-        p.number = -1;
-        if (p.keys.size() <= 0)
-        {
-            impl->error = true;
-            impl->error_message = "Field KEYS could not be empty\n";
-        }
-        else
-        {
-            if (p.keys[0][0] == '@')
-            {
-                p.number = jj;
-                jj++;
-            }
-
-            impl->data.push_back(p);
-        }
-    }
-
-    // parse argv
-    jj = 0;
-    for (int i = 1; i < argc; i++)
-    {
-        String s(argv[i]);
-        bool hasSingleDash = s.length() > 1 && s[0] == '-';
-
-        if (hasSingleDash)
-        {
-            bool hasDoubleDash = s.length() > 2 && s[1] == '-';
-            String key = s.substr(hasDoubleDash ? 2 : 1);
-            String value = "true";
-            size_t equalsPos = key.find('=');
-
-            if(equalsPos != String::npos) {
-                value = key.substr(equalsPos + 1);
-                key = key.substr(0, equalsPos);
-            }
-            impl->apply_params(key, value);
-        }
-        else
-        {
-            impl->apply_params(jj, s);
-            jj++;
-        }
-    }
-
-    impl->sort_params();
-}
-
-CommandLineParser::~CommandLineParser()
-{
-    if (CV_XADD(&impl->refcount, -1) == 1)
-        delete impl;
-}
-
-CommandLineParser::CommandLineParser(const CommandLineParser& parser)
-{
-    impl = parser.impl;
-    CV_XADD(&impl->refcount, 1);
-}
-
-CommandLineParser& CommandLineParser::operator = (const CommandLineParser& parser)
-{
-    if( this != &parser )
-    {
-        CV_XADD(&parser.impl->refcount, 1);
-        if(CV_XADD(&impl->refcount, -1) == 1)
-            delete impl;
-        impl = parser.impl;
-    }
-    return *this;
-}
-
-void CommandLineParser::about(const String& message)
-{
-    impl->about_message = message;
-}
-
-void CommandLineParser::Impl::apply_params(const String& key, const String& value)
-{
-    for (size_t i = 0; i < data.size(); i++)
-    {
-        for (size_t k = 0; k < data[i].keys.size(); k++)
-        {
-            if (key.compare(data[i].keys[k]) == 0)
-            {
-                data[i].def_value = value;
-                break;
-            }
-        }
-    }
-}
-
-void CommandLineParser::Impl::apply_params(int i, String value)
-{
-    for (size_t j = 0; j < data.size(); j++)
-    {
-        if (data[j].number == i)
-        {
-            data[j].def_value = value;
-            break;
-        }
-    }
-}
-
-void CommandLineParser::Impl::sort_params()
-{
-    for (size_t i = 0; i < data.size(); i++)
-    {
-        std::sort(data[i].keys.begin(), data[i].keys.end());
-    }
-
-    std::sort (data.begin(), data.end(), cmp_params);
-}
-
-String CommandLineParser::getPathToApplication() const
-{
-    return impl->path_to_app;
-}
-
-bool CommandLineParser::has(const String& name) const
-{
-    for (size_t i = 0; i < impl->data.size(); i++)
-    {
-        for (size_t j = 0; j < impl->data[i].keys.size(); j++)
-        {
-            if (name == impl->data[i].keys[j])
-            {
-                const String v = cat_string(impl->data[i].def_value);
-                return !v.empty() && v != noneValue;
-            }
-        }
-    }
-
-    CV_Error_(Error::StsBadArg, ("undeclared key '%s' requested", name.c_str()));
-}
-
-bool CommandLineParser::check() const
-{
-    return impl->error == false;
-}
-
-void CommandLineParser::printErrors() const
-{
-    if (impl->error)
-    {
-        printf("\nERRORS:\n%s\n", impl->error_message.c_str());
-        fflush(stdout);
-    }
-}
-
-void CommandLineParser::printMessage() const
-{
-    if (impl->about_message != "")
-        printf("%s\n", impl->about_message.c_str());
-
-    printf("Usage: %s [params] ", impl->app_name.c_str());
-
-    for (size_t i = 0; i < impl->data.size(); i++)
-    {
-        if (impl->data[i].number > -1)
-        {
-            String name = impl->data[i].keys[0].substr(1, impl->data[i].keys[0].length() - 1);
-            printf("%s ", name.c_str());
-        }
-    }
-
-    printf("\n\n");
-
-    for (size_t i = 0; i < impl->data.size(); i++)
-    {
-        if (impl->data[i].number == -1)
-        {
-            printf("\t");
-            for (size_t j = 0; j < impl->data[i].keys.size(); j++)
-            {
-                String k = impl->data[i].keys[j];
-                if (k.length() > 1)
-                {
-                    printf("--");
-                }
-                else
-                {
-                    printf("-");
-                }
-                printf("%s", k.c_str());
-
-                if (j != impl->data[i].keys.size() - 1)
-                {
-                    printf(", ");
-                }
-            }
-            String dv = cat_string(impl->data[i].def_value);
-            if (dv.compare("") != 0)
-            {
-                printf(" (value:%s)", dv.c_str());
-            }
-            printf("\n\t\t%s\n", impl->data[i].help_message.c_str());
-        }
-    }
-    printf("\n");
-
-    for (size_t i = 0; i < impl->data.size(); i++)
-    {
-        if (impl->data[i].number != -1)
-        {
-            printf("\t");
-            String k = impl->data[i].keys[0];
-            k = k.substr(1, k.length() - 1);
-
-            printf("%s", k.c_str());
-
-            String dv = cat_string(impl->data[i].def_value);
-            if (dv.compare("") != 0)
-            {
-                printf(" (value:%s)", dv.c_str());
-            }
-            printf("\n\t\t%s\n", impl->data[i].help_message.c_str());
-        }
-    }
-}
-
-std::vector<String> CommandLineParser::Impl::split_range_string(const String& _str, char fs, char ss) const
-{
-    String str = _str;
-    std::vector<String> vec;
-    String word = "";
-    bool begin = false;
-
-    while (!str.empty())
-    {
-        if (str[0] == fs)
-        {
-            if (begin == true)
-            {
-                throw cv::Exception(CV_StsParseError,
-                         String("error in split_range_string(")
-                         + str
-                         + String(", ")
-                         + String(1, fs)
-                         + String(", ")
-                         + String(1, ss)
-                         + String(")"),
-                         "", __FILE__, __LINE__
-                         );
-            }
-            begin = true;
-            word = "";
-            str = str.substr(1, str.length() - 1);
-        }
-
-        if (str[0] == ss)
-        {
-            if (begin == false)
-            {
-                throw cv::Exception(CV_StsParseError,
-                         String("error in split_range_string(")
-                         + str
-                         + String(", ")
-                         + String(1, fs)
-                         + String(", ")
-                         + String(1, ss)
-                         + String(")"),
-                         "", __FILE__, __LINE__
-                         );
-            }
-            begin = false;
-            vec.push_back(word);
-        }
-
-        if (begin == true)
-        {
-            word = word + str[0];
-        }
-        str = str.substr(1, str.length() - 1);
-    }
-
-    if (begin == true)
-    {
-        throw cv::Exception(CV_StsParseError,
-                 String("error in split_range_string(")
-                 + str
-                 + String(", ")
-                 + String(1, fs)
-                 + String(", ")
-                 + String(1, ss)
-                 + String(")"),
-                 "", __FILE__, __LINE__
-                );
-    }
-
-    return vec;
-}
-
-std::vector<String> CommandLineParser::Impl::split_string(const String& _str, char symbol, bool create_empty_item) const
-{
-    String str = _str;
-    std::vector<String> vec;
-    String word = "";
-
-    while (!str.empty())
-    {
-        if (str[0] == symbol)
-        {
-            if (!word.empty() || create_empty_item)
-            {
-                vec.push_back(word);
-                word = "";
-            }
-        }
-        else
-        {
-            word = word + str[0];
-        }
-        str = str.substr(1, str.length() - 1);
-    }
-
-    if (word != "" || create_empty_item)
-    {
-        vec.push_back(word);
-    }
-
-    return vec;
-}
-
-}
diff --git a/modules/core/src/glob.cpp b/modules/core/src/glob.cpp
index fa8592caa5..0be1331a1d 100644
--- a/modules/core/src/glob.cpp
+++ b/modules/core/src/glob.cpp
@@ -231,8 +231,9 @@ static void glob_rec(const cv::String& directory, const cv::String& wildchart, s
     if ((dir = opendir (directory.c_str())) != 0)
     {
         /* find all the files and directories within directory */
-        try
-        {
+        // mashplant:
+        // try
+        // {
             struct dirent *ent;
             while ((ent = readdir (dir)) != 0)
             {
@@ -254,12 +255,12 @@ static void glob_rec(const cv::String& directory, const cv::String& wildchart, s
                 if (wildchart.empty() || wildcmp(name, wildchart.c_str()))
                     result.push_back(entry);
             }
-        }
-        catch (...)
-        {
-            closedir(dir);
-            throw;
-        }
+        // }
+        // catch (...)
+        // {
+        //     closedir(dir);
+        //     throw;
+        // }
         closedir(dir);
     }
     else
diff --git a/modules/core/src/matrix.cpp b/modules/core/src/matrix.cpp
index 122b383379..66f5de9a80 100644
--- a/modules/core/src/matrix.cpp
+++ b/modules/core/src/matrix.cpp
@@ -700,18 +700,19 @@ void Mat::create(int d, const int* _sizes, int _type)
 #endif
         if(!a)
             a = a0;
-        try
-        {
+        // mashplant:
+        // try
+        // {
             u = a->allocate(dims, size, _type, 0, step.p, ACCESS_RW /* ignored */, USAGE_DEFAULT);
             CV_Assert(u != 0);
-        }
-        catch (...)
-        {
-            if (a == a0)
-                throw;
-            u = a0->allocate(dims, size, _type, 0, step.p, ACCESS_RW /* ignored */, USAGE_DEFAULT);
-            CV_Assert(u != 0);
-        }
+        // }
+        // catch (...)
+        // {
+        //     if (a == a0)
+        //         throw;
+        //     u = a0->allocate(dims, size, _type, 0, step.p, ACCESS_RW /* ignored */, USAGE_DEFAULT);
+        //     CV_Assert(u != 0);
+        // }
         CV_Assert( step[dims-1] == (size_t)CV_ELEM_SIZE(flags) );
     }
 
@@ -761,8 +762,9 @@ Mat::Mat(const Mat& m, const Range& _rowRange, const Range& _colRange)
     }
 
     *this = m;
-    try
-    {
+    // mashplant:
+    // try
+    // {
         if( _rowRange != Range::all() && _rowRange != Range(0,rows) )
         {
             CV_Assert( 0 <= _rowRange.start && _rowRange.start <= _rowRange.end
@@ -780,12 +782,12 @@ Mat::Mat(const Mat& m, const Range& _rowRange, const Range& _colRange)
             data += _colRange.start*elemSize();
             flags |= SUBMATRIX_FLAG;
         }
-    }
-    catch(...)
-    {
-        release();
-        throw;
-    }
+    // }
+    // catch(...)
+    // {
+    //     release();
+    //     throw;
+    // }
 
     updateContinuityFlag();
 
diff --git a/modules/core/src/pca.cpp b/modules/core/src/pca.cpp
index 79126a8f36..4c4c642dc5 100644
--- a/modules/core/src/pca.cpp
+++ b/modules/core/src/pca.cpp
@@ -148,25 +148,25 @@ PCA& PCA::operator()(InputArray _data, InputArray __mean, int flags, int maxComp
     return *this;
 }
 
-void PCA::write(FileStorage& fs ) const
-{
-    CV_Assert( fs.isOpened() );
-
-    fs << "name" << "PCA";
-    fs << "vectors" << eigenvectors;
-    fs << "values" << eigenvalues;
-    fs << "mean" << mean;
-}
-
-void PCA::read(const FileNode& fn)
-{
-    CV_Assert( !fn.empty() );
-    CV_Assert( (String)fn["name"] == "PCA" );
-
-    cv::read(fn["vectors"], eigenvectors);
-    cv::read(fn["values"], eigenvalues);
-    cv::read(fn["mean"], mean);
-}
+// void PCA::write(FileStorage& fs ) const
+// {
+//     CV_Assert( fs.isOpened() );
+
+//     fs << "name" << "PCA";
+//     fs << "vectors" << eigenvectors;
+//     fs << "values" << eigenvalues;
+//     fs << "mean" << mean;
+// }
+
+// void PCA::read(const FileNode& fn)
+// {
+//     CV_Assert( !fn.empty() );
+//     CV_Assert( (String)fn["name"] == "PCA" );
+
+//     cv::read(fn["vectors"], eigenvectors);
+//     cv::read(fn["values"], eigenvalues);
+//     cv::read(fn["mean"], mean);
+// }
 
 template <typename T>
 int computeCumulativeEnergy(const Mat& eigenvalues, double retainedVariance)
diff --git a/modules/core/src/persistence.cpp b/modules/core/src/persistence.cpp
deleted file mode 100644
index 4bf52a3134..0000000000
--- a/modules/core/src/persistence.cpp
+++ /dev/null
@@ -1,2669 +0,0 @@
-// This file is part of OpenCV project.
-// It is subject to the license terms in the LICENSE file found in the top-level directory
-// of this distribution and at http://opencv.org/license.html
-
-#include "precomp.hpp"
-#include "persistence.hpp"
-#include <unordered_map>
-#include <iterator>
-
-namespace cv
-{
-
-namespace fs
-{
-
-int strcasecmp(const char* s1, const char* s2)
-{
-    const char* dummy="";
-    if(!s1) s1=dummy;
-    if(!s2) s2=dummy;
-
-    size_t len1 = strlen(s1);
-    size_t len2 = strlen(s2);
-    size_t i, len = std::min(len1, len2);
-    for( i = 0; i < len; i++ )
-    {
-        int d = tolower((int)s1[i]) - tolower((int)s2[i]);
-        if( d != 0 )
-            return d;
-    }
-    return len1 < len2 ? -1 : len1 > len2 ? 1 : 0;
-}
-
-char* itoa( int _val, char* buffer, int /*radix*/ )
-{
-    const int radix = 10;
-    char* ptr=buffer + 23 /* enough even for 64-bit integers */;
-    unsigned val = abs(_val);
-
-    *ptr = '\0';
-    do
-    {
-        unsigned r = val / radix;
-        *--ptr = (char)(val - (r*radix) + '0');
-        val = r;
-    }
-    while( val != 0 );
-
-    if( _val < 0 )
-        *--ptr = '-';
-
-    return ptr;
-}
-
-char* doubleToString( char* buf, double value, bool explicitZero )
-{
-    Cv64suf val;
-    unsigned ieee754_hi;
-
-    val.f = value;
-    ieee754_hi = (unsigned)(val.u >> 32);
-
-    if( (ieee754_hi & 0x7ff00000) != 0x7ff00000 )
-    {
-        int ivalue = cvRound(value);
-        if( ivalue == value )
-        {
-            if( explicitZero )
-                sprintf( buf, "%d.0", ivalue );
-            else
-                sprintf( buf, "%d.", ivalue );
-        }
-        else
-        {
-            static const char* fmt = "%.16e";
-            char* ptr = buf;
-            sprintf( buf, fmt, value );
-            if( *ptr == '+' || *ptr == '-' )
-                ptr++;
-            for( ; cv_isdigit(*ptr); ptr++ )
-                ;
-            if( *ptr == ',' )
-                *ptr = '.';
-        }
-    }
-    else
-    {
-        unsigned ieee754_lo = (unsigned)val.u;
-        if( (ieee754_hi & 0x7fffffff) + (ieee754_lo != 0) > 0x7ff00000 )
-            strcpy( buf, ".Nan" );
-        else
-            strcpy( buf, (int)ieee754_hi < 0 ? "-.Inf" : ".Inf" );
-    }
-
-    return buf;
-}
-
-char* floatToString( char* buf, float value, bool halfprecision, bool explicitZero )
-{
-    Cv32suf val;
-    unsigned ieee754;
-    val.f = value;
-    ieee754 = val.u;
-
-    if( (ieee754 & 0x7f800000) != 0x7f800000 )
-    {
-        int ivalue = cvRound(value);
-        if( ivalue == value )
-        {
-            if( explicitZero )
-                sprintf( buf, "%d.0", ivalue );
-            else
-                sprintf( buf, "%d.", ivalue );
-        }
-        else
-        {
-            char* ptr = buf;
-            if (halfprecision)
-                sprintf(buf, "%.4e", value);
-            else
-                sprintf(buf, "%.8e", value);
-            if( *ptr == '+' || *ptr == '-' )
-                ptr++;
-            for( ; cv_isdigit(*ptr); ptr++ )
-                ;
-            if( *ptr == ',' )
-                *ptr = '.';
-        }
-    }
-    else
-    {
-        if( (ieee754 & 0x7fffffff) != 0x7f800000 )
-            strcpy( buf, ".Nan" );
-        else
-            strcpy( buf, (int)ieee754 < 0 ? "-.Inf" : ".Inf" );
-    }
-
-    return buf;
-}
-
-static const char symbols[9] = "ucwsifdh";
-
-static char typeSymbol(int depth)
-{
-    CV_StaticAssert(CV_64F == 6, "");
-    CV_Assert(depth >=0 && depth <= CV_64F);
-    return symbols[depth];
-}
-
-static int symbolToType(char c)
-{
-    const char* pos = strchr( symbols, c );
-    if( !pos )
-        CV_Error( CV_StsBadArg, "Invalid data type specification" );
-    if (c == 'r')
-        return CV_SEQ_ELTYPE_PTR;
-    return static_cast<int>(pos - symbols);
-}
-
-char* encodeFormat(int elem_type, char* dt)
-{
-    int cn = (elem_type == CV_SEQ_ELTYPE_PTR/*CV_USRTYPE1*/) ? 1 : CV_MAT_CN(elem_type);
-    char symbol = (elem_type == CV_SEQ_ELTYPE_PTR/*CV_USRTYPE1*/) ? 'r' : typeSymbol(CV_MAT_DEPTH(elem_type));
-    sprintf(dt, "%d%c", cn, symbol);
-    return dt + (cn == 1 ? 1 : 0);
-}
-
-int decodeFormat( const char* dt, int* fmt_pairs, int max_len )
-{
-    int fmt_pair_count = 0;
-    int i = 0, k = 0, len = dt ? (int)strlen(dt) : 0;
-
-    if( !dt || !len )
-        return 0;
-
-    assert( fmt_pairs != 0 && max_len > 0 );
-    fmt_pairs[0] = 0;
-    max_len *= 2;
-
-    for( ; k < len; k++ )
-    {
-        char c = dt[k];
-
-        if( cv_isdigit(c) )
-        {
-            int count = c - '0';
-            if( cv_isdigit(dt[k+1]) )
-            {
-                char* endptr = 0;
-                count = (int)strtol( dt+k, &endptr, 10 );
-                k = (int)(endptr - dt) - 1;
-            }
-
-            if( count <= 0 )
-                CV_Error( CV_StsBadArg, "Invalid data type specification" );
-
-            fmt_pairs[i] = count;
-        }
-        else
-        {
-            int depth = symbolToType(c);
-            if( fmt_pairs[i] == 0 )
-                fmt_pairs[i] = 1;
-            fmt_pairs[i+1] = depth;
-            if( i > 0 && fmt_pairs[i+1] == fmt_pairs[i-1] )
-                fmt_pairs[i-2] += fmt_pairs[i];
-            else
-            {
-                i += 2;
-                if( i >= max_len )
-                    CV_Error( CV_StsBadArg, "Too long data type specification" );
-            }
-            fmt_pairs[i] = 0;
-        }
-    }
-
-    fmt_pair_count = i/2;
-    return fmt_pair_count;
-}
-
-int calcElemSize( const char* dt, int initial_size )
-{
-    int size = 0;
-    int fmt_pairs[CV_FS_MAX_FMT_PAIRS], i, fmt_pair_count;
-    int comp_size;
-
-    fmt_pair_count = decodeFormat( dt, fmt_pairs, CV_FS_MAX_FMT_PAIRS );
-    fmt_pair_count *= 2;
-    for( i = 0, size = initial_size; i < fmt_pair_count; i += 2 )
-    {
-        comp_size = CV_ELEM_SIZE(fmt_pairs[i+1]);
-        size = cvAlign( size, comp_size );
-        size += comp_size * fmt_pairs[i];
-    }
-    if( initial_size == 0 )
-    {
-        comp_size = CV_ELEM_SIZE(fmt_pairs[1]);
-        size = cvAlign( size, comp_size );
-    }
-    return size;
-}
-
-
-int calcStructSize( const char* dt, int initial_size )
-{
-    int size = calcElemSize( dt, initial_size );
-    size_t elem_max_size = 0;
-    for ( const char * type = dt; *type != '\0'; type++ ) {
-        switch ( *type )
-        {
-        case 'u': { elem_max_size = std::max( elem_max_size, sizeof(uchar ) ); break; }
-        case 'c': { elem_max_size = std::max( elem_max_size, sizeof(schar ) ); break; }
-        case 'w': { elem_max_size = std::max( elem_max_size, sizeof(ushort) ); break; }
-        case 's': { elem_max_size = std::max( elem_max_size, sizeof(short ) ); break; }
-        case 'i': { elem_max_size = std::max( elem_max_size, sizeof(int   ) ); break; }
-        case 'f': { elem_max_size = std::max( elem_max_size, sizeof(float ) ); break; }
-        case 'd': { elem_max_size = std::max( elem_max_size, sizeof(double) ); break; }
-        default: break;
-        }
-    }
-    size = cvAlign( size, static_cast<int>(elem_max_size) );
-    return size;
-}
-
-int decodeSimpleFormat( const char* dt )
-{
-    int elem_type = -1;
-    int fmt_pairs[CV_FS_MAX_FMT_PAIRS], fmt_pair_count;
-
-    fmt_pair_count = decodeFormat( dt, fmt_pairs, CV_FS_MAX_FMT_PAIRS );
-    if( fmt_pair_count != 1 || fmt_pairs[0] >= CV_CN_MAX)
-        CV_Error( CV_StsError, "Too complex format for the matrix" );
-
-    elem_type = CV_MAKETYPE( fmt_pairs[1], fmt_pairs[0] );
-
-    return elem_type;
-}
-
-}
-
-#if defined __i386__ || defined(_M_IX86) || defined __x86_64__ || defined(_M_X64)
-#define CV_UNALIGNED_LITTLE_ENDIAN_MEM_ACCESS 1
-#else
-#define CV_UNALIGNED_LITTLE_ENDIAN_MEM_ACCESS 0
-#endif
-
-static inline int readInt(const uchar* p)
-{
-#if CV_UNALIGNED_LITTLE_ENDIAN_MEM_ACCESS
-    return *(const int*)p;
-#else
-    int val = (int)(p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24));
-    return val;
-#endif
-}
-
-static inline double readReal(const uchar* p)
-{
-#if CV_UNALIGNED_LITTLE_ENDIAN_MEM_ACCESS
-    return *(const double*)p;
-#else
-    unsigned val0 = (unsigned)(p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24));
-    unsigned val1 = (unsigned)(p[4] | (p[5] << 8) | (p[6] << 16) | (p[7] << 24));
-    Cv64suf val;
-    val.u = val0 | ((uint64)val1 << 32);
-    return val.f;
-#endif
-}
-
-static inline void writeInt(uchar* p, int ival)
-{
-#if CV_UNALIGNED_LITTLE_ENDIAN_MEM_ACCESS
-    int* ip = (int*)p;
-    *ip = ival;
-#else
-    p[0] = (uchar)ival;
-    p[1] = (uchar)(ival >> 8);
-    p[2] = (uchar)(ival >> 16);
-    p[3] = (uchar)(ival >> 24);
-#endif
-}
-
-static inline void writeReal(uchar* p, double fval)
-{
-#if CV_UNALIGNED_LITTLE_ENDIAN_MEM_ACCESS
-    double* fp = (double*)p;
-    *fp = fval;
-#else
-    Cv64suf v;
-    v.f = fval;
-    p[0] = (uchar)v.u;
-    p[1] = (uchar)(v.u >> 8);
-    p[2] = (uchar)(v.u >> 16);
-    p[3] = (uchar)(v.u >> 24);
-    p[4] = (uchar)(v.u >> 32);
-    p[5] = (uchar)(v.u >> 40);
-    p[6] = (uchar)(v.u >> 48);
-    p[7] = (uchar)(v.u >> 56);
-#endif
-}
-
-class FileStorage::Impl : public FileStorage_API
-{
-public:
-    void init()
-    {
-        flags = 0;
-        buffer.clear();
-        bufofs = 0;
-        state = UNDEFINED;
-        is_opened = false;
-        dummy_eof = false;
-        write_mode = false;
-        mem_mode = false;
-        space = 0;
-        wrap_margin = 71;
-        fmt = 0;
-        file = 0;
-        gzfile = 0;
-        empty_stream = true;
-
-        strbufv.clear();
-        strbuf = 0;
-        strbufsize = strbufpos = 0;
-        roots.clear();
-
-        fs_data.clear();
-        fs_data_ptrs.clear();
-        fs_data_blksz.clear();
-        freeSpaceOfs = 0;
-
-        str_hash.clear();
-        str_hash_data.clear();
-        str_hash_data.resize(1);
-        str_hash_data[0] = '\0';
-
-        filename.clear();
-        lineno = 0;
-    }
-
-    Impl(FileStorage* _fs)
-    {
-        fs_ext = _fs;
-        init();
-    }
-
-    virtual ~Impl()
-    {
-        release();
-    }
-
-    void release(String* out=0)
-    {
-        if( is_opened )
-        {
-            if(out)
-                out->clear();
-            if( write_mode )
-            {
-                while( write_stack.size() > 1 )
-                {
-                    endWriteStruct();
-                }
-                flush();
-                if( fmt == FileStorage::FORMAT_XML )
-                    puts( "</opencv_storage>\n" );
-                else if ( fmt == FileStorage::FORMAT_JSON )
-                    puts( "}\n" );
-            }
-            if( mem_mode && out )
-            {
-                *out = cv::String(outbuf.begin(), outbuf.end());
-            }
-        }
-        closeFile();
-        init();
-    }
-
-    void analyze_file_name( const std::string& file_name, std::vector<std::string>& params )
-    {
-        params.clear();
-        static const char not_file_name       = '\n';
-        static const char parameter_begin     = '?';
-        static const char parameter_separator = '&';
-
-        if( file_name.find(not_file_name, (size_t)0) != std::string::npos )
-            return;
-
-        size_t beg = file_name.find_last_of(parameter_begin);
-        params.push_back(file_name.substr((size_t)0, beg));
-
-        if( beg != std::string::npos )
-        {
-            size_t end = file_name.size();
-            beg++;
-            for( size_t param_beg = beg, param_end = beg;
-                 param_end < end;
-                 param_beg = param_end + 1 )
-            {
-                param_end = file_name.find_first_of( parameter_separator, param_beg );
-                if( (param_end == std::string::npos || param_end != param_beg) && param_beg + 1 < end )
-                {
-                    params.push_back( file_name.substr( param_beg, param_end - param_beg ) );
-                }
-            }
-        }
-    }
-
-    bool open( const char* filename_or_buf, int _flags, const char* encoding )
-    {
-        _flags &= ~FileStorage::BASE64;
-
-        bool ok = true;
-        release();
-
-        bool append = (_flags & 3) == FileStorage::APPEND;
-        mem_mode = (_flags & FileStorage::MEMORY) != 0;
-
-        write_mode = (_flags & 3) != 0;
-
-        bool isGZ = false;
-        size_t fnamelen = 0;
-
-        std::vector<std::string> params;
-        //if ( !mem_mode )
-        {
-            analyze_file_name( filename_or_buf, params );
-            if( !params.empty() )
-                filename = params[0];
-
-            /*if( !write_base64 && params.size() >= 2 &&
-                std::find(params.begin()+1, params.end(), std::string("base64")) != params.end())
-                write_base64 = (write_mode || append);*/
-        }
-
-        if( filename.size() == 0 && !mem_mode && !write_mode )
-            CV_Error( CV_StsNullPtr, "NULL or empty filename" );
-
-        if( mem_mode && append )
-            CV_Error( CV_StsBadFlag, "FileStorage::APPEND and FileStorage::MEMORY are not currently compatible" );
-
-        flags = _flags;
-
-        if( !mem_mode )
-        {
-            char* dot_pos = strrchr((char*)filename.c_str(), '.');
-            char compression = '\0';
-
-            if( dot_pos && dot_pos[1] == 'g' && dot_pos[2] == 'z' &&
-               (dot_pos[3] == '\0' || (cv_isdigit(dot_pos[3]) && dot_pos[4] == '\0')) )
-            {
-                if( append )
-                {
-                    CV_Error(CV_StsNotImplemented, "Appending data to compressed file is not implemented" );
-                }
-                isGZ = true;
-                compression = dot_pos[3];
-                if( compression )
-                    dot_pos[3] = '\0', fnamelen--;
-            }
-
-            if( !isGZ )
-            {
-                file = fopen(filename.c_str(), !write_mode ? "rt" : !append ? "wt" : "a+t" );
-                if( !file )
-                    return false;
-            }
-            else
-            {
-#if USE_ZLIB
-                char mode[] = { write_mode ? 'w' : 'r', 'b', compression ? compression : '3', '\0' };
-                gzfile = gzopen(filename.c_str(), mode);
-                if( !gzfile )
-                    return false;
-#else
-                CV_Error(CV_StsNotImplemented, "There is no compressed file storage support in this configuration");
-#endif
-            }
-        }
-
-        roots.clear();
-        fs_data.clear();
-        wrap_margin = 71;
-        fmt = FileStorage::FORMAT_AUTO;
-
-        if( write_mode )
-        {
-            fmt = flags & FileStorage::FORMAT_MASK;
-
-            if( mem_mode )
-                outbuf.clear();
-
-            if( fmt == FileStorage::FORMAT_AUTO && !filename.empty() )
-            {
-                const char* dot_pos = NULL;
-                const char* dot_pos2 = NULL;
-                // like strrchr() implementation, but save two last positions simultaneously
-                for (const char* pos = &filename[0]; pos[0] != 0; pos++)
-                {
-                    if( pos[0] == '.' )
-                    {
-                        dot_pos2 = dot_pos;
-                        dot_pos = pos;
-                    }
-                }
-                if (fs::strcasecmp(dot_pos, ".gz") == 0 && dot_pos2 != NULL)
-                {
-                    dot_pos = dot_pos2;
-                }
-                fmt = (fs::strcasecmp(dot_pos, ".xml") == 0 || fs::strcasecmp(dot_pos, ".xml.gz") == 0 )
-                        ? FileStorage::FORMAT_XML
-                    : (fs::strcasecmp(dot_pos, ".json") == 0 || fs::strcasecmp(dot_pos, ".json.gz") == 0)
-                        ? FileStorage::FORMAT_JSON
-                    : FileStorage::FORMAT_YAML;
-            }
-            else if( fmt == FileStorage::FORMAT_AUTO )
-            {
-                fmt = FileStorage::FORMAT_XML;
-            }
-
-            // we use factor=6 for XML (the longest characters (' and ") are encoded with 6 bytes (&apos; and &quot;)
-            // and factor=4 for YAML ( as we use 4 bytes for non ASCII characters (e.g. \xAB))
-            int buf_size = CV_FS_MAX_LEN*(fmt == FileStorage::FORMAT_XML ? 6 : 4) + 1024;
-
-            if (append)
-            {
-                fseek( file, 0, SEEK_END );
-                if (ftell(file) == 0)
-                    append = false;
-            }
-
-            write_stack.clear();
-            empty_stream = true;
-            write_stack.push_back(FStructData("", FileNode::MAP | FileNode::EMPTY, 0));
-            buffer.reserve(buf_size + 1024);
-            buffer.resize(buf_size);
-            bufofs = 0;
-
-            if( fmt == FileStorage::FORMAT_XML )
-            {
-                size_t file_size = file ? (size_t)ftell(file) : (size_t)0;
-                if( !append || file_size == 0 )
-                {
-                    if( encoding && *encoding != '\0' )
-                    {
-                        if( fs::strcasecmp(encoding, "UTF-16" ) == 0 )
-                        {
-                            release();
-                            CV_Error( CV_StsBadArg, "UTF-16 XML encoding is not supported! Use 8-bit encoding\n");
-                        }
-
-                        CV_Assert( strlen(encoding) < 1000 );
-                        char buf[1100];
-                        sprintf(buf, "<?xml version=\"1.0\" encoding=\"%s\"?>\n", encoding);
-                        puts( buf );
-                    }
-                    else
-                        puts( "<?xml version=\"1.0\"?>\n" );
-                    puts( "<opencv_storage>\n" );
-                }
-                else
-                {
-                    int xml_buf_size = 1 << 10;
-                    char substr[] = "</opencv_storage>";
-                    int last_occurrence = -1;
-                    xml_buf_size = MIN(xml_buf_size, int(file_size));
-                    fseek( file, -xml_buf_size, SEEK_END );
-                    // find the last occurrence of </opencv_storage>
-                    for(;;)
-                    {
-                        int line_offset = (int)ftell( file );
-                        const char* ptr0 = this->gets(xml_buf_size);
-                        const char* ptr = NULL;
-                        if( !ptr0 )
-                            break;
-                        ptr = ptr0;
-                        for(;;)
-                        {
-                            ptr = strstr( ptr, substr );
-                            if( !ptr )
-                                break;
-                            last_occurrence = line_offset + (int)(ptr - ptr0);
-                            ptr += strlen(substr);
-                        }
-                    }
-                    if( last_occurrence < 0 )
-                    {
-                        release();
-                        CV_Error( CV_StsError, "Could not find </opencv_storage> in the end of file.\n" );
-                    }
-                    closeFile();
-                    file = fopen( filename.c_str(), "r+t" );
-                    CV_Assert(file != 0);
-                    fseek( file, last_occurrence, SEEK_SET );
-                    // replace the last "</opencv_storage>" with " <!-- resumed -->", which has the same length
-                    puts( " <!-- resumed -->" );
-                    fseek( file, 0, SEEK_END );
-                    puts( "\n" );
-                }
-
-                emitter = createXMLEmitter(this);
-            }
-            else if( fmt == FileStorage::FORMAT_YAML )
-            {
-                if( !append)
-                    puts( "%YAML:1.0\n---\n" );
-                else
-                    puts( "...\n---\n" );
-
-                emitter = createYAMLEmitter(this);
-            }
-            else
-            {
-                CV_Assert( fmt == FileStorage::FORMAT_JSON );
-                if( !append )
-                    puts( "{\n" );
-                else
-                {
-                    bool valid = false;
-                    long roffset = 0;
-                    for ( ;
-                         fseek( file, roffset, SEEK_END ) == 0;
-                         roffset -= 1 )
-                    {
-                        const char end_mark = '}';
-                        if ( fgetc( file ) == end_mark )
-                        {
-                            fseek( file, roffset, SEEK_END );
-                            valid = true;
-                            break;
-                        }
-                    }
-
-                    if ( valid )
-                    {
-                        closeFile();
-                        file = fopen( filename.c_str(), "r+t" );
-                        CV_Assert(file != 0);
-                        fseek( file, roffset, SEEK_END );
-                        fputs( ",", file );
-                    }
-                    else
-                    {
-                        CV_Error( CV_StsError, "Could not find '}' in the end of file.\n" );
-                    }
-                }
-                write_stack.back().indent = 4;
-                emitter = createJSONEmitter(this);
-            }
-            is_opened = true;
-        }
-        else
-        {
-            const size_t buf_size0 = 40;
-            buffer.resize(buf_size0);
-            if( mem_mode )
-            {
-                strbuf = (char*)filename_or_buf;
-                strbufsize = strlen(strbuf);
-            }
-
-            const char* yaml_signature = "%YAML";
-            const char* json_signature = "{";
-            const char* xml_signature  = "<?xml";
-            char* buf = this->gets(16);
-            CV_Assert(buf);
-            char* bufPtr = cv_skip_BOM(buf);
-            size_t bufOffset = bufPtr - buf;
-
-            if(strncmp( bufPtr, yaml_signature, strlen(yaml_signature) ) == 0)
-                fmt = FileStorage::FORMAT_YAML;
-            else if(strncmp( bufPtr, json_signature, strlen(json_signature) ) == 0)
-                fmt = FileStorage::FORMAT_JSON;
-            else if(strncmp( bufPtr, xml_signature, strlen(xml_signature) ) == 0)
-                fmt = FileStorage::FORMAT_XML;
-            else if(strbufsize  == bufOffset)
-                CV_Error(CV_BADARG_ERR, "Input file is invalid");
-            else
-                CV_Error(CV_BADARG_ERR, "Unsupported file storage format");
-
-            rewind();
-            strbufpos = bufOffset;
-            bufofs = 0;
-
-            try
-            {
-                char* ptr = bufferStart();
-                ptr[0] = ptr[1] = ptr[2] = '\0';
-                FileNode root_nodes(fs_ext, 0, 0);
-
-                uchar* rptr = reserveNodeSpace(root_nodes, 9);
-                *rptr = FileNode::SEQ;
-                writeInt(rptr + 1, 4);
-                writeInt(rptr + 5, 0);
-
-                roots.clear();
-
-                switch (fmt)
-                {
-                    case FileStorage::FORMAT_XML: parser = createXMLParser(this); break;
-                    case FileStorage::FORMAT_YAML: parser = createYAMLParser(this); break;
-                    case FileStorage::FORMAT_JSON: parser = createJSONParser(this); break;
-                    default: parser = Ptr<FileStorageParser>();
-                }
-
-                if( !parser.empty() )
-                {
-                    ok = parser->parse(ptr);
-                    if( ok )
-                    {
-                        finalizeCollection(root_nodes);
-
-                        CV_Assert( !fs_data_ptrs.empty() );
-                        FileNode roots_node(fs_ext, 0, 0);
-                        size_t i, nroots = roots_node.size();
-                        FileNodeIterator it = roots_node.begin();
-
-                        for( i = 0; i < nroots; i++, ++it )
-                            roots.push_back(*it);
-                    }
-                }
-            }
-            catch(...)
-            {
-                is_opened = true;
-                release();
-                throw;
-            }
-
-            // release resources that we do not need anymore
-            closeFile();
-            is_opened = true;
-            std::vector<char> tmpbuf;
-            std::swap(buffer, tmpbuf);
-            bufofs = 0;
-        }
-        return ok;
-    }
-
-    void puts( const char* str )
-    {
-        CV_Assert( write_mode );
-        if( mem_mode )
-            std::copy(str, str + strlen(str), std::back_inserter(outbuf));
-        else if( file )
-            fputs( str, file );
-#if USE_ZLIB
-        else if( gzfile )
-            gzputs( gzfile, str );
-#endif
-        else
-            CV_Error( CV_StsError, "The storage is not opened" );
-    }
-
-    char* getsFromFile( char* buf, int count )
-    {
-        if( file )
-            return fgets( buf, count, file );
-    #if USE_ZLIB
-        if( gzfile )
-            return gzgets( gzfile, buf, count );
-    #endif
-        CV_Error(CV_StsError, "The storage is not opened");
-    }
-
-    char* gets( size_t maxCount )
-    {
-        if( strbuf )
-        {
-            size_t i = strbufpos, len = strbufsize;
-            const char* instr = strbuf;
-            for( ; i < len; i++ )
-            {
-                char c = instr[i];
-                if( c == '\0' || c == '\n' )
-                {
-                    if( c == '\n' )
-                        i++;
-                    break;
-                }
-            }
-            size_t count = i - strbufpos;
-            if( maxCount == 0 || maxCount > count )
-                maxCount = count;
-            buffer.resize(std::max(buffer.size(), maxCount + 8));
-            memcpy(&buffer[0], instr + strbufpos, maxCount);
-            buffer[maxCount] = '\0';
-            strbufpos = i;
-            return maxCount > 0 ? &buffer[0] : 0;
-        }
-
-        const size_t MAX_BLOCK_SIZE = INT_MAX/2; // hopefully, that will be enough
-        if( maxCount == 0 )
-            maxCount = MAX_BLOCK_SIZE;
-        else
-            CV_Assert(maxCount < MAX_BLOCK_SIZE);
-        size_t ofs = 0;
-
-        for(;;)
-        {
-            int count = (int)std::min(buffer.size() - ofs - 16, maxCount);
-            char* ptr = getsFromFile( &buffer[ofs], count+1 );
-            if( !ptr )
-                break;
-            int delta = (int)strlen(ptr);
-            ofs += delta;
-            maxCount -= delta;
-            if( ptr[delta-1] == '\n' || maxCount == 0 )
-                break;
-            if( delta == count )
-                buffer.resize((size_t)(buffer.size()*1.5));
-        }
-        return ofs > 0 ? &buffer[0] : 0;
-    }
-
-    char* gets()
-    {
-        char* ptr = this->gets(0);
-        if( !ptr )
-        {
-            ptr = bufferStart();  // FIXIT Why do we need this hack? What is about other parsers JSON/YAML?
-            *ptr = '\0';
-            setEof();
-            return 0;
-        }
-        else
-        {
-            size_t l = strlen(ptr);
-            if( l > 0 && ptr[l-1] != '\n' && ptr[l-1] != '\r' && !eof() )
-            {
-                ptr[l] = '\n';
-                ptr[l+1] = '\0';
-            }
-        }
-        lineno++;
-        return ptr;
-    }
-
-    bool eof()
-    {
-        if( dummy_eof )
-            return true;
-        if( strbuf )
-            return strbufpos >= strbufsize;
-        if( file )
-            return feof(file) != 0;
-#if USE_ZLIB
-        if( gzfile )
-            return gzeof(gzfile) != 0;
-#endif
-        return false;
-    }
-
-    void setEof()
-    {
-        dummy_eof = true;
-    }
-
-    void closeFile()
-    {
-        if( file )
-            fclose( file );
-#if USE_ZLIB
-        else if( gzfile )
-            gzclose( gzfile );
-#endif
-        file = 0;
-        gzfile = 0;
-        strbuf = 0;
-        strbufpos = 0;
-        is_opened = false;
-    }
-
-    void rewind()
-    {
-        if( file )
-            ::rewind(file);
-#if USE_ZLIB
-        else if( gzfile )
-            gzrewind(gzfile);
-#endif
-        strbufpos = 0;
-    }
-
-    char* resizeWriteBuffer( char* ptr, int len )
-    {
-        const char* buffer_end = &buffer[0] + buffer.size();
-        if( ptr + len < buffer_end )
-            return ptr;
-
-        const char* buffer_start = &buffer[0];
-        int written_len = (int)(ptr - buffer_start);
-
-        CV_Assert(written_len <= (int)buffer.size());
-        int new_size = (int)((buffer_end - buffer_start)*3/2);
-        new_size = MAX( written_len + len, new_size );
-        buffer.reserve( new_size + 256 );
-        buffer.resize( new_size );
-        bufofs = written_len;
-        return &buffer[0] + bufofs;
-    }
-
-    char* flush()
-    {
-        char* buffer_start = &buffer[0];
-        char* ptr = buffer_start + bufofs;
-
-        if( ptr > buffer_start + space )
-        {
-            ptr[0] = '\n';
-            ptr[1] = '\0';
-            puts( buffer_start );
-            bufofs = 0;
-        }
-
-        int indent = write_stack.back().indent;
-
-        if( space != indent )
-        {
-            memset( buffer_start, ' ', indent );
-            space = indent;
-        }
-        bufofs = space;
-        ptr = buffer_start + bufofs;
-
-        return ptr;
-    }
-
-    void endWriteStruct()
-    {
-        CV_Assert( write_mode );
-        CV_Assert( !write_stack.empty() );
-
-        FStructData& current_struct = write_stack.back();
-        if( fmt == FileStorage::FORMAT_JSON && !FileNode::isFlow(current_struct.flags) && write_stack.size() > 1 )
-            current_struct.indent = write_stack[write_stack.size() - 2].indent;
-
-        emitter->endWriteStruct(current_struct);
-
-        write_stack.pop_back();
-        if( !write_stack.empty() )
-            write_stack.back().flags &= ~FileNode::EMPTY;
-    }
-
-    void startWriteStruct( const char* key, int struct_flags,
-                           const char* type_name )
-    {
-        CV_Assert( write_mode );
-
-        struct_flags = (struct_flags & (FileNode::TYPE_MASK|FileNode::FLOW)) | FileNode::EMPTY;
-        if( !FileNode::isCollection(struct_flags))
-            CV_Error( CV_StsBadArg,
-                     "Some collection type: FileNode::SEQ or FileNode::MAP must be specified" );
-
-        if( type_name && type_name[0] == '\0' )
-            type_name = 0;
-
-        FStructData s = emitter->startWriteStruct( write_stack.back(), key, struct_flags, type_name );
-        write_stack.push_back(s);
-        size_t write_stack_size = write_stack.size();
-        if( write_stack_size > 1 )
-            write_stack[write_stack_size-2].flags &= ~FileNode::EMPTY;
-
-        if( !FileNode::isFlow(s.flags) )
-            flush();
-
-        if( fmt == FileStorage::FORMAT_JSON && type_name && type_name[0] && FileNode::isMap(struct_flags))
-        {
-            emitter->write("type_id", type_name, false);
-        }
-    }
-
-    void writeComment( const char* comment, bool eol_comment )
-    {
-        CV_Assert(write_mode);
-        emitter->writeComment( comment, eol_comment );
-    }
-
-    void startNextStream()
-    {
-        CV_Assert(write_mode);
-        if( !empty_stream )
-        {
-            while( !write_stack.empty() )
-                endWriteStruct();
-            flush();
-            emitter->startNextStream();
-            empty_stream = true;
-            write_stack.push_back(FStructData("", FileNode::EMPTY, 0));
-            bufofs = 0;
-        }
-    }
-
-    void write( const String& key, int value )
-    {
-        CV_Assert(write_mode);
-        emitter->write(key.c_str(), value);
-    }
-
-    void write( const String& key, double value )
-    {
-        CV_Assert(write_mode);
-        emitter->write(key.c_str(), value);
-    }
-
-    void write( const String& key, const String& value )
-    {
-        CV_Assert(write_mode);
-        emitter->write(key.c_str(), value.c_str(), false);
-    }
-
-    void writeRawData( const std::string& dt, const void* _data, size_t len )
-    {
-        CV_Assert(write_mode);
-
-        size_t elemSize = fs::calcStructSize(dt.c_str(), 0);
-        CV_Assert( len % elemSize == 0 );
-        len /= elemSize;
-
-        bool explicitZero = fmt == FileStorage::FORMAT_JSON;
-        const uchar* data0 = (const uchar*)_data;
-        int fmt_pairs[CV_FS_MAX_FMT_PAIRS*2], k, fmt_pair_count;
-        char buf[256] = "";
-
-        fmt_pair_count = fs::decodeFormat( dt.c_str(), fmt_pairs, CV_FS_MAX_FMT_PAIRS );
-
-        if( !len )
-            return;
-
-        if( !data0 )
-            CV_Error( CV_StsNullPtr, "Null data pointer" );
-
-        if( fmt_pair_count == 1 )
-        {
-            fmt_pairs[0] *= (int)len;
-            len = 1;
-        }
-
-        for(;len--; data0 += elemSize)
-        {
-            int offset = 0;
-            for( k = 0; k < fmt_pair_count; k++ )
-            {
-                int i, count = fmt_pairs[k*2];
-                int elem_type = fmt_pairs[k*2+1];
-                int elem_size = CV_ELEM_SIZE(elem_type);
-                const char *ptr;
-
-                offset = cvAlign( offset, elem_size );
-                const uchar* data = data0 + offset;
-
-                for( i = 0; i < count; i++ )
-                {
-                    switch( elem_type )
-                    {
-                    case CV_8U:
-                        ptr = fs::itoa( *(uchar*)data, buf, 10 );
-                        data++;
-                        break;
-                    case CV_8S:
-                        ptr = fs::itoa( *(char*)data, buf, 10 );
-                        data++;
-                        break;
-                    case CV_16U:
-                        ptr = fs::itoa( *(ushort*)data, buf, 10 );
-                        data += sizeof(ushort);
-                        break;
-                    case CV_16S:
-                        ptr = fs::itoa( *(short*)data, buf, 10 );
-                        data += sizeof(short);
-                        break;
-                    case CV_32S:
-                        ptr = fs::itoa( *(int*)data, buf, 10 );
-                        data += sizeof(int);
-                        break;
-                    case CV_32F:
-                        ptr = fs::floatToString( buf, *(float*)data, false, explicitZero );
-                        data += sizeof(float);
-                        break;
-                    case CV_64F:
-                        ptr = fs::doubleToString( buf, *(double*)data, explicitZero );
-                        data += sizeof(double);
-                        break;
-                    case CV_16F: /* reference */
-                        ptr = fs::floatToString( buf, (float)*(float16_t*)data, true, explicitZero );
-                        data += sizeof(float16_t);
-                        break;
-                    default:
-                        CV_Error( CV_StsUnsupportedFormat, "Unsupported type" );
-                        return;
-                    }
-
-                    emitter->writeScalar(0, ptr);
-                }
-
-                offset = (int)(data - data0);
-            }
-        }
-    }
-
-    void writeRawDataBase64(const void* /*data*/, int /*len*/, const char* /*dt*/ )
-    {
-
-    }
-
-    String releaseAndGetString();
-
-    FileNode getFirstTopLevelNode() const
-    {
-        return roots.empty() ? FileNode() : roots[0];
-    }
-
-    FileNode root(int streamIdx=0) const
-    {
-        return streamIdx >= 0 && streamIdx < (int)roots.size() ? roots[streamIdx] : FileNode();
-    }
-
-    FileNode operator[](const String& nodename) const
-    {
-        return this->operator[](nodename.c_str());
-    }
-
-    FileNode operator[](const char* /*nodename*/) const
-    {
-        return FileNode();
-    }
-
-    int getFormat() const { return fmt; }
-
-    char* bufferPtr() const { return (char*)(&buffer[0] + bufofs); }
-    char* bufferStart() const { return (char*)&buffer[0]; }
-    char* bufferEnd() const { return (char*)(&buffer[0] + buffer.size()); }
-    void setBufferPtr(char* ptr)
-    {
-        char* bufferstart = bufferStart();
-        CV_Assert( ptr >= bufferstart && ptr <= bufferEnd() );
-        bufofs = ptr - bufferstart;
-    }
-    int wrapMargin() const { return wrap_margin; }
-
-    FStructData& getCurrentStruct()
-    {
-        CV_Assert(!write_stack.empty());
-        return write_stack.back();
-    }
-
-    void setNonEmpty()
-    {
-        empty_stream = false;
-    }
-
-    void processSpecialDouble( char* buf, double* value, char** endptr )
-    {
-        FileStorage_API* fs = this;
-        char c = buf[0];
-        int inf_hi = 0x7ff00000;
-
-        if( c == '-' || c == '+' )
-        {
-            inf_hi = c == '-' ? 0xfff00000 : 0x7ff00000;
-            c = *++buf;
-        }
-
-        if( c != '.' )
-            CV_PARSE_ERROR_CPP( "Bad format of floating-point constant" );
-
-        Cv64suf v;
-        v.f = 0.;
-        if( toupper(buf[1]) == 'I' && toupper(buf[2]) == 'N' && toupper(buf[3]) == 'F' )
-            v.u = (uint64)inf_hi << 32;
-        else if( toupper(buf[1]) == 'N' && toupper(buf[2]) == 'A' && toupper(buf[3]) == 'N' )
-            v.u = (uint64)-1;
-        else
-            CV_PARSE_ERROR_CPP( "Bad format of floating-point constant" );
-        *value = v.f;
-        *endptr = buf + 4;
-    }
-
-    double strtod( char* ptr, char** endptr )
-    {
-        double fval = ::strtod( ptr, endptr );
-        if( **endptr == '.' )
-        {
-            char* dot_pos = *endptr;
-            *dot_pos = ',';
-            double fval2 = ::strtod( ptr, endptr );
-            *dot_pos = '.';
-            if( *endptr > dot_pos )
-                fval = fval2;
-            else
-                *endptr = dot_pos;
-        }
-
-        if( *endptr == ptr || cv_isalpha(**endptr) )
-            processSpecialDouble( ptr, &fval, endptr );
-
-        return fval;
-    }
-
-    void convertToCollection(int type, FileNode& node)
-    {
-        CV_Assert( type == FileNode::SEQ || type == FileNode::MAP );
-
-        int node_type = node.type();
-        if( node_type == type )
-            return;
-
-        bool named = node.isNamed();
-        uchar* ptr = node.ptr() + 1 + (named ? 4 : 0);
-
-        int ival = 0;
-        double fval = 0;
-        std::string sval;
-        bool add_first_scalar = false;
-
-        if( node_type != FileNode::NONE )
-        {
-            // scalar nodes can only be converted to sequences, e.g. in XML:
-            // <a>5[parser_position]... => create 5 with name "a"
-            // <a>5 6[parser_position]... => 5 is converted to [5] and then 6 is added to it
-            //
-            // otherwise we don't know where to get the element names from
-            CV_Assert( type == FileNode::SEQ );
-            if( node_type == FileNode::INT )
-            {
-                ival = readInt(ptr);
-                add_first_scalar = true;
-            }
-            else if( node_type == FileNode::REAL )
-            {
-                fval = readReal(ptr);
-                add_first_scalar = true;
-            }
-            else if( node_type == FileNode::STRING )
-            {
-                sval = std::string(node);
-                add_first_scalar = true;
-            }
-            else
-                CV_Error_(Error::StsError, ("The node of type %d cannot be converted to collection", node_type));
-        }
-
-        ptr = reserveNodeSpace(node, 1 + (named ? 4 : 0) + 4 + 4);
-        *ptr++ = (uchar)(type | (named ? FileNode::NAMED : 0));
-        // name has been copied automatically
-        if( named )
-            ptr += 4;
-        // set raw_size(collection)==4, nelems(collection)==1
-        writeInt(ptr, 4);
-        writeInt(ptr + 4, 0);
-
-        if( add_first_scalar )
-            addNode(node, std::string(), node_type,
-                    node_type == FileNode::INT ? (const void*)&ival :
-                    node_type == FileNode::REAL ? (const void*)&fval :
-                    node_type == FileNode::STRING ? (const void*)sval.c_str() : 0,
-                    -1);
-    }
-
-    // a) allocates new FileNode (for that just set blockIdx to the last block and ofs to freeSpaceOfs) or
-    // b) reallocates just created new node (blockIdx and ofs must be taken from FileNode).
-    //    If there is no enough space in the current block (it should be the last block added so far),
-    //    the last block is shrunk so that it ends immediately before the reallocated node. Then,
-    //    a new block of sufficient size is allocated and the FileNode is placed in the beginning of it.
-    // The case (a) can be used to allocate the very first node by setting blockIdx == ofs == 0.
-    // In the case (b) the existing tag and the name are copied automatically.
-    uchar* reserveNodeSpace(FileNode& node, size_t sz)
-    {
-        bool shrinkBlock = false;
-        size_t shrinkBlockIdx = 0, shrinkSize = 0;
-
-        uchar *ptr = 0, *blockEnd = 0;
-
-        if( !fs_data_ptrs.empty() )
-        {
-            size_t blockIdx = node.blockIdx;
-            size_t ofs = node.ofs;
-            CV_Assert( blockIdx == fs_data_ptrs.size()-1 );
-            CV_Assert( ofs <= fs_data_blksz[blockIdx] );
-            CV_Assert( freeSpaceOfs <= fs_data_blksz[blockIdx] );
-            //CV_Assert( freeSpaceOfs <= ofs + sz );
-
-            ptr = fs_data_ptrs[blockIdx] + ofs;
-            blockEnd = fs_data_ptrs[blockIdx] + fs_data_blksz[blockIdx];
-
-            CV_Assert(ptr >= fs_data_ptrs[blockIdx] && ptr <= blockEnd);
-            if( ptr + sz <= blockEnd )
-            {
-                freeSpaceOfs = ofs + sz;
-                return ptr;
-            }
-
-            if (ofs == 0)  // FileNode is a first component of this block. Resize current block instead of allocation of new one.
-            {
-                fs_data[blockIdx]->resize(sz);
-                ptr = &fs_data[blockIdx]->at(0);
-                fs_data_ptrs[blockIdx] = ptr;
-                fs_data_blksz[blockIdx] = sz;
-                freeSpaceOfs = sz;
-                return ptr;
-            }
-
-            shrinkBlock = true;
-            shrinkBlockIdx = blockIdx;
-            shrinkSize = ofs;
-        }
-
-        size_t blockSize = std::max((size_t)CV_FS_MAX_LEN*4 - 256, sz) + 256;
-        Ptr<std::vector<uchar> > pv = makePtr<std::vector<uchar> >(blockSize);
-        fs_data.push_back(pv);
-        uchar* new_ptr = &pv->at(0);
-        fs_data_ptrs.push_back(new_ptr);
-        fs_data_blksz.push_back(blockSize);
-        node.blockIdx = fs_data_ptrs.size()-1;
-        node.ofs = 0;
-        freeSpaceOfs = sz;
-
-        if( ptr && ptr + 5 <= blockEnd )
-        {
-            new_ptr[0] = ptr[0];
-            if( ptr[0] & FileNode::NAMED )
-            {
-                new_ptr[1] = ptr[1];
-                new_ptr[2] = ptr[2];
-                new_ptr[3] = ptr[3];
-                new_ptr[4] = ptr[4];
-            }
-        }
-
-        if (shrinkBlock)
-        {
-            fs_data[shrinkBlockIdx]->resize(shrinkSize);
-            fs_data_blksz[shrinkBlockIdx] = shrinkSize;
-        }
-
-        return new_ptr;
-    }
-
-    unsigned getStringOfs( const std::string& key ) const
-    {
-        str_hash_t::const_iterator it = str_hash.find(key);
-        return it != str_hash.end() ? it->second : 0;
-    }
-
-    FileNode addNode( FileNode& collection, const std::string& key,
-                       int elem_type, const void* value, int len )
-    {
-        FileStorage_API* fs = this;
-        bool noname = key.empty() || (fmt == FileStorage::FORMAT_XML && strcmp(key.c_str(), "_") == 0);
-        convertToCollection( noname ? FileNode::SEQ : FileNode::MAP, collection );
-
-        bool isseq = collection.empty() ? false : collection.isSeq();
-        if( noname != isseq )
-            CV_PARSE_ERROR_CPP( noname ? "Map element should have a name" :
-                                "Sequence element should not have name (use <_></_>)" );
-        unsigned strofs = 0;
-        if( !noname )
-        {
-            strofs = getStringOfs(key);
-            if( !strofs )
-            {
-                strofs = (unsigned)str_hash_data.size();
-                size_t keysize = key.size() + 1;
-                str_hash_data.resize(strofs + keysize);
-                memcpy(&str_hash_data[0] + strofs, &key[0], keysize);
-                str_hash.insert(std::make_pair(key, strofs));
-            }
-        }
-
-        uchar* cp = collection.ptr();
-
-        size_t blockIdx = fs_data_ptrs.size() - 1;
-        size_t ofs = freeSpaceOfs;
-        FileNode node(fs_ext, blockIdx, ofs);
-
-        size_t sz0 = 1 + (noname ? 0 : 4) + 8;
-        uchar* ptr = reserveNodeSpace(node, sz0);
-
-        *ptr++ = (uchar)(elem_type | (noname ? 0 : FileNode::NAMED));
-        if( elem_type == FileNode::NONE )
-            freeSpaceOfs -= 8;
-
-        if( !noname )
-        {
-            writeInt(ptr, (int)strofs);
-            ptr += 4;
-        }
-
-        if( elem_type == FileNode::SEQ || elem_type == FileNode::MAP )
-        {
-            writeInt(ptr, 4);
-            writeInt(ptr, 0);
-        }
-
-        if( value )
-            node.setValue(elem_type, value, len);
-
-        if( collection.isNamed() )
-            cp += 4;
-        int nelems = readInt(cp + 5);
-        writeInt(cp + 5, nelems + 1);
-
-        return node;
-    }
-
-    void finalizeCollection( FileNode& collection )
-    {
-        if( !collection.isSeq() && !collection.isMap() )
-            return;
-        uchar* ptr0 = collection.ptr(), *ptr = ptr0 + 1;
-        if( *ptr0 & FileNode::NAMED )
-            ptr += 4;
-        size_t blockIdx = collection.blockIdx;
-        size_t ofs = collection.ofs + (size_t)(ptr + 8 - ptr0);
-        size_t rawSize = 4;
-        unsigned sz = (unsigned)readInt(ptr + 4);
-        if( sz > 0 )
-        {
-            size_t lastBlockIdx = fs_data_ptrs.size() - 1;
-
-            for( ; blockIdx < lastBlockIdx; blockIdx++ )
-            {
-                rawSize += fs_data_blksz[blockIdx] - ofs;
-                ofs = 0;
-            }
-        }
-        rawSize += freeSpaceOfs - ofs;
-        writeInt(ptr, (int)rawSize);
-    }
-
-    void normalizeNodeOfs(size_t& blockIdx, size_t& ofs) const
-    {
-        while( ofs >= fs_data_blksz[blockIdx] )
-        {
-            if( blockIdx == fs_data_blksz.size() - 1 )
-            {
-                CV_Assert( ofs == fs_data_blksz[blockIdx] );
-                break;
-            }
-            ofs -= fs_data_blksz[blockIdx];
-            blockIdx++;
-        }
-    }
-
-    class Base64Decoder
-    {
-    public:
-        Base64Decoder() { ofs = 0; ptr = 0; indent = 0; totalchars = 0; eos = true; }
-        void init(Ptr<FileStorageParser>& _parser, char* _ptr, int _indent)
-        {
-            parser = _parser;
-            ptr = _ptr;
-            indent = _indent;
-            encoded.clear();
-            decoded.clear();
-            ofs = 0;
-            totalchars = 0;
-            eos = false;
-        }
-
-        bool readMore(int needed)
-        {
-            static const uchar base64tab[] =
-            {
-                0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-                0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-                0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 62,  0,  0,  0, 63,
-               52, 53, 54, 55, 56, 57, 58, 59, 60, 61,  0,  0,  0,  0,  0,  0,
-                0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
-               15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,  0,  0,  0,  0,  0,
-                0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-               41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,  0,  0,  0,  0,  0,
-                0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-                0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-                0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-                0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-                0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-                0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-                0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-                0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
-            };
-
-            if( eos )
-                return false;
-
-            size_t sz = decoded.size();
-            CV_Assert( ofs <= sz );
-            sz -= ofs;
-            for( size_t i = 0; i < sz; i++ )
-                decoded[i] = decoded[ofs + i];
-
-            decoded.resize(sz);
-            ofs = 0;
-
-            CV_Assert( !parser.empty() && ptr );
-            char *beg = 0, *end = 0;
-            bool ok = parser->getBase64Row(ptr, indent, beg, end);
-            ptr = end;
-            std::copy(beg, end, std::back_inserter(encoded));
-            totalchars += end - beg;
-
-            if( !ok || beg == end )
-            {
-                // in the end of base64 sequence pad it with '=' characters so that
-                // its total length is multiple of
-                eos = true;
-                size_t tc = totalchars;
-                for( ; tc % 4 != 0; tc++ )
-                    encoded.push_back('=');
-            }
-
-            int i = 0, j, n = (int)encoded.size();
-            if( n > 0 )
-            {
-                const uchar* tab = base64tab;
-                char* src = &encoded[0];
-
-                for( ; i <= n - 4; i += 4 )
-                {
-                    // dddddd cccccc bbbbbb aaaaaa => ddddddcc ccccbbbb bbaaaaaa
-                    uchar d = tab[(int)(uchar)src[i]], c = tab[(int)(uchar)src[i+1]];
-                    uchar b = tab[(int)(uchar)src[i+2]], a = tab[(int)(uchar)src[i+3]];
-
-                    decoded.push_back((uchar)((d << 2) | (c >> 4)));
-                    decoded.push_back((uchar)((c << 4) | (b >> 2)));
-                    decoded.push_back((uchar)((b << 6) | a));
-                }
-            }
-
-            if( i > 0 && encoded[i-1] == '=' )
-            {
-                if( i > 1 && encoded[i-2] == '=' && !decoded.empty() )
-                    decoded.pop_back();
-                if( !decoded.empty() )
-                    decoded.pop_back();
-            }
-
-            n -= i;
-            for( j = 0; j < n; j++ )
-                encoded[j] = encoded[i + j];
-            encoded.resize(n);
-
-            return (int)decoded.size() >= needed;
-        }
-
-        uchar getUInt8()
-        {
-            size_t sz = decoded.size();
-            if( ofs >= sz && !readMore(1) )
-                return (uchar)0;
-            return decoded[ofs++];
-        }
-
-        ushort getUInt16()
-        {
-            size_t sz = decoded.size();
-            if( ofs + 2 > sz && !readMore(2) )
-                return (ushort)0;
-            ushort val = (decoded[ofs] + (decoded[ofs + 1] << 8));
-            ofs += 2;
-            return val;
-        }
-
-        int getInt32()
-        {
-            size_t sz = decoded.size();
-            if( ofs + 4 > sz && !readMore(4) )
-                return 0;
-            int ival = readInt(&decoded[ofs]);
-            ofs += 4;
-            return ival;
-        }
-
-        double getFloat64()
-        {
-            size_t sz = decoded.size();
-            if( ofs + 8 > sz && !readMore(8) )
-                return 0;
-            double fval = readReal(&decoded[ofs]);
-            ofs += 8;
-            return fval;
-        }
-
-        bool endOfStream() const { return eos; }
-        char* getPtr() const { return ptr; }
-    protected:
-
-        Ptr<FileStorageParser> parser;
-        char* ptr;
-        int indent;
-        std::vector<char> encoded;
-        std::vector<uchar> decoded;
-        size_t ofs;
-        size_t totalchars;
-        bool eos;
-    };
-
-    char* parseBase64(char* ptr, int indent, FileNode& collection)
-    {
-        const int BASE64_HDR_SIZE = 24;
-        char dt[BASE64_HDR_SIZE+1] = {0};
-        base64decoder.init(parser, ptr, indent);
-
-        int i, k;
-
-        for( i = 0; i < BASE64_HDR_SIZE; i++ )
-            dt[i] = (char)base64decoder.getUInt8();
-        for( i = 0; i < BASE64_HDR_SIZE; i++ )
-            if( isspace(dt[i]))
-                break;
-        dt[i] = '\0';
-
-        CV_Assert( !base64decoder.endOfStream() );
-
-        int fmt_pairs[CV_FS_MAX_FMT_PAIRS*2];
-        int fmt_pair_count = fs::decodeFormat( dt, fmt_pairs, CV_FS_MAX_FMT_PAIRS );
-        int ival = 0;
-        double fval = 0;
-
-        for(;;)
-        {
-            for( k = 0; k < fmt_pair_count; k++ )
-            {
-                int elem_type = fmt_pairs[k*2+1];
-                int count = fmt_pairs[k*2];
-
-                for( i = 0; i < count; i++ )
-                {
-                    int node_type = FileNode::INT;
-                    switch( elem_type )
-                    {
-                    case CV_8U:
-                        ival = base64decoder.getUInt8();
-                        break;
-                    case CV_8S:
-                        ival = (char)base64decoder.getUInt8();
-                        break;
-                    case CV_16U:
-                        ival = base64decoder.getUInt16();
-                        break;
-                    case CV_16S:
-                        ival = (short)base64decoder.getUInt16();
-                        break;
-                    case CV_32S:
-                        ival = base64decoder.getInt32();
-                        break;
-                    case CV_32F:
-                        {
-                        Cv32suf v;
-                        v.i = base64decoder.getInt32();
-                        fval = v.f;
-                        node_type = FileNode::REAL;
-                        }
-                        break;
-                    case CV_64F:
-                        fval = base64decoder.getFloat64();
-                        node_type = FileNode::REAL;
-                        break;
-                    case CV_16F:
-                        fval = (float)float16_t::fromBits(base64decoder.getUInt16());
-                        node_type = FileNode::REAL;
-                        break;
-                    default:
-                        CV_Error( Error::StsUnsupportedFormat, "Unsupported type" );
-                    }
-
-                    if( base64decoder.endOfStream() )
-                        break;
-                    addNode(collection, std::string(), node_type,
-                            node_type == FileNode::INT ? (void*)&ival : (void*)&fval, -1);
-                }
-            }
-            if( base64decoder.endOfStream() )
-                break;
-        }
-
-        finalizeCollection(collection);
-        return base64decoder.getPtr();
-    }
-
-    void parseError( const char* func_name, const std::string& err_msg, const char* source_file, int source_line )
-    {
-        std::string msg = format("%s(%d): %s", filename.c_str(), lineno, err_msg.c_str());
-        error(Error::StsParseError, func_name, msg.c_str(), source_file, source_line );
-    }
-
-    const uchar* getNodePtr(size_t blockIdx, size_t ofs) const
-    {
-        CV_Assert( blockIdx < fs_data_ptrs.size());
-        CV_Assert( ofs < fs_data_blksz[blockIdx]);
-
-        return fs_data_ptrs[blockIdx] + ofs;
-    }
-
-    std::string getName( size_t nameofs ) const
-    {
-        CV_Assert( nameofs < str_hash_data.size() );
-        return std::string(&str_hash_data[nameofs]);
-    }
-
-    FileStorage* getFS() { return fs_ext; }
-
-    FileStorage* fs_ext;
-
-    std::string filename;
-    int flags;
-    bool empty_stream;
-
-    FILE* file;
-    gzFile gzfile;
-
-    bool is_opened;
-    bool dummy_eof;
-    bool write_mode;
-    bool mem_mode;
-    int fmt;
-
-    State state; //!< current state of the FileStorage (used only for writing)
-    int space, wrap_margin;
-    std::deque<FStructData> write_stack;
-    std::vector<char> buffer;
-    size_t bufofs;
-
-    std::deque<char> outbuf;
-
-    Ptr<FileStorageEmitter> emitter;
-    Ptr<FileStorageParser> parser;
-    Base64Decoder base64decoder;
-
-    std::vector<FileNode> roots;
-    std::vector<Ptr<std::vector<uchar> > > fs_data;
-    std::vector<uchar*> fs_data_ptrs;
-    std::vector<size_t> fs_data_blksz;
-    size_t freeSpaceOfs;
-    typedef std::unordered_map<std::string, unsigned> str_hash_t;
-    str_hash_t str_hash;
-    std::vector<char> str_hash_data;
-
-    std::vector<char> strbufv;
-    char* strbuf;
-    size_t strbufsize;
-    size_t strbufpos;
-    int lineno;
-};
-
-FileStorage::FileStorage()
-    : state(0)
-{
-    p = makePtr<FileStorage::Impl>(this);
-}
-
-FileStorage::FileStorage(const String& filename, int flags, const String& encoding)
-    : state(0)
-{
-    p = makePtr<FileStorage::Impl>(this);
-    bool ok = p->open(filename.c_str(), flags, encoding.c_str());
-    if(ok)
-        state = FileStorage::NAME_EXPECTED + FileStorage::INSIDE_MAP;
-}
-
-void FileStorage::startWriteStruct(const String& name, int struct_flags, const String& typeName)
-{
-    p->startWriteStruct(name.c_str(), struct_flags, typeName.c_str());
-    elname = String();
-    if ((struct_flags & FileNode::TYPE_MASK) == FileNode::SEQ)
-        state = FileStorage::VALUE_EXPECTED;
-    else
-        state = FileStorage::NAME_EXPECTED + FileStorage::INSIDE_MAP;
-}
-
-void FileStorage::endWriteStruct()
-{
-    p->endWriteStruct();
-    state = p->write_stack.empty() || FileNode::isMap(p->write_stack.back().flags) ?
-        FileStorage::NAME_EXPECTED + FileStorage::INSIDE_MAP :
-        FileStorage::VALUE_EXPECTED;
-    elname = String();
-}
-
-FileStorage::~FileStorage()
-{
-}
-
-bool FileStorage::open(const String& filename, int flags, const String& encoding)
-{
-    try
-    {
-        bool ok = p->open(filename.c_str(), flags, encoding.c_str());
-        if(ok)
-            state = FileStorage::NAME_EXPECTED + FileStorage::INSIDE_MAP;
-        return ok;
-    }
-    catch (...)
-    {
-        release();
-        throw;  // re-throw
-    }
-}
-
-bool FileStorage::isOpened() const { return p->is_opened; }
-
-void FileStorage::release()
-{
-    p->release();
-}
-
-FileNode FileStorage::root(int i) const
-{
-    if( p.empty() || p->roots.empty() || i < 0 || i >= (int)p->roots.size() )
-        return FileNode();
-
-    return p->roots[i];
-}
-
-FileNode FileStorage::getFirstTopLevelNode() const
-{
-    FileNode r = root();
-    FileNodeIterator it = r.begin();
-    return it != r.end() ? *it : FileNode();
-}
-
-std::string FileStorage::getDefaultObjectName(const std::string& _filename)
-{
-    static const char* stubname = "unnamed";
-    const char* filename = _filename.c_str();
-    const char* ptr2 = filename + _filename.size();
-    const char* ptr = ptr2 - 1;
-    cv::AutoBuffer<char> name_buf(_filename.size()+1);
-
-    while( ptr >= filename && *ptr != '\\' && *ptr != '/' && *ptr != ':' )
-    {
-        if( *ptr == '.' && (!*ptr2 || strncmp(ptr2, ".gz", 3) == 0) )
-            ptr2 = ptr;
-        ptr--;
-    }
-    ptr++;
-    if( ptr == ptr2 )
-        CV_Error( CV_StsBadArg, "Invalid filename" );
-
-    char* name = name_buf.data();
-
-    // name must start with letter or '_'
-    if( !cv_isalpha(*ptr) && *ptr!= '_' ){
-        *name++ = '_';
-    }
-
-    while( ptr < ptr2 )
-    {
-        char c = *ptr++;
-        if( !cv_isalnum(c) && c != '-' && c != '_' )
-            c = '_';
-        *name++ = c;
-    }
-    *name = '\0';
-    name = name_buf.data();
-    if( strcmp( name, "_" ) == 0 )
-        strcpy( name, stubname );
-    return name;
-}
-
-
-int FileStorage::getFormat() const
-{
-    return p->fmt;
-}
-
-FileNode FileStorage::operator [](const char* key) const
-{
-    return this->operator[](std::string(key));
-}
-
-FileNode FileStorage::operator [](const std::string& key) const
-{
-    FileNode res;
-    for (size_t i = 0; i < p->roots.size(); i++)
-    {
-        res = p->roots[i][key];
-        if (!res.empty())
-            break;
-    }
-    return res;
-}
-
-String FileStorage::releaseAndGetString()
-{
-    String buf;
-    p->release(&buf);
-    return buf;
-}
-
-void FileStorage::writeRaw( const String& fmt, const void* vec, size_t len )
-{
-    p->writeRawData(fmt, (const uchar*)vec, len);
-}
-
-void FileStorage::writeComment( const String& comment, bool eol_comment )
-{
-    p->writeComment(comment.c_str(), eol_comment);
-}
-
-void writeScalar( FileStorage& fs, int value )
-{
-    fs.p->write(String(), value);
-}
-
-void writeScalar( FileStorage& fs, float value )
-{
-    fs.p->write(String(), (double)value);
-}
-
-void writeScalar( FileStorage& fs, double value )
-{
-    fs.p->write(String(), value);
-}
-
-void writeScalar( FileStorage& fs, const String& value )
-{
-    fs.p->write(String(), value);
-}
-
-void write( FileStorage& fs, const String& name, int value )
-{
-    fs.p->write(name, value);
-}
-
-void write( FileStorage& fs, const String& name, float value )
-{
-    fs.p->write(name, (double)value);
-}
-
-void write( FileStorage& fs, const String& name, double value )
-{
-    fs.p->write(name, value);
-}
-
-void write( FileStorage& fs, const String& name, const String& value )
-{
-    fs.p->write(name, value);
-}
-
-void FileStorage::write(const String& name, int val) { p->write(name, val); }
-void FileStorage::write(const String& name, double val) { p->write(name, val); }
-void FileStorage::write(const String& name, const String& val) { p->write(name, val); }
-void FileStorage::write(const String& name, const Mat& val) { cv::write(*this, name, val); }
-void FileStorage::write(const String& name, const std::vector<String>& val) { cv::write(*this, name, val); }
-
-FileStorage& operator << (FileStorage& fs, const String& str)
-{
-    enum { NAME_EXPECTED = FileStorage::NAME_EXPECTED,
-        VALUE_EXPECTED = FileStorage::VALUE_EXPECTED,
-        INSIDE_MAP = FileStorage::INSIDE_MAP };
-    const char* _str = str.c_str();
-    if( !fs.isOpened() || !_str )
-        return fs;
-    Ptr<FileStorage::Impl>& fs_impl = fs.p;
-    char c = *_str;
-
-    if( c == '}' || c == ']' )
-    {
-        if( fs_impl->write_stack.empty() )
-            CV_Error_( CV_StsError, ("Extra closing '%c'", *_str) );
-
-        int struct_flags = fs_impl->write_stack.back().flags;
-        char expected_bracket = FileNode::isMap(struct_flags) ? '}' : ']';
-        if( c != expected_bracket )
-            CV_Error_( CV_StsError, ("The closing '%c' does not match the opening '%c'", c, expected_bracket));
-        fs_impl->endWriteStruct();
-        CV_Assert(!fs_impl->write_stack.empty());
-        struct_flags = fs_impl->write_stack.back().flags;
-        fs.state = FileNode::isMap(struct_flags) ? INSIDE_MAP + NAME_EXPECTED : VALUE_EXPECTED;
-        fs.elname = String();
-    }
-    else if( fs.state == NAME_EXPECTED + INSIDE_MAP )
-    {
-        if (!cv_isalpha(c) && c != '_')
-            CV_Error_( CV_StsError, ("Incorrect element name %s; should start with a letter or '_'", _str) );
-        fs.elname = str;
-        fs.state = VALUE_EXPECTED + INSIDE_MAP;
-    }
-    else if( (fs.state & 3) == VALUE_EXPECTED )
-    {
-        if( c == '{' || c == '[' )
-        {
-            int struct_flags = c == '{' ? FileNode::MAP : FileNode::SEQ;
-            fs.state = struct_flags == FileNode::MAP ? INSIDE_MAP + NAME_EXPECTED : VALUE_EXPECTED;
-            _str++;
-            if( *_str == ':' )
-            {
-                _str++;
-                if( !*_str )
-                    struct_flags |= FileNode::FLOW;
-            }
-            fs_impl->startWriteStruct(!fs.elname.empty() ? fs.elname.c_str() : 0, struct_flags, *_str ? _str : 0 );
-            fs.elname = String();
-        }
-        else
-        {
-            write( fs, fs.elname, (c == '\\' && (_str[1] == '{' || _str[1] == '}' ||
-                                _str[1] == '[' || _str[1] == ']')) ? String(_str+1) : str );
-            if( fs.state == INSIDE_MAP + VALUE_EXPECTED )
-                fs.state = INSIDE_MAP + NAME_EXPECTED;
-        }
-    }
-    else
-        CV_Error( CV_StsError, "Invalid fs.state" );
-    return fs;
-}
-
-
-FileNode::FileNode()
-    : fs(NULL)
-{
-    blockIdx = ofs = 0;
-}
-
-FileNode::FileNode(FileStorage::Impl* _fs, size_t _blockIdx, size_t _ofs)
-    : fs(_fs)
-{
-    blockIdx = _blockIdx;
-    ofs = _ofs;
-}
-
-FileNode::FileNode(const FileStorage* _fs, size_t _blockIdx, size_t _ofs)
-    : FileNode(_fs->p.get(), _blockIdx, _ofs)
-{
-    // nothing
-}
-
-FileNode::FileNode(const FileNode& node)
-{
-    fs = node.fs;
-    blockIdx = node.blockIdx;
-    ofs = node.ofs;
-}
-
-FileNode& FileNode::operator=(const FileNode& node)
-{
-    fs = node.fs;
-    blockIdx = node.blockIdx;
-    ofs = node.ofs;
-    return *this;
-}
-
-FileNode FileNode::operator[](const std::string& nodename) const
-{
-    if(!fs)
-        return FileNode();
-
-    CV_Assert( isMap() );
-
-    unsigned key = fs->getStringOfs(nodename);
-    size_t i, sz = size();
-    FileNodeIterator it = begin();
-
-    for( i = 0; i < sz; i++, ++it )
-    {
-        FileNode n = *it;
-        const uchar* p = n.ptr();
-        unsigned key2 = (unsigned)readInt(p + 1);
-        CV_Assert( key2 < fs->str_hash_data.size() );
-        if( key == key2 )
-            return n;
-    }
-    return FileNode();
-}
-
-FileNode FileNode::operator[](const char* nodename) const
-{
-    return this->operator[](std::string(nodename));
-}
-
-FileNode FileNode::operator[](int i) const
-{
-    if(!fs)
-        return FileNode();
-
-    CV_Assert( isSeq() );
-
-    int sz = (int)size();
-    CV_Assert( 0 <= i && i < sz );
-
-    FileNodeIterator it = begin();
-    it += i;
-
-    return *it;
-}
-
-std::vector<String> FileNode::keys() const
-{
-    CV_Assert(isMap());
-
-    std::vector<String> res;
-    res.reserve(size());
-    for (FileNodeIterator it = begin(); it != end(); ++it)
-    {
-        res.push_back((*it).name());
-    }
-    return res;
-}
-
-int FileNode::type() const
-{
-    const uchar* p = ptr();
-    if(!p)
-        return NONE;
-    return (*p & TYPE_MASK);
-}
-
-bool FileNode::isMap(int flags) { return (flags & TYPE_MASK) == MAP; }
-bool FileNode::isSeq(int flags) { return (flags & TYPE_MASK) == SEQ; }
-bool FileNode::isCollection(int flags) { return isMap(flags) || isSeq(flags); }
-bool FileNode::isFlow(int flags) { return (flags & FLOW) != 0; }
-bool FileNode::isEmptyCollection(int flags) { return (flags & EMPTY) != 0; }
-
-bool FileNode::empty() const   { return fs == 0; }
-bool FileNode::isNone() const  { return type() == NONE; }
-bool FileNode::isSeq() const   { return type() == SEQ; }
-bool FileNode::isMap() const   { return type() == MAP; }
-bool FileNode::isInt() const   { return type() == INT;  }
-bool FileNode::isReal() const  { return type() == REAL; }
-bool FileNode::isString() const { return type() == STRING;  }
-bool FileNode::isNamed() const
-{
-    const uchar* p = ptr();
-    if(!p)
-        return false;
-    return (*p & NAMED) != 0;
-}
-
-std::string FileNode::name() const
-{
-    const uchar* p = ptr();
-    if(!p)
-        return std::string();
-    size_t nameofs = p[1] | (p[2]<<8) | (p[3]<<16) | (p[4]<<24);
-    return fs->getName(nameofs);
-}
-
-FileNode::operator int() const
-{
-    const uchar* p = ptr();
-    if(!p)
-        return 0;
-    int tag = *p;
-    int type = (tag & TYPE_MASK);
-    p += (tag & NAMED) ? 5 : 1;
-
-    if( type == INT )
-    {
-        return readInt(p);
-    }
-    else if( type == REAL )
-    {
-        return cvRound(readReal(p));
-    }
-    else
-        return 0x7fffffff;
-}
-
-FileNode::operator float() const
-{
-    const uchar* p = ptr();
-    if(!p)
-        return 0.f;
-    int tag = *p;
-    int type = (tag & TYPE_MASK);
-    p += (tag & NAMED) ? 5 : 1;
-
-    if( type == INT )
-    {
-        return (float)readInt(p);
-    }
-    else if( type == REAL )
-    {
-        return (float)readReal(p);
-    }
-    else
-        return FLT_MAX;
-}
-
-FileNode::operator double() const
-{
-    const uchar* p = ptr();
-    if(!p)
-        return 0.f;
-    int tag = *p;
-    int type = (tag & TYPE_MASK);
-    p += (tag & NAMED) ? 5 : 1;
-
-    if( type == INT )
-    {
-        return (double)readInt(p);
-    }
-    else if( type == REAL )
-    {
-        return readReal(p);
-    }
-    else
-        return DBL_MAX;
-}
-
-double FileNode::real() const  { return double(*this); }
-std::string FileNode::string() const
-{
-    const uchar* p = ptr();
-    if( !p || (*p & TYPE_MASK) != STRING )
-        return std::string();
-    p += (*p & NAMED) ? 5 : 1;
-    size_t sz = (size_t)(unsigned)readInt(p);
-    return std::string((const char*)(p + 4), sz - 1);
-}
-Mat FileNode::mat() const { Mat value; read(*this, value, Mat()); return value; }
-
-FileNodeIterator FileNode::begin() const { return FileNodeIterator(*this, false); }
-FileNodeIterator FileNode::end() const   { return FileNodeIterator(*this, true); }
-
-void FileNode::readRaw( const std::string& fmt, void* vec, size_t len ) const
-{
-    FileNodeIterator it = begin();
-    it.readRaw( fmt, vec, len );
-}
-
-size_t FileNode::size() const
-{
-    const uchar* p = ptr();
-    if( !p )
-        return 0;
-    int tag = *p;
-    int tp = tag & TYPE_MASK;
-    if( tp == MAP || tp == SEQ )
-    {
-        if( tag & NAMED )
-            p += 4;
-        return (size_t)(unsigned)readInt(p + 5);
-    }
-    return tp != NONE;
-}
-
-size_t FileNode::rawSize() const
-{
-    const uchar* p0 = ptr(), *p = p0;
-    if( !p )
-        return 0;
-    int tag = *p++;
-    int tp = tag & TYPE_MASK;
-    if( tag & NAMED )
-        p += 4;
-    size_t sz0 = (size_t)(p - p0);
-    if( tp == INT )
-        return sz0 + 4;
-    if( tp == REAL )
-        return sz0 + 8;
-    if( tp == NONE )
-        return sz0;
-    CV_Assert( tp == STRING || tp == SEQ || tp == MAP );
-    return sz0 + 4 + readInt(p);
-}
-
-uchar* FileNode::ptr()
-{
-    return !fs ? 0 : (uchar*)fs->getNodePtr(blockIdx, ofs);
-}
-
-const uchar* FileNode::ptr() const
-{
-    return !fs ? 0 : fs->getNodePtr(blockIdx, ofs);
-}
-
-void FileNode::setValue( int type, const void* value, int len )
-{
-    uchar *p = ptr();
-    CV_Assert(p != 0);
-
-    int tag = *p;
-    int current_type = tag & TYPE_MASK;
-    CV_Assert( current_type == NONE || current_type == type );
-
-    int sz = 1;
-
-    if( tag & NAMED )
-        sz += 4;
-
-    if( type == INT )
-        sz += 4;
-    else if( type == REAL )
-        sz += 8;
-    else if( type == STRING )
-    {
-        if( len < 0 )
-            len = (int)strlen((const char*)value);
-        sz += 4 + len + 1; // besides the string content,
-                           // take the size (4 bytes) and the final '\0' into account
-    }
-    else
-        CV_Error(Error::StsNotImplemented, "Only scalar types can be dynamically assigned to a file node");
-
-    p = fs->reserveNodeSpace(*this, sz);
-    *p++ = (uchar)(type | (tag & NAMED));
-    if( tag & NAMED )
-        p += 4;
-
-    if( type == INT )
-    {
-        int ival = *(const int*)value;
-        writeInt(p, ival);
-    }
-    else if( type == REAL )
-    {
-        double dbval = *(const double*)value;
-        writeReal(p, dbval);
-    }
-    else if( type == STRING )
-    {
-        const char* str = (const char*)value;
-        writeInt(p, len + 1);
-        memcpy(p + 4, str, len);
-        p[4 + len] = (uchar)'\0';
-    }
-}
-
-FileNodeIterator::FileNodeIterator()
-{
-    fs = 0;
-    blockIdx = 0;
-    ofs = 0;
-    blockSize = 0;
-    nodeNElems = 0;
-    idx = 0;
-}
-
-FileNodeIterator::FileNodeIterator( const FileNode& node, bool seekEnd )
-{
-    fs = node.fs;
-    idx = 0;
-    if( !fs )
-        blockIdx = ofs = blockSize = nodeNElems = 0;
-    else
-    {
-        blockIdx = node.blockIdx;
-        ofs = node.ofs;
-
-        bool collection = node.isSeq() || node.isMap();
-        if( node.isNone() )
-        {
-            nodeNElems = 0;
-        }
-        else if( !collection )
-        {
-            nodeNElems = 1;
-            if( seekEnd )
-            {
-                idx = 1;
-                ofs += node.rawSize();
-            }
-        }
-        else
-        {
-            nodeNElems = node.size();
-            const uchar* p0 = node.ptr(), *p = p0 + 1;
-            if(*p0 & FileNode::NAMED )
-                p += 4;
-            if( !seekEnd )
-                ofs += (p - p0) + 8;
-            else
-            {
-                size_t rawsz = (size_t)(unsigned)readInt(p);
-                ofs += (p - p0) + 4 + rawsz;
-                idx = nodeNElems;
-            }
-        }
-        fs->normalizeNodeOfs(blockIdx, ofs);
-        blockSize = fs->fs_data_blksz[blockIdx];
-    }
-}
-
-FileNodeIterator::FileNodeIterator(const FileNodeIterator& it)
-{
-    fs = it.fs;
-    blockIdx = it.blockIdx;
-    ofs = it.ofs;
-    blockSize = it.blockSize;
-    nodeNElems = it.nodeNElems;
-    idx = it.idx;
-}
-
-FileNodeIterator& FileNodeIterator::operator=(const FileNodeIterator& it)
-{
-    fs = it.fs;
-    blockIdx = it.blockIdx;
-    ofs = it.ofs;
-    blockSize = it.blockSize;
-    nodeNElems = it.nodeNElems;
-    idx = it.idx;
-    return *this;
-}
-
-FileNode FileNodeIterator::operator *() const
-{
-    return FileNode(idx < nodeNElems ? fs : NULL, blockIdx, ofs);
-}
-
-FileNodeIterator& FileNodeIterator::operator ++ ()
-{
-    if( idx == nodeNElems || !fs )
-        return *this;
-    idx++;
-    FileNode n(fs, blockIdx, ofs);
-    ofs += n.rawSize();
-    if( ofs >= blockSize )
-    {
-        fs->normalizeNodeOfs(blockIdx, ofs);
-        blockSize = fs->fs_data_blksz[blockIdx];
-    }
-    return *this;
-}
-
-FileNodeIterator FileNodeIterator::operator ++ (int)
-{
-    FileNodeIterator it = *this;
-    ++(*this);
-    return it;
-}
-
-FileNodeIterator& FileNodeIterator::operator += (int _ofs)
-{
-    CV_Assert( _ofs >= 0 );
-    for( ; _ofs > 0; _ofs-- )
-        this->operator ++();
-    return *this;
-}
-
-FileNodeIterator& FileNodeIterator::readRaw( const String& fmt, void* _data0, size_t maxsz)
-{
-    if( fs && idx < nodeNElems )
-    {
-        uchar* data0 = (uchar*)_data0;
-        int fmt_pairs[CV_FS_MAX_FMT_PAIRS*2];
-        int fmt_pair_count = fs::decodeFormat( fmt.c_str(), fmt_pairs, CV_FS_MAX_FMT_PAIRS );
-        size_t esz = fs::calcStructSize( fmt.c_str(), 0 );
-
-        CV_Assert( maxsz % esz == 0 );
-        maxsz /= esz;
-
-        for( ; maxsz > 0; maxsz--, data0 += esz )
-        {
-            size_t offset = 0;
-            for( int k = 0; k < fmt_pair_count; k++ )
-            {
-                int elem_type = fmt_pairs[k*2+1];
-                int elem_size = CV_ELEM_SIZE(elem_type);
-
-                int count = fmt_pairs[k*2];
-                offset = alignSize( offset, elem_size );
-                uchar* data = data0 + offset;
-
-                for( int i = 0; i < count; i++, ++(*this) )
-                {
-                    FileNode node = *(*this);
-                    if( node.isInt() )
-                    {
-                        int ival = (int)node;
-                        switch( elem_type )
-                        {
-                        case CV_8U:
-                            *(uchar*)data = saturate_cast<uchar>(ival);
-                            data++;
-                            break;
-                        case CV_8S:
-                            *(char*)data = saturate_cast<schar>(ival);
-                            data++;
-                            break;
-                        case CV_16U:
-                            *(ushort*)data = saturate_cast<ushort>(ival);
-                            data += sizeof(ushort);
-                            break;
-                        case CV_16S:
-                            *(short*)data = saturate_cast<short>(ival);
-                            data += sizeof(short);
-                            break;
-                        case CV_32S:
-                            *(int*)data = ival;
-                            data += sizeof(int);
-                            break;
-                        case CV_32F:
-                            *(float*)data = (float)ival;
-                            data += sizeof(float);
-                            break;
-                        case CV_64F:
-                            *(double*)data = (double)ival;
-                            data += sizeof(double);
-                            break;
-                        case CV_16F:
-                            *(float16_t*)data = float16_t((float)ival);
-                            data += sizeof(float16_t);
-                            break;
-                        default:
-                            CV_Error( Error::StsUnsupportedFormat, "Unsupported type" );
-                        }
-                    }
-                    else if( node.isReal() )
-                    {
-                        double fval = (double)node;
-
-                        switch( elem_type )
-                        {
-                        case CV_8U:
-                            *(uchar*)data = saturate_cast<uchar>(fval);
-                            data++;
-                            break;
-                        case CV_8S:
-                            *(char*)data = saturate_cast<schar>(fval);
-                            data++;
-                            break;
-                        case CV_16U:
-                            *(ushort*)data = saturate_cast<ushort>(fval);
-                            data += sizeof(ushort);
-                            break;
-                        case CV_16S:
-                            *(short*)data = saturate_cast<short>(fval);
-                            data += sizeof(short);
-                            break;
-                        case CV_32S:
-                            *(int*)data = saturate_cast<int>(fval);
-                            data += sizeof(int);
-                            break;
-                        case CV_32F:
-                            *(float*)data = (float)fval;
-                            data += sizeof(float);
-                            break;
-                        case CV_64F:
-                            *(double*)data = fval;
-                            data += sizeof(double);
-                            break;
-                        case CV_16F:
-                            *(float16_t*)data = float16_t((float)fval);
-                            data += sizeof(float16_t);
-                            break;
-                        default:
-                            CV_Error( Error::StsUnsupportedFormat, "Unsupported type" );
-                        }
-                    }
-                    else
-                        CV_Error( Error::StsError, "readRawData can only be used to read plain sequences of numbers" );
-                }
-                offset = (int)(data - data0);
-            }
-        }
-    }
-
-    return *this;
-}
-
-bool FileNodeIterator::equalTo(const FileNodeIterator& it) const
-{
-    return fs == it.fs && blockIdx == it.blockIdx && ofs == it.ofs &&
-           idx == it.idx && nodeNElems == it.nodeNElems;
-}
-
-size_t FileNodeIterator::remaining() const
-{
-    return nodeNElems - idx;
-}
-
-bool operator == ( const FileNodeIterator& it1, const FileNodeIterator& it2 )
-{
-    return it1.equalTo(it2);
-}
-
-bool operator != ( const FileNodeIterator& it1, const FileNodeIterator& it2 )
-{
-    return !it1.equalTo(it2);
-}
-
-void read(const FileNode& node, int& val, int default_val)
-{
-    val = default_val;
-    if( !node.empty() )
-    {
-        val = (int)node;
-    }
-}
-
-void read(const FileNode& node, double& val, double default_val)
-{
-    val = default_val;
-    if( !node.empty() )
-    {
-        val = (double)node;
-    }
-}
-
-void read(const FileNode& node, float& val, float default_val)
-{
-    val = default_val;
-    if( !node.empty() )
-    {
-        val = (float)node;
-    }
-}
-
-void read(const FileNode& node, std::string& val, const std::string& default_val)
-{
-    val = default_val;
-    if( !node.empty() )
-    {
-        val = (std::string)node;
-    }
-}
-
-FileStorage_API::~FileStorage_API() {}
-
-namespace internal
-{
-
-WriteStructContext::WriteStructContext(FileStorage& _fs, const std::string& name,
-                                       int flags, const std::string& typeName)
-{
-    fs = &_fs;
-    fs->startWriteStruct(name, flags, typeName);
-}
-
-WriteStructContext::~WriteStructContext()
-{
-    fs->endWriteStruct();
-}
-
-}
-
-}
diff --git a/modules/core/src/persistence.hpp b/modules/core/src/persistence.hpp
deleted file mode 100644
index 05c7adc17c..0000000000
--- a/modules/core/src/persistence.hpp
+++ /dev/null
@@ -1,202 +0,0 @@
-// This file is part of OpenCV project.
-// It is subject to the license terms in the LICENSE file found in the top-level directory
-// of this distribution and at http://opencv.org/license.html
-
-
-#ifndef SRC_PERSISTENCE_HPP
-#define SRC_PERSISTENCE_HPP
-
-#include "opencv2/core/types_c.h"
-#include <deque>
-#include <sstream>
-#include <string>
-#include <iterator>
-
-#define USE_ZLIB 1
-#if USE_ZLIB
-#  ifndef _LFS64_LARGEFILE
-#    define _LFS64_LARGEFILE 0
-#  endif
-#  ifndef _FILE_OFFSET_BITS
-#    define _FILE_OFFSET_BITS 0
-#  endif
-#  include <zlib.h>
-#else
-typedef void* gzFile;
-#endif
-
-//=====================================================================================
-
-static const size_t PARSER_BASE64_BUFFER_SIZE = 1024U * 1024U / 8U;
-
-namespace base64 {
-
-enum
-{
-    HEADER_SIZE         = 24,
-    ENCODED_HEADER_SIZE = 32
-};
-
-} // base64::
-
-//=====================================================================================
-
-#define CV_FS_MAX_LEN 4096
-#define CV_FS_MAX_FMT_PAIRS  128
-
-/****************************************************************************************\
-*                            Common macros and type definitions                          *
-\****************************************************************************************/
-
-#define cv_isprint(c)     ((uchar)(c) >= (uchar)' ')
-#define cv_isprint_or_tab(c)  ((uchar)(c) >= (uchar)' ' || (c) == '\t')
-
-inline bool cv_isalnum(char c)
-{
-    return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z');
-}
-
-inline bool cv_isalpha(char c)
-{
-    return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z');
-}
-
-inline bool cv_isdigit(char c)
-{
-    return '0' <= c && c <= '9';
-}
-
-inline bool cv_isspace(char c)
-{
-    return (9 <= c && c <= 13) || c == ' ';
-}
-
-inline char* cv_skip_BOM(char* ptr)
-{
-    if((uchar)ptr[0] == 0xef && (uchar)ptr[1] == 0xbb && (uchar)ptr[2] == 0xbf) //UTF-8 BOM
-    {
-      return ptr + 3;
-    }
-    return ptr;
-}
-
-namespace cv
-{
-namespace fs
-{
-int strcasecmp(const char* str1, const char* str2);
-char* itoa( int _val, char* buffer, int /*radix*/ );
-char* floatToString( char* buf, float value, bool halfprecision, bool explicitZero );
-char* doubleToString( char* buf, double value, bool explicitZero );
-
-int calcStructSize( const char* dt, int initial_size );
-int calcElemSize( const char* dt, int initial_size );
-char* encodeFormat( int elem_type, char* dt );
-int decodeFormat( const char* dt, int* fmt_pairs, int max_len );
-int decodeSimpleFormat( const char* dt );
-}
-
-
-#ifdef CV_STATIC_ANALYSIS
-#define CV_PARSE_ERROR_CPP(errmsg) do { (void)fs; abort(); } while (0)
-#else
-#define CV_PARSE_ERROR_CPP( errmsg ) \
-    fs->parseError( CV_Func, (errmsg), __FILE__, __LINE__ )
-#endif
-
-
-#define CV_PERSISTENCE_CHECK_END_OF_BUFFER_BUG_CPP() do { \
-    CV_DbgAssert(ptr); \
-    if((ptr)[0] == 0 && (ptr) == fs->bufferEnd() - 1) CV_PARSE_ERROR_CPP("OpenCV persistence doesn't support very long lines"); \
-} while (0)
-
-
-class FileStorageParser;
-class FileStorageEmitter;
-
-struct FStructData
-{
-    FStructData() { indent = flags = 0; }
-    FStructData( const std::string& _struct_tag,
-                 int _struct_flags, int _struct_indent )
-    {
-        tag = _struct_tag;
-        flags = _struct_flags;
-        indent = _struct_indent;
-    }
-
-    std::string tag;
-    int flags;
-    int indent;
-};
-
-class FileStorage_API
-{
-public:
-    virtual ~FileStorage_API();
-    virtual FileStorage* getFS() = 0;
-
-    virtual void puts( const char* str ) = 0;
-    virtual char* gets() = 0;
-    virtual bool eof() = 0;
-    virtual void setEof() = 0;
-    virtual void closeFile() = 0;
-    virtual void rewind() = 0;
-    virtual char* resizeWriteBuffer( char* ptr, int len ) = 0;
-    virtual char* bufferPtr() const = 0;
-    virtual char* bufferStart() const = 0;
-    virtual char* bufferEnd() const = 0;
-    virtual void setBufferPtr(char* ptr) = 0;
-    virtual char* flush() = 0;
-    virtual void setNonEmpty() = 0;
-    virtual int wrapMargin() const = 0;
-
-    virtual FStructData& getCurrentStruct() = 0;
-
-    virtual void convertToCollection( int type, FileNode& node ) = 0;
-    virtual FileNode addNode( FileNode& collection, const std::string& key,
-                               int type, const void* value=0, int len=-1 ) = 0;
-    virtual void finalizeCollection( FileNode& collection ) = 0;
-    virtual double strtod(char* ptr, char** endptr) = 0;
-
-    virtual char* parseBase64(char* ptr, int indent, FileNode& collection) = 0;
-    CV_NORETURN
-    virtual void parseError(const char* funcname, const std::string& msg,
-                            const char* filename, int lineno) = 0;
-};
-
-class FileStorageEmitter
-{
-public:
-    virtual ~FileStorageEmitter() {}
-
-    virtual FStructData startWriteStruct( const FStructData& parent, const char* key,
-                                          int struct_flags, const char* type_name=0 ) = 0;
-    virtual void endWriteStruct(const FStructData& current_struct) = 0;
-    virtual void write(const char* key, int value) = 0;
-    virtual void write(const char* key, double value) = 0;
-    virtual void write(const char* key, const char* value, bool quote) = 0;
-    virtual void writeScalar(const char* key, const char* value) = 0;
-    virtual void writeComment(const char* comment, bool eol_comment) = 0;
-    virtual void startNextStream() = 0;
-};
-
-class FileStorageParser
-{
-public:
-    virtual ~FileStorageParser() {}
-    virtual bool parse(char* ptr) = 0;
-    virtual bool getBase64Row(char* ptr, int indent, char* &beg, char* &end) = 0;
-};
-
-Ptr<FileStorageEmitter> createXMLEmitter(FileStorage_API* fs);
-Ptr<FileStorageEmitter> createYAMLEmitter(FileStorage_API* fs);
-Ptr<FileStorageEmitter> createJSONEmitter(FileStorage_API* fs);
-
-Ptr<FileStorageParser> createXMLParser(FileStorage_API* fs);
-Ptr<FileStorageParser> createYAMLParser(FileStorage_API* fs);
-Ptr<FileStorageParser> createJSONParser(FileStorage_API* fs);
-
-}
-
-#endif // SRC_PERSISTENCE_HPP
diff --git a/modules/core/src/persistence_json.cpp b/modules/core/src/persistence_json.cpp
deleted file mode 100644
index 667895fbc5..0000000000
--- a/modules/core/src/persistence_json.cpp
+++ /dev/null
@@ -1,786 +0,0 @@
-// This file is part of OpenCV project.
-// It is subject to the license terms in the LICENSE file found in the top-level directory
-// of this distribution and at http://opencv.org/license.html
-
-#include "precomp.hpp"
-#include "persistence.hpp"
-
-namespace cv
-{
-
-class JSONEmitter : public FileStorageEmitter
-{
-public:
-    JSONEmitter(FileStorage_API* _fs) : fs(_fs)
-    {
-    }
-    virtual ~JSONEmitter() {}
-
-    FStructData startWriteStruct( const FStructData& parent, const char* key,
-                                  int struct_flags, const char* type_name=0 )
-    {
-        char data[CV_FS_MAX_LEN + 1024];
-
-        struct_flags = (struct_flags & (FileNode::TYPE_MASK|FileNode::FLOW)) | FileNode::EMPTY;
-        if( !FileNode::isCollection(struct_flags))
-            CV_Error( CV_StsBadArg,
-                     "Some collection type - FileNode::SEQ or FileNode::MAP, must be specified" );
-
-        if( type_name && *type_name == '\0' )
-            type_name = 0;
-
-        bool is_real_collection = true;
-        if (type_name && memcmp(type_name, "binary", 6) == 0)
-        {
-            struct_flags = FileNode::STR;
-            data[0] = '\0';
-            is_real_collection = false;
-        }
-
-        if ( is_real_collection )
-        {
-            char c = FileNode::isMap(struct_flags) ? '{' : '[';
-            data[0] = c;
-            data[1] = '\0';
-        }
-
-        writeScalar( key, data );
-        FStructData current_struct("", struct_flags, parent.indent + 4);
-
-        return current_struct;
-    }
-
-    void endWriteStruct(const FStructData& current_struct)
-    {
-        int struct_flags = current_struct.flags;
-        CV_Assert( FileNode::isCollection(struct_flags) );
-
-        if( !FileNode::isFlow(struct_flags) )
-        {
-#if 0
-            if ( fs->bufferPtr() <= fs->bufferStart() + fs->space )
-            {
-                /* some bad code for base64_writer... */
-                ptr = fs->bufferPtr();
-                *ptr++ = '\n';
-                *ptr++ = '\0';
-                fs->puts( fs->bufferStart() );
-                fs->setBufferPtr(fs->bufferStart());
-            }
-#endif
-            fs->flush();
-        }
-
-        char* ptr = fs->bufferPtr();
-        if( ptr > fs->bufferStart() + current_struct.indent && !FileNode::isEmptyCollection(struct_flags) )
-            *ptr++ = ' ';
-        *ptr++ = FileNode::isMap(struct_flags) ? '}' : ']';
-        fs->setBufferPtr(ptr);
-    }
-
-    void write(const char* key, int value)
-    {
-        char buf[128];
-        writeScalar( key, fs::itoa( value, buf, 10 ));
-    }
-
-    void write( const char* key, double value )
-    {
-        char buf[128];
-        writeScalar( key, fs::doubleToString( buf, value, true ));
-    }
-
-    void write(const char* key, const char* str, bool quote)
-    {
-        char buf[CV_FS_MAX_LEN*4+16];
-        char* data = (char*)str;
-        int i, len;
-
-        if( !str )
-            CV_Error( CV_StsNullPtr, "Null string pointer" );
-
-        len = (int)strlen(str);
-        if( len > CV_FS_MAX_LEN )
-            CV_Error( CV_StsBadArg, "The written string is too long" );
-
-        if( quote || len == 0 || str[0] != str[len-1] || (str[0] != '\"' && str[0] != '\'') )
-        {
-            int need_quote = 1;
-            data = buf;
-            *data++ = '\"';
-            for( i = 0; i < len; i++ )
-            {
-                char c = str[i];
-
-                switch ( c )
-                {
-                case '\\':
-                case '\"':
-                case '\'': { *data++ = '\\'; *data++ = c;   break; }
-                case '\n': { *data++ = '\\'; *data++ = 'n'; break; }
-                case '\r': { *data++ = '\\'; *data++ = 'r'; break; }
-                case '\t': { *data++ = '\\'; *data++ = 't'; break; }
-                case '\b': { *data++ = '\\'; *data++ = 'b'; break; }
-                case '\f': { *data++ = '\\'; *data++ = 'f'; break; }
-                default  : { *data++ = c; }
-                }
-            }
-
-            *data++ = '\"';
-            *data++ = '\0';
-            data = buf + !need_quote;
-        }
-
-        writeScalar( key, data);
-    }
-
-    void writeScalar(const char* key, const char* data)
-    {
-        size_t key_len = 0u;
-        if( key && *key == '\0' )
-            key = 0;
-        if ( key )
-        {
-            key_len = strlen(key);
-            if ( key_len == 0u )
-                CV_Error( CV_StsBadArg, "The key is an empty" );
-            else if ( static_cast<int>(key_len) > CV_FS_MAX_LEN )
-                CV_Error( CV_StsBadArg, "The key is too long" );
-        }
-
-        size_t data_len = 0u;
-        if ( data )
-            data_len = strlen(data);
-
-        FStructData& current_struct = fs->getCurrentStruct();
-        int struct_flags = current_struct.flags;
-        if( FileNode::isCollection(struct_flags) )
-        {
-            if ( (FileNode::isMap(struct_flags) ^ (key != 0)) )
-                CV_Error( CV_StsBadArg, "An attempt to add element without a key to a map, "
-                         "or add element with key to sequence" );
-        } else {
-            fs->setNonEmpty();
-            struct_flags = FileNode::EMPTY | (key ? FileNode::MAP : FileNode::SEQ);
-        }
-
-        // start to write
-        char* ptr = 0;
-
-        if( FileNode::isFlow(struct_flags) )
-        {
-            int new_offset;
-            ptr = fs->bufferPtr();
-            if( !FileNode::isEmptyCollection(struct_flags) )
-                *ptr++ = ',';
-            new_offset = static_cast<int>(ptr - fs->bufferStart() + key_len + data_len);
-            if( new_offset > fs->wrapMargin() && new_offset - current_struct.indent > 10 )
-            {
-                fs->setBufferPtr(ptr);
-                ptr = fs->flush();
-            }
-            else
-                *ptr++ = ' ';
-        }
-        else
-        {
-            if ( !FileNode::isEmptyCollection(struct_flags) )
-            {
-                ptr = fs->bufferPtr();
-                *ptr++ = ',';
-                *ptr++ = '\n';
-                *ptr++ = '\0';
-                fs->puts( fs->bufferStart() );
-                fs->setBufferPtr(fs->bufferStart());
-            }
-            ptr = fs->flush();
-        }
-
-        if( key )
-        {
-            if( !cv_isalpha(key[0]) && key[0] != '_' )
-                CV_Error( CV_StsBadArg, "Key must start with a letter or _" );
-
-            ptr = fs->resizeWriteBuffer( ptr, static_cast<int>(key_len) );
-            *ptr++ = '\"';
-
-            for( size_t i = 0u; i < key_len; i++ )
-            {
-                char c = key[i];
-
-                ptr[i] = c;
-                if( !cv_isalnum(c) && c != '-' && c != '_' && c != ' ' )
-                    CV_Error( CV_StsBadArg, "Key names may only contain alphanumeric characters [a-zA-Z0-9], '-', '_' and ' '" );
-            }
-
-            ptr += key_len;
-            *ptr++ = '\"';
-            *ptr++ = ':';
-            *ptr++ = ' ';
-        }
-
-        if( data )
-        {
-            ptr = fs->resizeWriteBuffer( ptr, static_cast<int>(data_len) );
-            memcpy( ptr, data, data_len );
-            ptr += data_len;
-        }
-
-        fs->setBufferPtr(ptr);
-        current_struct.flags &= ~FileNode::EMPTY;
-    }
-
-    void writeComment(const char* comment, bool eol_comment)
-    {
-        if( !comment )
-            CV_Error( CV_StsNullPtr, "Null comment" );
-
-        int len = static_cast<int>(strlen(comment));
-        char* ptr = fs->bufferPtr();
-        const char* eol = strchr(comment, '\n');
-        bool multiline = eol != 0;
-
-        if( !eol_comment || multiline || fs->bufferEnd() - ptr < len || ptr == fs->bufferStart() )
-            ptr = fs->flush();
-        else
-            *ptr++ = ' ';
-
-        while( comment )
-        {
-            *ptr++ = '/';
-            *ptr++ = '/';
-            *ptr++ = ' ';
-            if( eol )
-            {
-                ptr = fs->resizeWriteBuffer( ptr, (int)(eol - comment) + 1 );
-                memcpy( ptr, comment, eol - comment + 1 );
-                fs->setBufferPtr(ptr + (eol - comment));
-                comment = eol + 1;
-                eol = strchr( comment, '\n' );
-            }
-            else
-            {
-                len = (int)strlen(comment);
-                ptr = fs->resizeWriteBuffer( ptr, len );
-                memcpy( ptr, comment, len );
-                fs->setBufferPtr(ptr + len);
-                comment = 0;
-            }
-            ptr = fs->flush();
-        }
-    }
-
-    void startNextStream()
-    {
-        fs->puts( "...\n" );
-        fs->puts( "---\n" );
-    }
-
-protected:
-    FileStorage_API* fs;
-};
-
-class JSONParser : public FileStorageParser
-{
-public:
-    JSONParser(FileStorage_API* _fs) : fs(_fs)
-    {
-    }
-
-    virtual ~JSONParser() {}
-
-    char* skipSpaces( char* ptr )
-    {
-        bool is_eof = false;
-        bool is_completed = false;
-
-        while ( is_eof == false && is_completed == false )
-        {
-            if (!ptr)
-                CV_PARSE_ERROR_CPP("Invalid input");
-            switch ( *ptr )
-            {
-                /* comment */
-                case '/' : {
-                    ptr++;
-                    if ( *ptr == '\0' )
-                    {
-                        ptr = fs->gets();
-                        if( !ptr || !*ptr ) { is_eof = true; break; }
-                    }
-
-                    if ( *ptr == '/' )
-                    {
-                        while ( *ptr != '\n' && *ptr != '\r' )
-                        {
-                            if ( *ptr == '\0' )
-                            {
-                                ptr = fs->gets();
-                                if( !ptr || !*ptr ) { is_eof = true; break; }
-                            }
-                            else
-                            {
-                                ptr++;
-                            }
-                        }
-                    }
-                    else if ( *ptr == '*' )
-                    {
-                        ptr++;
-                        for (;;)
-                        {
-                            if ( *ptr == '\0' )
-                            {
-                                ptr = fs->gets();
-                                if( !ptr || !*ptr ) { is_eof = true; break; }
-                            }
-                            else if ( *ptr == '*' )
-                            {
-                                ptr++;
-                                if ( *ptr == '\0' )
-                                {
-                                    ptr = fs->gets();
-                                    if( !ptr || !*ptr ) { is_eof = true; break; }
-                                }
-                                if ( *ptr == '/' )
-                                {
-                                    ptr++;
-                                    break;
-                                }
-                            }
-                            else
-                            {
-                                ptr++;
-                            }
-                        }
-                    }
-                    else
-                    {
-                        CV_PARSE_ERROR_CPP( "Not supported escape character" );
-                    }
-                } break;
-                    /* whitespace */
-                case '\t':
-                case ' ' : {
-                    ptr++;
-                } break;
-                    /* newline || end mark */
-                case '\0':
-                case '\n':
-                case '\r': {
-                    ptr = fs->gets();
-                    if( !ptr || !*ptr ) { is_eof = true; break; }
-                } break;
-                    /* other character */
-                default: {
-                    if( !cv_isprint(*ptr) )
-                        CV_PARSE_ERROR_CPP( "Invalid character in the stream" );
-                    is_completed = true;
-                } break;
-            }
-        }
-
-        if ( is_eof || !is_completed )
-        {
-            ptr = fs->bufferStart();
-            CV_Assert(ptr);
-            *ptr = '\0';
-            fs->setEof();
-            if( !is_completed )
-                CV_PARSE_ERROR_CPP( "Abort at parse time" );
-        }
-
-        return ptr;
-    }
-
-    char* parseKey( char* ptr, FileNode& collection, FileNode& value_placeholder )
-    {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
-        if( *ptr != '"' )
-            CV_PARSE_ERROR_CPP( "Key must start with \'\"\'" );
-
-        char * beg = ptr + 1;
-
-        do {
-            ++ptr;
-            CV_PERSISTENCE_CHECK_END_OF_BUFFER_BUG_CPP();
-        } while( cv_isprint(*ptr) && *ptr != '"' );
-
-        if( *ptr != '"' )
-            CV_PARSE_ERROR_CPP( "Key must end with \'\"\'" );
-
-        if( ptr == beg )
-            CV_PARSE_ERROR_CPP( "Key is empty" );
-        value_placeholder = fs->addNode(collection, std::string(beg, (size_t)(ptr - beg)), FileNode::NONE);
-
-        ptr++;
-        ptr = skipSpaces( ptr );
-        if( !ptr || !*ptr )
-            return 0;
-
-        if( *ptr != ':' )
-            CV_PARSE_ERROR_CPP( "Missing \':\' between key and value" );
-
-        return ++ptr;
-    }
-
-    bool getBase64Row(char* ptr, int /*indent*/, char* &beg, char* &end)
-    {
-        beg = end = ptr;
-        if( !ptr || !*ptr )
-            return false;
-
-        // find end of the row
-        while( cv_isprint(*ptr) && (*ptr != ',') && (*ptr != '"'))
-            ++ptr;
-        if ( *ptr == '\0' )
-            CV_PARSE_ERROR_CPP( "Unexpected end of line" );
-
-        end = ptr;
-        return true;
-    }
-
-    char* parseValue( char* ptr, FileNode& node )
-    {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid value input");
-
-        ptr = skipSpaces( ptr );
-        if( !ptr || !*ptr )
-            CV_PARSE_ERROR_CPP( "Unexpected End-Of-File" );
-
-        if( *ptr == '"' )
-        {   /* must be string or Base64 string */
-            ptr++;
-            char * beg = ptr;
-            size_t len = 0u;
-            for ( ; (cv_isalnum(*ptr) || *ptr == '$' ) && len <= 9u; ptr++ )
-                len++;
-
-            if ((len >= 8u) && (memcmp( beg, "$base64$", 8u ) == 0) )
-            {   /**************** Base64 string ****************/
-                ptr = beg + 8;
-                ptr = fs->parseBase64(ptr, 0, node);
-
-                if ( *ptr != '\"' )
-                    CV_PARSE_ERROR_CPP( "'\"' - right-quote of string is missing" );
-                else
-                    ptr++;
-            }
-            else
-            {   /**************** normal string ****************/
-                int i = 0, sz;
-
-                ptr = beg;
-                bool is_matching = false;
-                while ( !is_matching )
-                {
-                    switch ( *ptr )
-                    {
-                        case '\\':
-                        {
-                            sz = (int)(ptr - beg);
-                            if( sz > 0 )
-                            {
-                                if (i + sz >= CV_FS_MAX_LEN)
-                                    CV_PARSE_ERROR_CPP("string is too long");
-                                memcpy(buf + i, beg, sz);
-                                i += sz;
-                            }
-                            ptr++;
-                            if (i + 1 >= CV_FS_MAX_LEN)
-                                CV_PARSE_ERROR_CPP("string is too long");
-                            switch ( *ptr )
-                            {
-                            case '\\':
-                            case '\"':
-                            case '\'': { buf[i++] = *ptr; break; }
-                            case 'n' : { buf[i++] = '\n'; break; }
-                            case 'r' : { buf[i++] = '\r'; break; }
-                            case 't' : { buf[i++] = '\t'; break; }
-                            case 'b' : { buf[i++] = '\b'; break; }
-                            case 'f' : { buf[i++] = '\f'; break; }
-                            case 'u' : { CV_PARSE_ERROR_CPP( "'\\uXXXX' currently not supported" ); break; }
-                            default  : { CV_PARSE_ERROR_CPP( "Invalid escape character" ); }
-                            break;
-                            }
-                            ptr++;
-                            beg = ptr;
-                            break;
-                        }
-                        case '\0':
-                        {
-                            sz = (int)(ptr - beg);
-                            if( sz > 0 )
-                            {
-                                if (i + sz >= CV_FS_MAX_LEN)
-                                    CV_PARSE_ERROR_CPP("string is too long");
-                                memcpy(buf + i, beg, sz);
-                                i += sz;
-                            }
-                            ptr = fs->gets();
-                            if ( !ptr || !*ptr )
-                                CV_PARSE_ERROR_CPP( "'\"' - right-quote of string is missing" );
-
-                            beg = ptr;
-                            break;
-                        }
-                        case '\"':
-                        {
-                            sz = (int)(ptr - beg);
-                            if( sz > 0 )
-                            {
-                                if (i + sz >= CV_FS_MAX_LEN)
-                                    CV_PARSE_ERROR_CPP("string is too long");
-                                memcpy(buf + i, beg, sz);
-                                i += sz;
-                            }
-                            beg = ptr;
-                            is_matching = true;
-                            break;
-                        }
-                        case '\n':
-                        case '\r':
-                        {
-                            CV_PARSE_ERROR_CPP( "'\"' - right-quote of string is missing" );
-                            break;
-                        }
-                        default:
-                        {
-                            ptr++;
-                            break;
-                        }
-                    }
-                }
-
-                if ( *ptr != '\"' )
-                    CV_PARSE_ERROR_CPP( "'\"' - right-quote of string is missing" );
-                else
-                    ptr++;
-
-                node.setValue(FileNode::STRING, buf, i);
-            }
-        }
-        else if ( cv_isdigit(*ptr) || *ptr == '-' || *ptr == '+' || *ptr == '.' )
-        {    /**************** number ****************/
-            char * beg = ptr;
-            if ( *ptr == '+' || *ptr == '-' )
-            {
-                ptr++;
-                CV_PERSISTENCE_CHECK_END_OF_BUFFER_BUG_CPP();
-            }
-            while( cv_isdigit(*ptr) )
-            {
-                ptr++;
-                CV_PERSISTENCE_CHECK_END_OF_BUFFER_BUG_CPP();
-            }
-            if (*ptr == '.' || *ptr == 'e')
-            {
-                double fval = fs->strtod( beg, &ptr );
-                CV_PERSISTENCE_CHECK_END_OF_BUFFER_BUG_CPP();
-
-                node.setValue(FileNode::REAL, &fval);
-            }
-            else
-            {
-                int ival = (int)strtol( beg, &ptr, 0 );
-                CV_PERSISTENCE_CHECK_END_OF_BUFFER_BUG_CPP();
-
-                node.setValue(FileNode::INT, &ival);
-            }
-
-            if ( beg >= ptr )
-                CV_PARSE_ERROR_CPP( "Invalid numeric value (inconsistent explicit type specification?)" );
-        }
-        else
-        {    /**************** other data ****************/
-            const char* beg = ptr;
-            int len = 0;
-            for ( ; cv_isalpha(*ptr) && len <= 6; )
-            {
-                len++;
-                ptr++;
-                CV_PERSISTENCE_CHECK_END_OF_BUFFER_BUG_CPP();
-            }
-
-            if( len == 4 && memcmp( beg, "null", 4 ) == 0 )
-            {
-                CV_PARSE_ERROR_CPP( "Value 'null' is not supported by this parser" );
-            }
-            else if( (len == 4 && memcmp( beg, "true", 4 ) == 0) ||
-                     (len == 5 && memcmp( beg, "false", 5 ) == 0) )
-            {
-                int ival = *beg == 't' ? 1 : 0;
-                node.setValue(FileNode::INT, &ival);
-            }
-            else
-            {
-                CV_PARSE_ERROR_CPP( "Unrecognized value" );
-            }
-        }
-
-        return ptr;
-    }
-
-    char* parseSeq( char* ptr, FileNode& node )
-    {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP( "ptr is NULL" );
-
-        if ( *ptr != '[' )
-            CV_PARSE_ERROR_CPP( "'[' - left-brace of seq is missing" );
-        else
-            ptr++;
-
-        fs->convertToCollection(FileNode::SEQ, node);
-
-        for (;;)
-        {
-            ptr = skipSpaces( ptr );
-            if( !ptr || !*ptr )
-                break;
-
-            if ( *ptr != ']' )
-            {
-                FileNode child = fs->addNode(node, std::string(), FileNode::NONE );
-
-                if ( *ptr == '[' )
-                    ptr = parseSeq( ptr, child );
-                else if ( *ptr == '{' )
-                    ptr = parseMap( ptr, child );
-                else
-                    ptr = parseValue( ptr, child );
-            }
-
-            ptr = skipSpaces( ptr );
-            if( !ptr || !*ptr )
-                break;
-
-            if ( *ptr == ',' )
-                ptr++;
-            else if ( *ptr == ']' )
-                break;
-            else
-                CV_PARSE_ERROR_CPP( "Unexpected character" );
-        }
-
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("ptr is NULL");
-
-        if ( *ptr != ']' )
-            CV_PARSE_ERROR_CPP( "']' - right-brace of seq is missing" );
-        else
-            ptr++;
-
-        fs->finalizeCollection(node);
-        return ptr;
-    }
-
-    char* parseMap( char* ptr, FileNode& node )
-    {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("ptr is NULL");
-
-        if ( *ptr != '{' )
-            CV_PARSE_ERROR_CPP( "'{' - left-brace of map is missing" );
-        else
-            ptr++;
-
-        fs->convertToCollection(FileNode::MAP, node);
-
-        for( ;; )
-        {
-            ptr = skipSpaces( ptr );
-            if( !ptr || !*ptr )
-                break;
-
-            if ( *ptr == '"' )
-            {
-                FileNode child;
-                ptr = parseKey( ptr, node, child );
-                if( !ptr || !*ptr )
-                    break;
-                ptr = skipSpaces( ptr );
-                if( !ptr || !*ptr )
-                    break;
-
-                if ( *ptr == '[' )
-                    ptr = parseSeq( ptr, child );
-                else if ( *ptr == '{' )
-                    ptr = parseMap( ptr, child );
-                else
-                    ptr = parseValue( ptr, child );
-            }
-
-            ptr = skipSpaces( ptr );
-            if( !ptr || !*ptr )
-                break;
-
-            if ( *ptr == ',' )
-                ptr++;
-            else if ( *ptr == '}' )
-                break;
-            else
-            {
-                CV_PARSE_ERROR_CPP( "Unexpected character" );
-            }
-        }
-
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("ptr is NULL");
-
-        if ( *ptr != '}' )
-            CV_PARSE_ERROR_CPP( "'}' - right-brace of map is missing" );
-        else
-            ptr++;
-
-        fs->finalizeCollection(node);
-        return ptr;
-    }
-
-    bool parse( char* ptr )
-    {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
-        ptr = skipSpaces( ptr );
-        if ( !ptr || !*ptr )
-            return false;
-
-        FileNode root_collection(fs->getFS(), 0, 0);
-
-        if( *ptr == '{' )
-        {
-            FileNode root_node = fs->addNode(root_collection, std::string(), FileNode::MAP);
-            parseMap( ptr, root_node );
-        }
-        else if ( *ptr == '[' )
-        {
-            FileNode root_node = fs->addNode(root_collection, std::string(), FileNode::SEQ);
-            parseSeq( ptr, root_node );
-        }
-        else
-        {
-            CV_PARSE_ERROR_CPP( "left-brace of top level is missing" );
-        }
-
-        return true;
-    }
-
-    FileStorage_API* fs;
-    char buf[CV_FS_MAX_LEN+1024];
-};
-
-Ptr<FileStorageEmitter> createJSONEmitter(FileStorage_API* fs)
-{
-    return makePtr<JSONEmitter>(fs);
-}
-
-Ptr<FileStorageParser> createJSONParser(FileStorage_API* fs)
-{
-    return makePtr<JSONParser>(fs);
-}
-
-}
diff --git a/modules/core/src/persistence_types.cpp b/modules/core/src/persistence_types.cpp
deleted file mode 100644
index eeebdafe75..0000000000
--- a/modules/core/src/persistence_types.cpp
+++ /dev/null
@@ -1,319 +0,0 @@
-// This file is part of OpenCV project.
-// It is subject to the license terms in the LICENSE file found in the top-level directory
-// of this distribution and at http://opencv.org/license.html
-
-#include "precomp.hpp"
-#include "persistence.hpp"
-
-namespace cv
-{
-
-void write( FileStorage& fs, const String& name, const Mat& m )
-{
-    char dt[16];
-
-    if( m.dims <= 2 )
-    {
-        fs.startWriteStruct(name, FileNode::MAP, String("opencv-matrix"));
-        fs << "rows" << m.rows;
-        fs << "cols" << m.cols;
-        fs << "dt" << fs::encodeFormat( m.type(), dt );
-        fs << "data" << "[:";
-        for( int i = 0; i < m.rows; i++ )
-            fs.writeRaw(dt, m.ptr(i), m.cols*m.elemSize());
-        fs << "]";
-        fs.endWriteStruct();
-    }
-    else
-    {
-        fs.startWriteStruct(name, FileNode::MAP, String("opencv-nd-matrix"));
-        fs << "sizes" << "[:";
-        fs.writeRaw( "i", m.size.p, m.dims*sizeof(int) );
-        fs << "]";
-        fs << "dt" << fs::encodeFormat( m.type(), dt );
-        fs << "data" << "[:";
-        const Mat* arrays[] = {&m, 0};
-        uchar* ptrs[1] = {};
-        NAryMatIterator it(arrays, ptrs);
-        size_t total = it.size*m.elemSize();
-
-        for( size_t i = 0; i < it.nplanes; i++, ++it )
-            fs.writeRaw( dt, ptrs[0], total );
-        fs << "]";
-        fs.endWriteStruct();
-    }
-}
-
-struct SparseNodeCmp
-{
-    SparseNodeCmp(int _dims) : dims(_dims) {}
-    bool operator()(const SparseMat::Node* a, const SparseMat::Node* b)
-    {
-        for( int i = 0; i < dims; i++ )
-        {
-            int d = a->idx[i] - b->idx[i];
-            if(d)
-                return d < 0;
-        }
-        return false;
-    }
-
-    int dims;
-};
-
-void write( FileStorage& fs, const String& name, const SparseMat& m )
-{
-    char dt[16];
-
-    fs.startWriteStruct(name, FileNode::MAP, String("opencv-sparse-matrix"));
-    fs << "sizes" << "[:";
-    int dims = m.dims();
-    if( dims > 0 )
-        fs.writeRaw("i", m.hdr->size, dims*sizeof(int) );
-    fs << "]";
-    fs << "dt" << fs::encodeFormat( m.type(), dt );
-    fs << "data" << "[:";
-
-    size_t i = 0, n = m.nzcount();
-    std::vector<const SparseMat::Node*> elems(n);
-    SparseMatConstIterator it = m.begin(), it_end = m.end();
-
-    for( ; it != it_end; ++it )
-    {
-        CV_Assert(it.node() != 0);
-        elems[i++] = it.node();
-    }
-
-    std::sort(elems.begin(), elems.end(), SparseNodeCmp(dims));
-    const SparseMat::Node* prev_node = 0;
-    size_t esz = m.elemSize();
-
-    for( i = 0; i < n; i++ )
-    {
-        const SparseMat::Node* node = elems[i];
-        int k = 0;
-
-        if( prev_node )
-        {
-            for( ; k < dims; k++ )
-                if( node->idx[k] != prev_node->idx[k] )
-                    break;
-            CV_Assert( k < dims );
-            if( k < dims - 1 )
-                writeScalar( fs, k - dims + 1 );
-        }
-        for( ; k < dims; k++ )
-            writeScalar( fs, node->idx[k] );
-        prev_node = node;
-
-        const uchar* value = &m.value<uchar>(node);
-        fs.writeRaw(dt, value, esz);
-    }
-
-    fs << "]" << "}";
-}
-
-void read(const FileNode& node, Mat& m, const Mat& default_mat)
-{
-    if( node.empty() )
-    {
-        default_mat.copyTo(m);
-        return;
-    }
-
-    std::string dt;
-    int rows, cols, elem_type;
-
-    read(node["dt"], dt, std::string());
-    CV_Assert( !dt.empty() );
-
-    elem_type = fs::decodeSimpleFormat( dt.c_str() );
-
-    read(node["rows"], rows, -1);
-    if( rows >= 0 )
-    {
-        read(node["cols"], cols, -1);
-        m.create(rows, cols, elem_type);
-    }
-    else
-    {
-        int sizes[CV_MAX_DIM] = {0}, dims;
-        FileNode sizes_node = node["sizes"];
-        CV_Assert( !sizes_node.empty() );
-
-        dims = (int)sizes_node.size();
-        sizes_node.readRaw("i", sizes, dims*sizeof(sizes[0]));
-
-        m.create(dims, sizes, elem_type);
-    }
-
-    FileNode data_node = node["data"];
-    CV_Assert(!data_node.empty());
-
-    size_t nelems = data_node.size();
-    CV_Assert(nelems == m.total()*m.channels());
-
-    data_node.readRaw(dt, (uchar*)m.ptr(), m.total()*m.elemSize());
-}
-
-void read( const FileNode& node, SparseMat& m, const SparseMat& default_mat )
-{
-    if( node.empty() )
-    {
-        default_mat.copyTo(m);
-        return;
-    }
-
-    std::string dt;
-    read(node["dt"], dt, std::string());
-    CV_Assert( !dt.empty() );
-
-    int elem_type = fs::decodeSimpleFormat( dt.c_str() );
-
-    int sizes[CV_MAX_DIM] = {0};
-    FileNode sizes_node = node["sizes"];
-    CV_Assert( !sizes_node.empty() );
-
-    int dims = (int)sizes_node.size();
-    sizes_node.readRaw("i", sizes, dims*sizeof(sizes[0]));
-
-    m.create(dims, sizes, elem_type);
-
-    FileNode data = node["data"];
-    CV_Assert( data.isSeq() );
-
-    int cn = CV_MAT_CN(elem_type);
-    int idx[CV_MAX_DIM] = {0};
-    size_t i, sz = data.size();
-    size_t esz = m.elemSize();
-    FileNodeIterator it = data.begin();
-
-    for( i = 0; i < sz; )
-    {
-        FileNode n = *it;
-        int k = (int)n;
-        if( i > 0 && k >= 0 )
-            idx[dims-1] = k;
-        else
-        {
-            if( i > 0 )
-                k = dims + k - 1;
-            else
-                idx[0] = k, k = 1;
-            for( ; k < dims; k++ )
-            {
-                ++it;
-                i++;
-                n = *it;
-                CV_Assert( n.isInt() );
-                int idx_k = (int)n;
-                CV_Assert( idx_k >= 0 );
-                idx[k] = idx_k;
-            }
-        }
-        ++it;
-        i++;
-        uchar* valptr = m.ptr(idx, true);
-        it.readRaw(dt, valptr, esz);
-        i += cn;
-    }
-}
-
-void read(const FileNode& node, KeyPoint& value, const KeyPoint& default_value)
-{
-    if( node.empty() )
-    {
-        value = default_value;
-        return;
-    }
-    node >> value;
-}
-
-void read(const FileNode& node, DMatch& value, const DMatch& default_value)
-{
-    if( node.empty() )
-    {
-        value = default_value;
-        return;
-    }
-    node >> value;
-}
-
-#ifdef CV__LEGACY_PERSISTENCE
-void write( FileStorage& fs, const std::string& name, const std::vector<KeyPoint>& vec)
-{
-    // from template implementation
-    cv::internal::WriteStructContext ws(fs, name, FileNode::SEQ);
-    write(fs, vec);
-}
-
-void read(const FileNode& node, std::vector<KeyPoint>& keypoints)
-{
-    FileNode first_node = *(node.begin());
-    if (first_node.isSeq())
-    {
-        // modern scheme
-#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
-        FileNodeIterator it = node.begin();
-        size_t total = (size_t)it.remaining;
-        keypoints.resize(total);
-        for (size_t i = 0; i < total; ++i, ++it)
-        {
-            (*it) >> keypoints[i];
-        }
-#else
-        FileNodeIterator it = node.begin();
-        it >> keypoints;
-#endif
-        return;
-    }
-    keypoints.clear();
-    FileNodeIterator it = node.begin(), it_end = node.end();
-    for( ; it != it_end; )
-    {
-        KeyPoint kpt;
-        it >> kpt.pt.x >> kpt.pt.y >> kpt.size >> kpt.angle >> kpt.response >> kpt.octave >> kpt.class_id;
-        keypoints.push_back(kpt);
-    }
-}
-
-void write( FileStorage& fs, const std::string& name, const std::vector<DMatch>& vec)
-{
-    // from template implementation
-    cv::internal::WriteStructContext ws(fs, name, FileNode::SEQ);
-    write(fs, vec);
-}
-
-void read(const FileNode& node, std::vector<DMatch>& matches)
-{
-    FileNode first_node = *(node.begin());
-    if (first_node.isSeq())
-    {
-        // modern scheme
-#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
-        FileNodeIterator it = node.begin();
-        size_t total = (size_t)it.remaining;
-        matches.resize(total);
-        for (size_t i = 0; i < total; ++i, ++it)
-        {
-            (*it) >> matches[i];
-        }
-#else
-        FileNodeIterator it = node.begin();
-        it >> matches;
-#endif
-        return;
-    }
-    matches.clear();
-    FileNodeIterator it = node.begin(), it_end = node.end();
-    for( ; it != it_end; )
-    {
-        DMatch m;
-        it >> m.queryIdx >> m.trainIdx >> m.imgIdx >> m.distance;
-        matches.push_back(m);
-    }
-}
-#endif
-
-
-}
diff --git a/modules/core/src/persistence_xml.cpp b/modules/core/src/persistence_xml.cpp
deleted file mode 100644
index 52b5374425..0000000000
--- a/modules/core/src/persistence_xml.cpp
+++ /dev/null
@@ -1,850 +0,0 @@
-// This file is part of OpenCV project.
-// It is subject to the license terms in the LICENSE file found in the top-level directory
-// of this distribution and at http://opencv.org/license.html
-
-
-#include "precomp.hpp"
-#include "persistence.hpp"
-
-enum
-{
-    CV_XML_INDENT = 2,
-    CV_XML_INSIDE_COMMENT = 1,
-    CV_XML_INSIDE_TAG = 2,
-    CV_XML_INSIDE_DIRECTIVE = 3,
-    CV_XML_OPENING_TAG = 1,
-    CV_XML_CLOSING_TAG = 2,
-    CV_XML_EMPTY_TAG = 3,
-    CV_XML_HEADER_TAG = 4,
-    CV_XML_DIRECTIVE_TAG = 5
-};
-
-namespace cv
-{
-
-class XMLEmitter : public FileStorageEmitter
-{
-public:
-    XMLEmitter(FileStorage_API* _fs) : fs(_fs)
-    {
-    }
-    virtual ~XMLEmitter() {}
-
-    void writeTag( const char* key, int tag_type, const std::vector<std::string>& attrlist=std::vector<std::string>() )
-    {
-        char* ptr = fs->bufferPtr();
-        int i, len = 0;
-        FStructData& current_struct = fs->getCurrentStruct();
-        int struct_flags = current_struct.flags;
-
-        if( key && key[0] == '\0' )
-            key = 0;
-
-        if( tag_type == CV_XML_OPENING_TAG || tag_type == CV_XML_EMPTY_TAG )
-        {
-            if( FileNode::isCollection(struct_flags) )
-            {
-                if( FileNode::isMap(struct_flags) ^ (key != 0) )
-                    CV_Error( CV_StsBadArg, "An attempt to add element without a key to a map, "
-                             "or add element with key to sequence" );
-            }
-            else
-            {
-                struct_flags = FileNode::EMPTY + (key ? FileNode::MAP : FileNode::SEQ);
-                //fs->is_first = 0;
-            }
-
-            if( !FileNode::isEmptyCollection(struct_flags) )
-                ptr = fs->flush();
-        }
-
-        if( !key )
-            key = "_";
-        else if( key[0] == '_' && key[1] == '\0' )
-            CV_Error( CV_StsBadArg, "A single _ is a reserved tag name" );
-
-        len = (int)strlen( key );
-        *ptr++ = '<';
-        if( tag_type == CV_XML_CLOSING_TAG )
-        {
-            if( !attrlist.empty() )
-                CV_Error( CV_StsBadArg, "Closing tag should not include any attributes" );
-            *ptr++ = '/';
-        }
-
-        if( !cv_isalpha(key[0]) && key[0] != '_' )
-            CV_Error( CV_StsBadArg, "Key should start with a letter or _" );
-
-        ptr = fs->resizeWriteBuffer( ptr, len );
-        for( i = 0; i < len; i++ )
-        {
-            char c = key[i];
-            if( !cv_isalnum(c) && c != '_' && c != '-' )
-                CV_Error( CV_StsBadArg, "Key name may only contain alphanumeric characters [a-zA-Z0-9], '-' and '_'" );
-            ptr[i] = c;
-        }
-        ptr += len;
-
-        int nattr = (int)attrlist.size();
-        CV_Assert( nattr % 2 == 0 );
-
-        for( i = 0; i < nattr; i += 2 )
-        {
-            size_t len0 = attrlist[i].size();
-            size_t len1 = attrlist[i+1].size();
-            CV_Assert( len0 > 0 );
-
-            ptr = fs->resizeWriteBuffer( ptr, (int)(len0 + len1 + 4) );
-            *ptr++ = ' ';
-
-            memcpy( ptr, attrlist[i].c_str(), len0 );
-            ptr += len0;
-            *ptr++ = '=';
-            *ptr++ = '\"';
-            if( len1 > 0 )
-                memcpy( ptr, attrlist[i+1].c_str(), len1 );
-            ptr += len1;
-            *ptr++ = '\"';
-        }
-
-        if( tag_type == CV_XML_EMPTY_TAG )
-            *ptr++ = '/';
-        *ptr++ = '>';
-        fs->setBufferPtr(ptr);
-        current_struct.flags = struct_flags & ~FileNode::EMPTY;
-    }
-
-    FStructData startWriteStruct(const FStructData& parent, const char* key,
-                                 int struct_flags, const char* type_name=0)
-    {
-        std::vector<std::string> attrlist;
-        if( type_name && *type_name )
-        {
-            attrlist.push_back("type_id");
-            attrlist.push_back(type_name);
-        }
-
-        writeTag( key, CV_XML_OPENING_TAG, attrlist );
-
-        FStructData current_struct;
-        current_struct.tag = key ? std::string(key) : std::string();
-        current_struct.flags = struct_flags;
-        current_struct.indent = parent.indent + CV_XML_INDENT;
-
-        return current_struct;
-    }
-
-    void endWriteStruct(const FStructData& current_struct)
-    {
-        writeTag( current_struct.tag.c_str(), CV_XML_CLOSING_TAG );
-    }
-
-    void write(const char* key, int value)
-    {
-        char buf[128], *ptr = fs::itoa( value, buf, 10 );
-        writeScalar( key, ptr);
-    }
-
-    void write( const char* key, double value )
-    {
-        char buf[128];
-        writeScalar( key, fs::doubleToString( buf, value, false ) );
-    }
-
-    void write(const char* key, const char* str, bool quote)
-    {
-        char buf[CV_FS_MAX_LEN*6+16];
-        char* data = (char*)str;
-        int i, len;
-
-        if( !str )
-            CV_Error( CV_StsNullPtr, "Null string pointer" );
-
-        len = (int)strlen(str);
-        if( len > CV_FS_MAX_LEN )
-            CV_Error( CV_StsBadArg, "The written string is too long" );
-
-        if( quote || len == 0 || str[0] != '\"' || str[0] != str[len-1] )
-        {
-            bool need_quote = quote || len == 0;
-            data = buf;
-            *data++ = '\"';
-            for( i = 0; i < len; i++ )
-            {
-                char c = str[i];
-
-                if( (uchar)c >= 128 || c == ' ' )
-                {
-                    *data++ = c;
-                    need_quote = true;
-                }
-                else if( !cv_isprint(c) || c == '<' || c == '>' || c == '&' || c == '\'' || c == '\"' )
-                {
-                    *data++ = '&';
-                    if( c == '<' )
-                    {
-                        memcpy(data, "lt", 2);
-                        data += 2;
-                    }
-                    else if( c == '>' )
-                    {
-                        memcpy(data, "gt", 2);
-                        data += 2;
-                    }
-                    else if( c == '&' )
-                    {
-                        memcpy(data, "amp", 3);
-                        data += 3;
-                    }
-                    else if( c == '\'' )
-                    {
-                        memcpy(data, "apos", 4);
-                        data += 4;
-                    }
-                    else if( c == '\"' )
-                    {
-                        memcpy( data, "quot", 4);
-                        data += 4;
-                    }
-                    else
-                    {
-                        sprintf( data, "#x%02x", (uchar)c );
-                        data += 4;
-                    }
-                    *data++ = ';';
-                    need_quote = 1;
-                }
-                else
-                    *data++ = c;
-            }
-            if( !need_quote && (cv_isdigit(str[0]) ||
-                                str[0] == '+' || str[0] == '-' || str[0] == '.' ))
-                need_quote = true;
-
-            if( need_quote )
-                *data++ = '\"';
-            len = (int)(data - buf) - !need_quote;
-            *data++ = '\0';
-            data = buf + (int)!need_quote;
-        }
-
-        writeScalar( key, data );
-    }
-
-    void writeScalar(const char* key, const char* data)
-    {
-        int len = (int)strlen(data);
-        if( key && *key == '\0' )
-            key = 0;
-
-        FStructData& current_struct = fs->getCurrentStruct();
-        int struct_flags = current_struct.flags;
-
-        if( FileNode::isMap(struct_flags) ||
-           (!FileNode::isCollection(struct_flags) && key) )
-        {
-            writeTag( key, CV_XML_OPENING_TAG );
-            char* ptr = fs->resizeWriteBuffer( fs->bufferPtr(), len );
-            memcpy( ptr, data, len );
-            fs->setBufferPtr( ptr + len );
-            writeTag( key, CV_XML_CLOSING_TAG );
-        }
-        else
-        {
-            char* ptr = fs->bufferPtr();
-            int new_offset = (int)(ptr - fs->bufferStart()) + len;
-
-            if( key )
-                CV_Error( CV_StsBadArg, "elements with keys can not be written to sequence" );
-
-            current_struct.flags = FileNode::SEQ;
-
-            if( (new_offset > fs->wrapMargin() && new_offset - current_struct.indent > 10) ||
-               (ptr > fs->bufferStart() && ptr[-1] == '>') )
-            {
-                ptr = fs->flush();
-            }
-            else if( ptr > fs->bufferStart() + current_struct.indent && ptr[-1] != '>' )
-                *ptr++ = ' ';
-
-            memcpy( ptr, data, len );
-            fs->setBufferPtr(ptr + len);
-        }
-    }
-
-    void writeComment(const char* comment, bool eol_comment)
-    {
-        FStructData& current_struct = fs->getCurrentStruct();
-        int len;
-        int multiline;
-        const char* eol;
-        char* ptr;
-
-        if( !comment )
-            CV_Error( CV_StsNullPtr, "Null comment" );
-
-        if( strstr(comment, "--") != 0 )
-            CV_Error( CV_StsBadArg, "Double hyphen \'--\' is not allowed in the comments" );
-
-        len = (int)strlen(comment);
-        eol = strchr(comment, '\n');
-        multiline = eol != 0;
-        ptr = fs->bufferPtr();
-
-        if( multiline || !eol_comment || fs->bufferEnd() - ptr < len + 5 )
-            ptr = fs->flush();
-        else if( ptr > fs->bufferStart() + current_struct.indent )
-            *ptr++ = ' ';
-
-        if( !multiline )
-        {
-            ptr = fs->resizeWriteBuffer( ptr, len + 9 );
-            sprintf( ptr, "<!-- %s -->", comment );
-            len = (int)strlen(ptr);
-        }
-        else
-        {
-            strcpy( ptr, "<!--" );
-            len = 4;
-        }
-
-        fs->setBufferPtr(ptr + len);
-        ptr = fs->flush();
-
-        if( multiline )
-        {
-            while( comment )
-            {
-                if( eol )
-                {
-                    ptr = fs->resizeWriteBuffer( ptr, (int)(eol - comment) + 1 );
-                    memcpy( ptr, comment, eol - comment + 1 );
-                    ptr += eol - comment;
-                    comment = eol + 1;
-                    eol = strchr( comment, '\n' );
-                }
-                else
-                {
-                    len = (int)strlen(comment);
-                    ptr = fs->resizeWriteBuffer( ptr, len );
-                    memcpy( ptr, comment, len );
-                    ptr += len;
-                    comment = 0;
-                }
-                fs->setBufferPtr(ptr);
-                ptr = fs->flush();
-            }
-            sprintf( ptr, "-->" );
-            fs->setBufferPtr(ptr + 3);
-            fs->flush();
-        }
-    }
-
-    void startNextStream()
-    {
-        fs->puts( "\n<!-- next stream -->\n" );
-    }
-
-protected:
-    FileStorage_API* fs;
-};
-
-class XMLParser : public FileStorageParser
-{
-public:
-    XMLParser(FileStorage_API* _fs) : fs(_fs)
-    {
-    }
-
-    virtual ~XMLParser() {}
-
-    char* skipSpaces( char* ptr, int mode )
-    {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
-        int level = 0;
-
-        for(;;)
-        {
-            char c;
-            ptr--;
-
-            if( mode == CV_XML_INSIDE_COMMENT )
-            {
-                do c = *++ptr;
-                while( cv_isprint_or_tab(c) && (c != '-' || ptr[1] != '-' || ptr[2] != '>') );
-
-                if( c == '-' )
-                {
-                    assert( ptr[1] == '-' && ptr[2] == '>' );
-                    mode = 0;
-                    ptr += 3;
-                }
-            }
-            else if( mode == CV_XML_INSIDE_DIRECTIVE )
-            {
-                // !!!NOTE!!! This is not quite correct, but should work in most cases
-                do
-                {
-                    c = *++ptr;
-                    level += c == '<';
-                    level -= c == '>';
-                    if( level < 0 )
-                        return ptr;
-                } while( cv_isprint_or_tab(c) );
-            }
-            else
-            {
-                do c = *++ptr;
-                while( c == ' ' || c == '\t' );
-
-                if( c == '<' && ptr[1] == '!' && ptr[2] == '-' && ptr[3] == '-' )
-                {
-                    if( mode != 0 )
-                        CV_PARSE_ERROR_CPP( "Comments are not allowed here" );
-                    mode = CV_XML_INSIDE_COMMENT;
-                    ptr += 4;
-                }
-                else if( cv_isprint(c) )
-                    break;
-            }
-
-            if( !cv_isprint(*ptr) )
-            {
-                if( *ptr != '\0' && *ptr != '\n' && *ptr != '\r' )
-                    CV_PARSE_ERROR_CPP( "Invalid character in the stream" );
-                ptr = fs->gets();
-                if( !ptr || *ptr == '\0' )
-                    break;
-            }
-        }
-        return ptr;
-    }
-
-    bool getBase64Row(char* ptr, int /*indent*/, char* &beg, char* &end)
-    {
-        beg = end = ptr = skipSpaces(ptr, CV_XML_INSIDE_TAG);
-        if( !ptr || !*ptr )
-            return false;
-
-        // closing XML tag
-        if ( *beg == '<' )
-            return false;
-
-        // find end of the row
-        while( cv_isprint(*ptr) )
-            ++ptr;
-        if ( *ptr == '\0' )
-            CV_PARSE_ERROR_CPP( "Unexpected end of line" );
-
-        end = ptr;
-        return true;
-    }
-
-    char* parseValue( char* ptr, FileNode& node )
-    {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
-        FileNode new_elem;
-        bool have_space = true;
-        int value_type = node.type();
-        std::string key, key2, type_name;
-
-        for(;;)
-        {
-            char c = *ptr, d;
-            char* endptr;
-
-            // FIXIT ptr[1], ptr[2] - out of bounds read without check or data fetch (#11061)
-            if( cv_isspace(c) || c == '\0' ||
-                (c == '<' && ptr[1] == '!' && ptr[2] == '-') )
-            {
-                ptr = skipSpaces( ptr, 0 );
-                if (!ptr)
-                    CV_PARSE_ERROR_CPP("Invalid input");
-                have_space = true;
-                c = *ptr;
-            }
-
-            d = ptr[1];  // FIXIT ptr[1] - out of bounds read without check or data fetch (#11061)
-
-            if( c =='<' || c == '\0' )
-            {
-                int tag_type = 0;
-                int elem_type = FileNode::NONE;
-
-                if( d == '/' || c == '\0' )
-                    break;
-
-                ptr = parseTag( ptr, key, type_name, tag_type );
-
-                if( tag_type == CV_XML_DIRECTIVE_TAG )
-                    CV_PARSE_ERROR_CPP( "Directive tags are not allowed here" );
-                if( tag_type == CV_XML_EMPTY_TAG )
-                    CV_PARSE_ERROR_CPP( "Empty tags are not supported" );
-
-                CV_Assert(tag_type == CV_XML_OPENING_TAG);
-
-                /* for base64 string */
-                bool binary_string = false;
-
-                if( !type_name.empty() )
-                {
-                    const char* tn = type_name.c_str();
-                    if( strcmp(tn, "str") == 0 )
-                        elem_type = FileNode::STRING;
-                    else if( strcmp( tn, "map" ) == 0 )
-                        elem_type = FileNode::MAP;
-                    else if( strcmp( tn, "seq" ) == 0 )
-                        elem_type = FileNode::SEQ;
-                    else if( strcmp( tn, "binary") == 0)
-                        binary_string = true;
-                }
-
-                new_elem = fs->addNode(node, key, elem_type, 0);
-                if (!binary_string)
-                    ptr = parseValue(ptr, new_elem);
-                else
-                {
-                    ptr = fs->parseBase64( ptr, 0, new_elem);
-                    ptr = skipSpaces( ptr, 0 );
-                    if (!ptr)
-                        CV_PARSE_ERROR_CPP("Invalid input");
-                }
-
-                ptr = parseTag( ptr, key2, type_name, tag_type );
-                if( tag_type != CV_XML_CLOSING_TAG || key2 != key )
-                    CV_PARSE_ERROR_CPP( "Mismatched closing tag" );
-                have_space = true;
-            }
-            else
-            {
-                if( !have_space )
-                    CV_PARSE_ERROR_CPP( "There should be space between literals" );
-
-                FileNode* elem = &node;
-                if( node.type() != FileNode::NONE )
-                {
-                    fs->convertToCollection( FileNode::SEQ, node );
-                    new_elem = fs->addNode(node, std::string(), FileNode::NONE, 0);
-                    elem = &new_elem;
-                }
-
-                if( value_type != FileNode::STRING &&
-                   (cv_isdigit(c) || ((c == '-' || c == '+') &&
-                   (cv_isdigit(d) || d == '.')) || (c == '.' && cv_isalnum(d))) ) // a number
-                {
-                    endptr = ptr + (c == '-' || c == '+');
-                    while( cv_isdigit(*endptr) )
-                        endptr++;
-                    if( *endptr == '.' || *endptr == 'e' )
-                    {
-                        double fval = fs->strtod( ptr, &endptr );
-                        elem->setValue(FileNode::REAL, &fval);
-                    }
-                    else
-                    {
-                        int ival = (int)strtol( ptr, &endptr, 0 );
-                        elem->setValue(FileNode::INT, &ival);
-                    }
-
-                    if( endptr == ptr )
-                        CV_PARSE_ERROR_CPP( "Invalid numeric value (inconsistent explicit type specification?)" );
-
-                    ptr = endptr;
-                    CV_PERSISTENCE_CHECK_END_OF_BUFFER_BUG_CPP();
-                }
-                else
-                {
-                    // string
-                    int i = 0, len, is_quoted = 0;
-                    if( c == '\"' )
-                        is_quoted = 1;
-                    else
-                        --ptr;
-                    strbuf[0] = '\0';
-
-                    for( ;; )
-                    {
-                        c = *++ptr;
-                        CV_PERSISTENCE_CHECK_END_OF_BUFFER_BUG_CPP();
-
-                        if( !cv_isalnum(c) )
-                        {
-                            if( c == '\"' )
-                            {
-                                if( !is_quoted )
-                                    CV_PARSE_ERROR_CPP( "Literal \" is not allowed within a string. Use &quot;" );
-                                ++ptr;
-                                break;
-                            }
-                            else if( !cv_isprint(c) || c == '<' || (!is_quoted && cv_isspace(c)))
-                            {
-                                if( is_quoted )
-                                    CV_PARSE_ERROR_CPP( "Closing \" is expected" );
-                                break;
-                            }
-                            else if( c == '\'' || c == '>' )
-                            {
-                                CV_PARSE_ERROR_CPP( "Literal \' or > are not allowed. Use &apos; or &gt;" );
-                            }
-                            else if( c == '&' )
-                            {
-                                if( *++ptr == '#' )
-                                {
-                                    int val, base = 10;
-                                    ptr++;
-                                    if( *ptr == 'x' )
-                                    {
-                                        base = 16;
-                                        ptr++;
-                                    }
-                                    val = (int)strtol( ptr, &endptr, base );
-                                    if( (unsigned)val > (unsigned)255 ||
-                                       !endptr || *endptr != ';' )
-                                        CV_PARSE_ERROR_CPP( "Invalid numeric value in the string" );
-                                    c = (char)val;
-                                }
-                                else
-                                {
-                                    endptr = ptr;
-                                    do c = *++endptr;
-                                    while( cv_isalnum(c) );
-                                    if( c != ';' )
-                                        CV_PARSE_ERROR_CPP( "Invalid character in the symbol entity name" );
-                                    len = (int)(endptr - ptr);
-                                    if( len == 2 && memcmp( ptr, "lt", len ) == 0 )
-                                        c = '<';
-                                    else if( len == 2 && memcmp( ptr, "gt", len ) == 0 )
-                                        c = '>';
-                                    else if( len == 3 && memcmp( ptr, "amp", len ) == 0 )
-                                        c = '&';
-                                    else if( len == 4 && memcmp( ptr, "apos", len ) == 0 )
-                                        c = '\'';
-                                    else if( len == 4 && memcmp( ptr, "quot", len ) == 0 )
-                                        c = '\"';
-                                    else
-                                    {
-                                        if (len + 2 + i >= CV_FS_MAX_LEN)
-                                            CV_PARSE_ERROR_CPP("string is too long");
-                                        memcpy( strbuf + i, ptr-1, len + 2 );
-                                        i += len + 2;
-                                    }
-                                }
-                                ptr = endptr;
-                                CV_PERSISTENCE_CHECK_END_OF_BUFFER_BUG_CPP();
-                            }
-                        }
-                        if (i + 1 >= CV_FS_MAX_LEN)
-                            CV_PARSE_ERROR_CPP("Too long string literal");
-                        strbuf[i++] = c;
-                    }
-                    elem->setValue(FileNode::STRING, strbuf, i);
-                }
-
-                if( value_type != FileNode::NONE && value_type != FileNode::SEQ && value_type != FileNode::MAP )
-                    break;
-                have_space = false;
-            }
-        }
-        fs->finalizeCollection(node);
-
-        return ptr;
-    }
-
-    char* parseTag( char* ptr, std::string& tag_name,
-                    std::string& type_name, int& tag_type )
-    {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid tag input");
-
-        if( *ptr == '\0' )
-            CV_PARSE_ERROR_CPP( "Unexpected end of the stream" );
-
-        if( *ptr != '<' )
-            CV_PARSE_ERROR_CPP( "Tag should start with \'<\'" );
-
-        ptr++;
-        CV_PERSISTENCE_CHECK_END_OF_BUFFER_BUG_CPP();
-
-        if( cv_isalnum(*ptr) || *ptr == '_' )
-            tag_type = CV_XML_OPENING_TAG;
-        else if( *ptr == '/' )
-        {
-            tag_type = CV_XML_CLOSING_TAG;
-            ptr++;
-        }
-        else if( *ptr == '?' )
-        {
-            tag_type = CV_XML_HEADER_TAG;
-            ptr++;
-        }
-        else if( *ptr == '!' )
-        {
-            tag_type = CV_XML_DIRECTIVE_TAG;
-            assert( ptr[1] != '-' || ptr[2] != '-' );
-            ptr++;
-        }
-        else
-            CV_PARSE_ERROR_CPP( "Unknown tag type" );
-
-        tag_name.clear();
-        type_name.clear();
-
-        for(;;)
-        {
-            char c, *endptr;
-            if( !cv_isalpha(*ptr) && *ptr != '_' )
-                CV_PARSE_ERROR_CPP( "Name should start with a letter or underscore" );
-
-            endptr = ptr - 1;
-            do c = *++endptr;
-            while( cv_isalnum(c) || c == '_' || c == '-' );
-
-            std::string attrname(ptr, (size_t)(endptr - ptr));
-            ptr = endptr;
-            CV_PERSISTENCE_CHECK_END_OF_BUFFER_BUG_CPP();
-
-            if( tag_name.empty() )
-                tag_name = attrname;
-            else
-            {
-                if( tag_type == CV_XML_CLOSING_TAG )
-                    CV_PARSE_ERROR_CPP( "Closing tag should not contain any attributes" );
-
-                if( *ptr != '=' )
-                {
-                    ptr = skipSpaces( ptr, CV_XML_INSIDE_TAG );
-                    if (!ptr)
-                        CV_PARSE_ERROR_CPP("Invalid attribute");
-                    if( *ptr != '=' )
-                        CV_PARSE_ERROR_CPP( "Attribute name should be followed by \'=\'" );
-                }
-
-                c = *++ptr;
-                if( c != '\"' && c != '\'' )
-                {
-                    ptr = skipSpaces( ptr, CV_XML_INSIDE_TAG );
-                    if( *ptr != '\"' && *ptr != '\'' )
-                        CV_PARSE_ERROR_CPP( "Attribute value should be put into single or double quotes" );
-                }
-
-                char quote = *ptr++;
-                endptr = ptr;
-                for(;;)
-                {
-                    c = *endptr++;
-                    if( c == quote )
-                        break;
-                    if( c == '\0' )
-                        CV_PARSE_ERROR_CPP( "Unexpected end of line" );
-                }
-
-                if( attrname == "type_id" )
-                {
-                    CV_Assert( type_name.empty() );
-                    type_name = std::string(ptr, (size_t)(endptr - 1 - ptr));
-                }
-
-                ptr = endptr;
-            }
-
-            c = *ptr;
-            bool have_space = cv_isspace(c) || c == '\0';
-
-            if( c != '>' )
-            {
-                ptr = skipSpaces( ptr, CV_XML_INSIDE_TAG );
-                if (!ptr)
-                    CV_PARSE_ERROR_CPP("Invalid input");
-                c = *ptr;
-            }
-
-            if( c == '>' )
-            {
-                if( tag_type == CV_XML_HEADER_TAG )
-                    CV_PARSE_ERROR_CPP( "Invalid closing tag for <?xml ..." );
-                ptr++;
-                break;
-            }
-            else if( c == '?' && tag_type == CV_XML_HEADER_TAG )
-            {
-                if( ptr[1] != '>'  )  // FIXIT ptr[1] - out of bounds read without check
-                    CV_PARSE_ERROR_CPP( "Invalid closing tag for <?xml ..." );
-                ptr += 2;
-                break;
-            }
-            else if( c == '/' && ptr[1] == '>' && tag_type == CV_XML_OPENING_TAG )  // FIXIT ptr[1] - out of bounds read without check
-            {
-                tag_type = CV_XML_EMPTY_TAG;
-                ptr += 2;
-                break;
-            }
-
-            if( !have_space )
-                CV_PARSE_ERROR_CPP( "There should be space between attributes" );
-        }
-
-        return ptr;
-    }
-
-    bool parse(char* ptr)
-    {
-        CV_Assert( fs != 0 );
-
-        std::string key, key2, type_name;
-        int tag_type = 0;
-        bool ok = false;
-
-        // CV_XML_INSIDE_TAG is used to prohibit leading comments
-        ptr = skipSpaces( ptr, CV_XML_INSIDE_TAG );
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
-        if( memcmp( ptr, "<?xml", 5 ) != 0 )  // FIXIT ptr[1..] - out of bounds read without check
-            CV_PARSE_ERROR_CPP( "Valid XML should start with \'<?xml ...?>\'" );
-
-        ptr = parseTag( ptr, key, type_name, tag_type );
-        FileNode root_collection(fs->getFS(), 0, 0);
-
-        while( ptr && *ptr != '\0' )
-        {
-            ptr = skipSpaces( ptr, 0 );
-            if (!ptr)
-                CV_PARSE_ERROR_CPP("Invalid input");
-
-            if( *ptr != '\0' )
-            {
-                ptr = parseTag( ptr, key, type_name, tag_type );
-                if( tag_type != CV_XML_OPENING_TAG || key != "opencv_storage" )
-                    CV_PARSE_ERROR_CPP( "<opencv_storage> tag is missing" );
-                FileNode root = fs->addNode(root_collection, std::string(), FileNode::MAP, 0);
-                ptr = parseValue( ptr, root );
-                ptr = parseTag( ptr, key2, type_name, tag_type );
-                if( tag_type != CV_XML_CLOSING_TAG || key != key2 )
-                    CV_PARSE_ERROR_CPP( "</opencv_storage> tag is missing" );
-                ptr = skipSpaces( ptr, 0 );
-                ok = true;
-            }
-        }
-        CV_Assert( fs->eof() );
-        return ok;
-    }
-
-    FileStorage_API* fs;
-    char strbuf[CV_FS_MAX_LEN+16];
-};
-
-Ptr<FileStorageEmitter> createXMLEmitter(FileStorage_API* fs)
-{
-    return makePtr<XMLEmitter>(fs);
-}
-
-Ptr<FileStorageParser> createXMLParser(FileStorage_API* fs)
-{
-    return makePtr<XMLParser>(fs);
-}
-
-}
diff --git a/modules/core/src/persistence_yml.cpp b/modules/core/src/persistence_yml.cpp
deleted file mode 100644
index 3f3742b8d1..0000000000
--- a/modules/core/src/persistence_yml.cpp
+++ /dev/null
@@ -1,859 +0,0 @@
-// This file is part of OpenCV project.
-// It is subject to the license terms in the LICENSE file found in the top-level directory
-// of this distribution and at http://opencv.org/license.html
-
-#include "precomp.hpp"
-#include "persistence.hpp"
-
-enum
-{
-    CV_YML_INDENT = 3,
-    CV_YML_INDENT_FLOW = 1
-};
-
-namespace cv
-{
-
-class YAMLEmitter : public FileStorageEmitter
-{
-public:
-    YAMLEmitter(FileStorage_API* _fs) : fs(_fs)
-    {
-    }
-    virtual ~YAMLEmitter() {}
-
-    FStructData startWriteStruct(const FStructData& parent, const char* key,
-                                 int struct_flags, const char* type_name=0)
-    {
-        char buf[CV_FS_MAX_LEN + 1024];
-        const char* data = 0;
-
-        if ( type_name && *type_name == '\0' )
-            type_name = 0;
-
-        struct_flags = (struct_flags & (FileNode::TYPE_MASK|FileNode::FLOW)) | FileNode::EMPTY;
-        if( !FileNode::isCollection(struct_flags))
-            CV_Error( CV_StsBadArg,
-                     "Some collection type - FileNode::SEQ or FileNode::MAP, must be specified" );
-
-        if (type_name && memcmp(type_name, "binary", 6) == 0)
-        {
-            /* reset struct flag. in order not to print ']' */
-            struct_flags = FileNode::SEQ;
-            sprintf(buf, "!!binary |");
-            data = buf;
-        }
-        else if( FileNode::isFlow(struct_flags))
-        {
-            char c = FileNode::isMap(struct_flags) ? '{' : '[';
-            struct_flags |= FileNode::FLOW;
-
-            if( type_name )
-                sprintf( buf, "!!%s %c", type_name, c );
-            else
-            {
-                buf[0] = c;
-                buf[1] = '\0';
-            }
-            data = buf;
-        }
-        else if( type_name )
-        {
-            sprintf( buf, "!!%s", type_name );
-            data = buf;
-        }
-
-        writeScalar( key, data );
-
-        FStructData fsd;
-        fsd.indent = parent.indent;
-        fsd.flags = struct_flags;
-
-        if( !FileNode::isFlow(parent.flags) )
-            fsd.indent += CV_YML_INDENT + FileNode::isFlow(struct_flags);
-
-        return fsd;
-    }
-
-    void endWriteStruct(const FStructData& current_struct)
-    {
-        char* ptr;
-
-        int struct_flags = current_struct.flags;
-
-        if( FileNode::isFlow(struct_flags) )
-        {
-            ptr = fs->bufferPtr();
-            if( ptr > fs->bufferStart() + current_struct.indent && !FileNode::isEmptyCollection(struct_flags) )
-                *ptr++ = ' ';
-            *ptr++ = FileNode::isMap(struct_flags) ? '}' : ']';
-            fs->setBufferPtr(ptr);
-        }
-        else if( FileNode::isEmptyCollection(struct_flags) )
-        {
-            ptr = fs->flush();
-            memcpy( ptr, FileNode::isMap(struct_flags) ? "{}" : "[]", 2 );
-            fs->setBufferPtr(ptr + 2);
-        }
-        /*
-        if( !FileNode::isFlow(parent_flags) )
-            fs->struct_indent -= CV_YML_INDENT + FileNode::isFlow(struct_flags);
-        assert( fs->struct_indent >= 0 );*/
-    }
-
-    void write(const char* key, int value)
-    {
-        char buf[128];
-        writeScalar( key, fs::itoa( value, buf, 10 ));
-    }
-
-    void write( const char* key, double value )
-    {
-        char buf[128];
-        writeScalar( key, fs::doubleToString( buf, value, false ));
-    }
-
-    void write(const char* key, const char* str, bool quote)
-    {
-        char buf[CV_FS_MAX_LEN*4+16];
-        char* data = (char*)str;
-        int i, len;
-
-        if( !str )
-            CV_Error( CV_StsNullPtr, "Null string pointer" );
-
-        len = (int)strlen(str);
-        if( len > CV_FS_MAX_LEN )
-            CV_Error( CV_StsBadArg, "The written string is too long" );
-
-        if( quote || len == 0 || str[0] != str[len-1] || (str[0] != '\"' && str[0] != '\'') )
-        {
-            int need_quote = quote || len == 0 || str[0] == ' ';
-            data = buf;
-            *data++ = '\"';
-            for( i = 0; i < len; i++ )
-            {
-                char c = str[i];
-
-                if( !need_quote && !cv_isalnum(c) && c != '_' && c != ' ' && c != '-' &&
-                   c != '(' && c != ')' && c != '/' && c != '+' && c != ';' )
-                    need_quote = 1;
-
-                if( !cv_isalnum(c) && (!cv_isprint(c) || c == '\\' || c == '\'' || c == '\"') )
-                {
-                    *data++ = '\\';
-                    if( cv_isprint(c) )
-                        *data++ = c;
-                    else if( c == '\n' )
-                        *data++ = 'n';
-                    else if( c == '\r' )
-                        *data++ = 'r';
-                    else if( c == '\t' )
-                        *data++ = 't';
-                    else
-                    {
-                        sprintf( data, "x%02x", c );
-                        data += 3;
-                    }
-                }
-                else
-                    *data++ = c;
-            }
-            if( !need_quote && (cv_isdigit(str[0]) ||
-                                str[0] == '+' || str[0] == '-' || str[0] == '.' ))
-                need_quote = 1;
-
-            if( need_quote )
-                *data++ = '\"';
-            *data++ = '\0';
-            data = buf + !need_quote;
-        }
-
-        writeScalar( key, data);
-    }
-
-    void writeScalar(const char* key, const char* data)
-    {
-        int i, keylen = 0;
-        int datalen = 0;
-        char* ptr;
-
-        FStructData& current_struct = fs->getCurrentStruct();
-
-        int struct_flags = current_struct.flags;
-
-        if( key && key[0] == '\0' )
-            key = 0;
-
-        if( FileNode::isCollection(struct_flags) )
-        {
-            if( (FileNode::isMap(struct_flags) ^ (key != 0)) )
-                CV_Error( CV_StsBadArg, "An attempt to add element without a key to a map, "
-                         "or add element with key to sequence" );
-        }
-        else
-        {
-            fs->setNonEmpty();
-            struct_flags = FileNode::EMPTY | (key ? FileNode::MAP : FileNode::SEQ);
-        }
-
-        if( key )
-        {
-            keylen = (int)strlen(key);
-            if( keylen == 0 )
-                CV_Error( CV_StsBadArg, "The key is an empty" );
-
-            if( keylen > CV_FS_MAX_LEN )
-                CV_Error( CV_StsBadArg, "The key is too long" );
-        }
-
-        if( data )
-            datalen = (int)strlen(data);
-
-        if( FileNode::isFlow(struct_flags) )
-        {
-            ptr = fs->bufferPtr();
-            if( !FileNode::isEmptyCollection(struct_flags) )
-                *ptr++ = ',';
-            int new_offset = (int)(ptr - fs->bufferStart()) + keylen + datalen;
-            if( new_offset > fs->wrapMargin() && new_offset - current_struct.indent > 10 )
-            {
-                fs->setBufferPtr(ptr);
-                ptr = fs->flush();
-            }
-            else
-                *ptr++ = ' ';
-        }
-        else
-        {
-            ptr = fs->flush();
-            if( !FileNode::isMap(struct_flags) )
-            {
-                *ptr++ = '-';
-                if( data )
-                    *ptr++ = ' ';
-            }
-        }
-
-        if( key )
-        {
-            if( !cv_isalpha(key[0]) && key[0] != '_' )
-                CV_Error( CV_StsBadArg, "Key must start with a letter or _" );
-
-            ptr = fs->resizeWriteBuffer( ptr, keylen );
-
-            for( i = 0; i < keylen; i++ )
-            {
-                char c = key[i];
-
-                ptr[i] = c;
-                if( !cv_isalnum(c) && c != '-' && c != '_' && c != ' ' )
-                    CV_Error( CV_StsBadArg, "Key names may only contain alphanumeric characters [a-zA-Z0-9], '-', '_' and ' '" );
-            }
-
-            ptr += keylen;
-            *ptr++ = ':';
-            if( !FileNode::isFlow(struct_flags) && data )
-                *ptr++ = ' ';
-        }
-
-        if( data )
-        {
-            ptr = fs->resizeWriteBuffer( ptr, datalen );
-            memcpy( ptr, data, datalen );
-            ptr += datalen;
-        }
-
-        fs->setBufferPtr(ptr);
-        current_struct.flags &= ~FileNode::EMPTY;
-    }
-
-    void writeComment(const char* comment, bool eol_comment)
-    {
-        if( !comment )
-            CV_Error( CV_StsNullPtr, "Null comment" );
-
-        int len = (int)strlen(comment);
-        const char* eol = strchr(comment, '\n');
-        bool multiline = eol != 0;
-        char* ptr = fs->bufferPtr();
-
-        if( !eol_comment || multiline ||
-            fs->bufferEnd() - ptr < len || ptr == fs->bufferStart() )
-            ptr = fs->flush();
-        else
-            *ptr++ = ' ';
-
-        while( comment )
-        {
-            *ptr++ = '#';
-            *ptr++ = ' ';
-            if( eol )
-            {
-                ptr = fs->resizeWriteBuffer( ptr, (int)(eol - comment) + 1 );
-                memcpy( ptr, comment, eol - comment + 1 );
-                fs->setBufferPtr(ptr + (eol - comment));
-                comment = eol + 1;
-                eol = strchr( comment, '\n' );
-            }
-            else
-            {
-                len = (int)strlen(comment);
-                ptr = fs->resizeWriteBuffer( ptr, len );
-                memcpy( ptr, comment, len );
-                fs->setBufferPtr(ptr + len);
-                comment = 0;
-            }
-            ptr = fs->flush();
-        }
-    }
-
-    void startNextStream()
-    {
-        fs->puts( "...\n" );
-        fs->puts( "---\n" );
-    }
-
-protected:
-    FileStorage_API* fs;
-};
-
-
-class YAMLParser : public FileStorageParser
-{
-public:
-    YAMLParser(FileStorage_API* _fs) : fs(_fs)
-    {
-    }
-
-    virtual ~YAMLParser() {}
-
-    char* skipSpaces( char* ptr, int min_indent, int max_comment_indent )
-    {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
-        for(;;)
-        {
-            while( *ptr == ' ' )
-                ptr++;
-            if( *ptr == '#' )
-            {
-                if( ptr - fs->bufferStart() > max_comment_indent )
-                    return ptr;
-                *ptr = '\0';
-            }
-            else if( cv_isprint(*ptr) )
-            {
-                if( ptr - fs->bufferStart() < min_indent )
-                    CV_PARSE_ERROR_CPP( "Incorrect indentation" );
-                break;
-            }
-            else if( *ptr == '\0' || *ptr == '\n' || *ptr == '\r' )
-            {
-                ptr = fs->gets();
-                if( !ptr )
-                {
-                    // emulate end of stream
-                    ptr = fs->bufferStart();
-                    ptr[0] = ptr[1] = ptr[2] = '.';
-                    ptr[3] = '\0';
-                    fs->setEof();
-                    break;
-                }
-                else
-                {
-                    int l = (int)strlen(ptr);
-                    if( ptr[l-1] != '\n' && ptr[l-1] != '\r' && !fs->eof() )
-                        CV_PARSE_ERROR_CPP( "Too long string or a last string w/o newline" );
-                }
-            }
-            else
-                CV_PARSE_ERROR_CPP( *ptr == '\t' ? "Tabs are prohibited in YAML!" : "Invalid character" );
-        }
-
-        return ptr;
-    }
-
-    bool getBase64Row(char* ptr, int indent, char* &beg, char* &end)
-    {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
-        beg = end = ptr = skipSpaces(ptr, 0, INT_MAX);
-        if (!ptr || !*ptr)
-            return false; // end of file
-
-        if (ptr - fs->bufferStart() != indent)
-            return false; // end of base64 data
-
-        /* find end */
-        while(cv_isprint(*ptr)) /* no check for base64 string */
-            ++ptr;
-        if (*ptr == '\0')
-            CV_PARSE_ERROR_CPP("Unexpected end of line");
-
-        end = ptr;
-        return true;
-    }
-
-
-    char* parseKey( char* ptr, FileNode& map_node, FileNode& value_placeholder )
-    {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
-        char c;
-        char *endptr = ptr - 1, *saveptr;
-
-        if( *ptr == '-' )
-            CV_PARSE_ERROR_CPP( "Key may not start with \'-\'" );
-
-        do c = *++endptr;
-        while( cv_isprint(c) && c != ':' );
-
-        if( c != ':' )
-            CV_PARSE_ERROR_CPP( "Missing \':\'" );
-
-        saveptr = endptr + 1;
-        do c = *--endptr;
-        while( c == ' ' );
-
-        ++endptr;
-        if( endptr == ptr )
-            CV_PARSE_ERROR_CPP( "An empty key" );
-
-        value_placeholder = fs->addNode(map_node, std::string(ptr, endptr - ptr), FileNode::NONE);
-        ptr = saveptr;
-
-        return ptr;
-    }
-
-    char* parseValue( char* ptr, FileNode& node, int min_indent, bool is_parent_flow )
-    {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
-        char* endptr = 0;
-        char c = ptr[0], d = ptr[1];
-        int value_type = FileNode::NONE;
-        int len;
-        bool is_binary_string = false;
-        bool is_user = false;
-
-        if( c == '!' ) // handle explicit type specification
-        {
-            if( d == '!' || d == '^' )
-            {
-                ptr++;
-                is_user = true;
-                //value_type |= FileNode::USER;
-            }
-            if ( d == '<') //support of full type heading from YAML 1.2
-            {
-                const char* yamlTypeHeading = "<tag:yaml.org,2002:";
-                const size_t headingLength = strlen(yamlTypeHeading);
-
-                char* typeEndPtr = ++ptr;
-
-                do d = *++typeEndPtr;
-                while( cv_isprint(d) && d != ' ' && d != '>' );
-
-                if ( d == '>' && (size_t)(typeEndPtr - ptr) > headingLength )
-                {
-                    if ( memcmp(ptr, yamlTypeHeading, headingLength) == 0 )
-                    {
-                        *typeEndPtr = ' ';
-                        ptr += headingLength - 1;
-                        is_user = true;
-                        //value_type |= FileNode::USER;
-                    }
-                }
-            }
-
-            endptr = ptr++;
-            do d = *++endptr;
-            while( cv_isprint(d) && d != ' ' );
-            len = (int)(endptr - ptr);
-            if( len == 0 )
-                CV_PARSE_ERROR_CPP( "Empty type name" );
-            d = *endptr;
-            *endptr = '\0';
-
-            if( len == 3 && !is_user )
-            {
-                if( memcmp( ptr, "str", 3 ) == 0 )
-                    value_type = FileNode::STRING;
-                else if( memcmp( ptr, "int", 3 ) == 0 )
-                    value_type = FileNode::INT;
-                else if( memcmp( ptr, "seq", 3 ) == 0 )
-                    value_type = FileNode::SEQ;
-                else if( memcmp( ptr, "map", 3 ) == 0 )
-                    value_type = FileNode::MAP;
-            }
-            else if( len == 5 && !is_user )
-            {
-                if( memcmp( ptr, "float", 5 ) == 0 )
-                    value_type = FileNode::REAL;
-            }
-            else if (len == 6 && is_user)
-            {
-                if( memcmp( ptr, "binary", 6 ) == 0 ) {
-                    value_type = FileNode::SEQ;
-                    is_binary_string = true;
-
-                    /* for ignore '|' */
-
-                    /**** operation with endptr ****/
-                    *endptr = d;
-
-                    do {
-                        d = *++endptr;
-                        if (d == '|')
-                            break;
-                    } while (d == ' ');
-
-                    d = *++endptr;
-                    *endptr = '\0';
-                }
-            }
-
-            *endptr = d;
-            ptr = skipSpaces( endptr, min_indent, INT_MAX );
-            if (!ptr)
-                CV_PARSE_ERROR_CPP("Invalid input");
-
-            c = *ptr;
-
-            if( !is_user )
-            {
-                if (value_type == FileNode::STRING && c != '\'' && c != '\"')
-                    goto force_string;
-                if( value_type == FileNode::INT )
-                    goto force_int;
-                if( value_type == FileNode::REAL )
-                    goto force_real;
-            }
-        }
-
-        if (is_binary_string)
-        {
-            int indent = static_cast<int>(ptr - fs->bufferStart());
-            ptr = fs->parseBase64(ptr, indent, node);
-        }
-        else if( cv_isdigit(c) ||
-                ((c == '-' || c == '+') && (cv_isdigit(d) || d == '.')) ||
-                (c == '.' && cv_isalnum(d))) // a number
-        {
-            endptr = ptr + (c == '-' || c == '+');
-            while( cv_isdigit(*endptr) )
-                endptr++;
-            if( *endptr == '.' || *endptr == 'e' )
-            {
-            force_real:
-                double fval = fs->strtod( ptr, &endptr );
-                node.setValue(FileNode::REAL, &fval);
-            }
-            else
-            {
-            force_int:
-                int ival = (int)strtol( ptr, &endptr, 0 );
-                node.setValue(FileNode::INT, &ival);
-            }
-
-            if( !endptr || endptr == ptr )
-                CV_PARSE_ERROR_CPP( "Invalid numeric value (inconsistent explicit type specification?)" );
-
-            ptr = endptr;
-            CV_PERSISTENCE_CHECK_END_OF_BUFFER_BUG_CPP();
-        }
-        else if( c == '\'' || c == '\"' ) // an explicit string
-        {
-            if( c == '\'' )
-                for( len = 0; len < CV_FS_MAX_LEN; )
-                {
-                    c = *++ptr;
-                    if( cv_isalnum(c) || (c != '\'' && cv_isprint(c)))
-                        buf[len++] = c;
-                    else if( c == '\'' )
-                    {
-                        c = *++ptr;
-                        if( c != '\'' )
-                            break;
-                        buf[len++] = c;
-                    }
-                    else
-                        CV_PARSE_ERROR_CPP( "Invalid character" );
-                }
-            else
-                for( len = 0; len < CV_FS_MAX_LEN; )
-                {
-                    c = *++ptr;
-                    if( cv_isalnum(c) || (c != '\\' && c != '\"' && cv_isprint(c)))
-                        buf[len++] = c;
-                    else if( c == '\"' )
-                    {
-                        ++ptr;
-                        break;
-                    }
-                    else if( c == '\\' )
-                    {
-                        d = *++ptr;
-                        if( d == '\'' )
-                            buf[len++] = d;
-                        else if( d == '\"' || d == '\\' || d == '\'' )
-                            buf[len++] = d;
-                        else if( d == 'n' )
-                            buf[len++] = '\n';
-                        else if( d == 'r' )
-                            buf[len++] = '\r';
-                        else if( d == 't' )
-                            buf[len++] = '\t';
-                        else if( d == 'x' || (cv_isdigit(d) && d < '8') )
-                        {
-                            int val, is_hex = d == 'x';
-                            c = ptr[3];
-                            ptr[3] = '\0';
-                            val = (int)strtol( ptr + is_hex, &endptr, is_hex ? 8 : 16 );
-                            ptr[3] = c;
-                            if( endptr == ptr + is_hex )
-                                buf[len++] = 'x';
-                            else
-                            {
-                                buf[len++] = (char)val;
-                                ptr = endptr;
-                            }
-                        }
-                    }
-                    else
-                        CV_PARSE_ERROR_CPP( "Invalid character" );
-                }
-
-            if( len >= CV_FS_MAX_LEN )
-                CV_PARSE_ERROR_CPP( "Too long string literal" );
-
-            node.setValue(FileNode::STRING, buf, len);
-        }
-        else if( c == '[' || c == '{' ) // collection as a flow
-        {
-            int new_min_indent = min_indent + !is_parent_flow;
-            int struct_type = c == '{' ? FileNode::MAP : FileNode::SEQ;
-            int nelems = 0;
-
-            fs->convertToCollection(struct_type, node);
-            d = c == '[' ? ']' : '}';
-
-            for( ++ptr ;; nelems++ )
-            {
-                FileNode elem;
-
-                ptr = skipSpaces( ptr, new_min_indent, INT_MAX );
-                if (!ptr)
-                    CV_PARSE_ERROR_CPP("Invalid input");
-                if( *ptr == '}' || *ptr == ']' )
-                {
-                    if( *ptr != d )
-                        CV_PARSE_ERROR_CPP( "The wrong closing bracket" );
-                    ptr++;
-                    break;
-                }
-
-                if( nelems != 0 )
-                {
-                    if( *ptr != ',' )
-                        CV_PARSE_ERROR_CPP( "Missing , between the elements" );
-                    ptr = skipSpaces( ptr + 1, new_min_indent, INT_MAX );
-                    if (!ptr)
-                        CV_PARSE_ERROR_CPP("Invalid input");
-                }
-
-                if( struct_type == FileNode::MAP )
-                {
-                    ptr = parseKey( ptr, node, elem );
-                    ptr = skipSpaces( ptr, new_min_indent, INT_MAX );
-                }
-                else
-                {
-                    if( *ptr == ']' )
-                        break;
-                    elem = fs->addNode(node, std::string(), FileNode::NONE);
-                }
-                ptr = parseValue( ptr, elem, new_min_indent, true );
-            }
-            fs->finalizeCollection(node);
-        }
-        else
-        {
-            int indent, struct_type;
-
-            if( is_parent_flow || c != '-' )
-            {
-                // implicit (one-line) string or nested block-style collection
-                if( !is_parent_flow )
-                {
-                    if( c == '?' )
-                        CV_PARSE_ERROR_CPP( "Complex keys are not supported" );
-                    if( c == '|' || c == '>' )
-                        CV_PARSE_ERROR_CPP( "Multi-line text literals are not supported" );
-                }
-
-            force_string:
-                endptr = ptr - 1;
-
-                do c = *++endptr;
-                while( cv_isprint(c) &&
-                      (!is_parent_flow || (c != ',' && c != '}' && c != ']')) &&
-                      (is_parent_flow || c != ':' || value_type == FileNode::STRING));
-
-                if( endptr == ptr )
-                    CV_PARSE_ERROR_CPP( "Invalid character" );
-
-                if( is_parent_flow || c != ':' )
-                {
-                    char* str_end = endptr;
-                    // strip spaces in the end of string
-                    do c = *--str_end;
-                    while( str_end > ptr && c == ' ' );
-                    str_end++;
-                    node.setValue(FileNode::STRING, ptr, (int)(str_end - ptr));
-                    ptr = endptr;
-                    return ptr;
-                }
-                struct_type = FileNode::MAP;
-            }
-            else
-                struct_type = FileNode::SEQ;
-
-            fs->convertToCollection( struct_type, node );
-            indent = (int)(ptr - fs->bufferStart());
-
-            for(;;)
-            {
-                FileNode elem;
-
-                if( struct_type == FileNode::MAP )
-                {
-                    ptr = parseKey( ptr, node, elem );
-                }
-                else
-                {
-                    c = *ptr++;
-                    if( c != '-' )
-                        CV_PARSE_ERROR_CPP( "Block sequence elements must be preceded with \'-\'" );
-
-                    elem = fs->addNode(node, std::string(), FileNode::NONE);
-                }
-                ptr = skipSpaces( ptr, indent + 1, INT_MAX );
-                ptr = parseValue( ptr, elem, indent + 1, false );
-                ptr = skipSpaces( ptr, 0, INT_MAX );
-                if( ptr - fs->bufferStart() != indent )
-                {
-                    if( ptr - fs->bufferStart() < indent )
-                        break;
-                    else
-                        CV_PARSE_ERROR_CPP( "Incorrect indentation" );
-                }
-                if( memcmp( ptr, "...", 3 ) == 0 )
-                    break;
-            }
-            fs->finalizeCollection(node);
-        }
-
-        return ptr;
-    }
-
-    bool parse( char* ptr )
-    {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
-        bool first = true;
-        bool ok = true;
-        FileNode root_collection(fs->getFS(), 0, 0);
-
-        for(;;)
-        {
-            // 0. skip leading comments and directives  and ...
-            // 1. reach the first item
-            for(;;)
-            {
-                ptr = skipSpaces( ptr, 0, INT_MAX );
-                if( !ptr || *ptr == '\0' )
-                {
-                    ok = !first;
-                    break;
-                }
-
-                if( *ptr == '%' )
-                {
-                    if( memcmp( ptr, "%YAML", 5 ) == 0 &&
-                        memcmp( ptr, "%YAML:1.", 8 ) != 0 &&
-                        memcmp( ptr, "%YAML 1.", 8 ) != 0)
-                        CV_PARSE_ERROR_CPP( "Unsupported YAML version (it must be 1.x)" );
-                    *ptr = '\0';
-                }
-                else if( *ptr == '-' )
-                {
-                    if( memcmp(ptr, "---", 3) == 0 )
-                    {
-                        ptr += 3;
-                        break;
-                    }
-                    else if( first )
-                        break;
-                }
-                else if( cv_isalnum(*ptr) || *ptr=='_')
-                {
-                    if( !first )
-                        CV_PARSE_ERROR_CPP( "The YAML streams must start with '---', except the first one" );
-                    break;
-                }
-                else if( fs->eof() )
-                    break;
-                else
-                    CV_PARSE_ERROR_CPP( "Invalid or unsupported syntax" );
-            }
-
-            if( ptr )
-                ptr = skipSpaces( ptr, 0, INT_MAX );
-            if( !ptr || !ptr[0] )
-                break;
-            if( memcmp( ptr, "...", 3 ) != 0 )
-            {
-                // 2. parse the collection
-                FileNode root_node = fs->addNode(root_collection, std::string(), FileNode::NONE);
-
-                ptr = parseValue( ptr, root_node, 0, false );
-                if( !root_node.isMap() && !root_node.isSeq() )
-                    CV_PARSE_ERROR_CPP( "Only collections as YAML streams are supported by this parser" );
-
-                // 3. parse until the end of file or next collection
-                ptr = skipSpaces( ptr, 0, INT_MAX );
-                if( !ptr )
-                    break;
-            }
-
-            if( fs->eof() )
-                break;
-            ptr += 3;
-            first = false;
-        }
-
-        return ok;
-    }
-
-    FileStorage_API* fs;
-    char buf[CV_FS_MAX_LEN+1024];
-};
-
-Ptr<FileStorageEmitter> createYAMLEmitter(FileStorage_API* fs)
-{
-    return makePtr<YAMLEmitter>(fs);
-}
-
-Ptr<FileStorageParser> createYAMLParser(FileStorage_API* fs)
-{
-    return makePtr<YAMLParser>(fs);
-}
-
-}
diff --git a/modules/core/src/system.cpp b/modules/core/src/system.cpp
index 3acf77035f..e62c808d7d 100644
--- a/modules/core/src/system.cpp
+++ b/modules/core/src/system.cpp
@@ -1133,7 +1133,8 @@ void error( const Exception& exc )
         *p = 0;
     }
 
-    throw exc;
+    // mashplant:
+    // throw exc;
 #ifdef __GNUC__
 # if !defined __clang__ && !defined __APPLE__
     // this suppresses this warning: "noreturn" function does return [enabled by default]
@@ -1885,7 +1886,7 @@ inline bool parseOption(const std::string & value)
     {
         return false;
     }
-    throw ParseError(value);
+    abort(); // mashplant: throw ParseError(value);
 }
 
 template<>
@@ -1906,7 +1907,7 @@ inline size_t parseOption(const std::string &value)
         return v * 1024 * 1024;
     else if (suffixStr == "KB" || suffixStr == "Kb" || suffixStr == "kb")
         return v * 1024;
-    throw ParseError(value);
+    abort(); // mashplant: throw ParseError(value);
 }
 
 template<>
@@ -1949,16 +1950,17 @@ static inline const char * envRead(const char * name)
 template<typename T>
 inline T read(const std::string & k, const T & defaultValue)
 {
-    try
-    {
+    // mashplant:
+    // try
+    // {
         const char * res = envRead(k.c_str());
         if (res)
             return parseOption<T>(std::string(res));
-    }
-    catch (const ParseError &err)
-    {
-        CV_Error(cv::Error::StsBadArg, err.toString(k));
-    }
+    // }
+    // catch (const ParseError &err)
+    // {
+    //     CV_Error(cv::Error::StsBadArg, err.toString(k));
+    // }
     return defaultValue;
 }
 
diff --git a/modules/core/src/umatrix.cpp b/modules/core/src/umatrix.cpp
index 0ec6270a70..9e75c4d411 100644
--- a/modules/core/src/umatrix.cpp
+++ b/modules/core/src/umatrix.cpp
@@ -575,14 +575,15 @@ UMat Mat::getUMat(AccessFlag accessFlags, UMatUsageFlags usageFlags) const
         new_u->originalUMatData = u;
     }
     bool allocated = false;
-    try
-    {
+    // mashplant:
+    // try
+    // {
         allocated = UMat::getStdAllocator()->allocate(new_u, accessFlags, usageFlags);
-    }
-    catch (const cv::Exception& e)
-    {
-        fprintf(stderr, "Exception: %s\n", e.what());
-    }
+    // }
+    // catch (const cv::Exception& e)
+    // {
+    //     fprintf(stderr, "Exception: %s\n", e.what());
+    // }
     if (!allocated)
     {
         allocated = getDefaultAllocator()->allocate(new_u, accessFlags, usageFlags);
@@ -650,17 +651,18 @@ void UMat::create(int d, const int* _sizes, int _type, UMatUsageFlags _usageFlag
             a = a0;
             a0 = Mat::getDefaultAllocator();
         }
-        try
-        {
+        // mashplant:
+        // try
+        // {
             u = a->allocate(dims, size, _type, 0, step.p, ACCESS_RW /* ignored */, usageFlags);
             CV_Assert(u != 0);
-        }
-        catch(...)
-        {
-            if(a != a0)
-                u = a0->allocate(dims, size, _type, 0, step.p, ACCESS_RW /* ignored */, usageFlags);
-            CV_Assert(u != 0);
-        }
+        // }
+        // catch(...)
+        // {
+        //     if(a != a0)
+        //         u = a0->allocate(dims, size, _type, 0, step.p, ACCESS_RW /* ignored */, usageFlags);
+        //     CV_Assert(u != 0);
+        // }
         CV_Assert( step[dims-1] == (size_t)CV_ELEM_SIZE(flags) );
     }
 
diff --git a/modules/core/src/utils/filesystem.cpp b/modules/core/src/utils/filesystem.cpp
index 9e606dcdbe..e309dd9530 100644
--- a/modules/core/src/utils/filesystem.cpp
+++ b/modules/core/src/utils/filesystem.cpp
@@ -508,14 +508,15 @@ cv::String getCacheDirectory(const char* sub_directory_name, const char* configu
                     && !utils::fs::isDirectory(default_cache_path))
                 {
                     std::vector<cv::String> existedCacheDirs;
-                    try
-                    {
+                    // mashplant:
+                    // try
+                    // {
                         utils::fs::glob_relative(default_cache_path_base, "*", existedCacheDirs, false, true);
-                    }
-                    catch (...)
-                    {
-                        // ignore
-                    }
+                    // }
+                    // catch (...)
+                    // {
+                    //     // ignore
+                    // }
                     if (!existedCacheDirs.empty())
                     {
                         CV_LOG_WARNING(NULL, "Creating new OpenCV cache directory: " << default_cache_path);
diff --git a/modules/gapi/include/opencv2/gapi/imgproc.hpp b/modules/gapi/include/opencv2/gapi/imgproc.hpp
index cc091dfa8e..294b3b7842 100644
--- a/modules/gapi/include/opencv2/gapi/imgproc.hpp
+++ b/modules/gapi/include/opencv2/gapi/imgproc.hpp
@@ -78,14 +78,6 @@ namespace imgproc {
         }
     };
 
-    G_TYPED_KERNEL(GMorphologyEx, <GMat(GMat,MorphTypes,Mat,Point,int,BorderTypes,Scalar)>,
-                   "org.opencv.imgproc.filters.morphologyEx") {
-        static GMatDesc outMeta(const GMatDesc &in, MorphTypes, Mat, Point, int,
-                                BorderTypes, Scalar) {
-            return in;
-        }
-    };
-
     G_TYPED_KERNEL(GSobel, <GMat(GMat,int,int,int,int,double,double,int,Scalar)>, "org.opencv.imgproc.filters.sobel") {
         static GMatDesc outMeta(GMatDesc in, int ddepth, int, int, int, double, double, int, Scalar) {
             return in.withDepth(ddepth);
@@ -529,7 +521,7 @@ anchor is at the element center.
 @param iterations number of times erosion is applied.
 @param borderType pixel extrapolation method, see cv::BorderTypes
 @param borderValue border value in case of a constant border
-@sa  dilate, morphologyEx
+@sa  dilate
  */
 GAPI_EXPORTS GMat erode(const GMat& src, const Mat& kernel, const Point& anchor = Point(-1,-1), int iterations = 1,
                         int borderType = BORDER_CONSTANT,
@@ -604,37 +596,6 @@ GAPI_EXPORTS GMat dilate3x3(const GMat& src, int iterations = 1,
                             int borderType = BORDER_CONSTANT,
                             const  Scalar& borderValue = morphologyDefaultBorderValue());
 
-/** @brief Performs advanced morphological transformations.
-
-The function can perform advanced morphological transformations using an erosion and dilation as
-basic operations.
-
-Any of the operations can be done in-place. In case of multi-channel images, each channel is
-processed independently.
-
-@note Function textual ID is "org.opencv.imgproc.filters.morphologyEx"
-
-@param src Input image.
-@param op Type of a morphological operation, see #MorphTypes
-@param kernel Structuring element. It can be created using #getStructuringElement.
-@param anchor Anchor position within the element. Both negative values mean that the anchor is at
-the kernel center.
-@param iterations Number of times erosion and dilation are applied.
-@param borderType Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.
-@param borderValue Border value in case of a constant border. The default value has a special
-meaning.
-@sa  dilate, erode, getStructuringElement
-@note The number of iterations is the number of times erosion or dilatation operation will be
-applied. For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to
-apply successively: erode -> erode -> dilate -> dilate
-(and not erode -> dilate -> erode -> dilate).
- */
-GAPI_EXPORTS GMat morphologyEx(const GMat &src, const MorphTypes op, const Mat &kernel,
-                               const Point       &anchor      = Point(-1,-1),
-                               const int          iterations  = 1,
-                               const BorderTypes  borderType  = BORDER_CONSTANT,
-                               const Scalar      &borderValue = morphologyDefaultBorderValue());
-
 /** @brief Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.
 
 In all cases except one, the \f$\texttt{ksize} \times \texttt{ksize}\f$ separable kernel is used to
diff --git a/modules/gapi/src/api/kernels_imgproc.cpp b/modules/gapi/src/api/kernels_imgproc.cpp
index 9a5b07c14a..652f83935f 100644
--- a/modules/gapi/src/api/kernels_imgproc.cpp
+++ b/modules/gapi/src/api/kernels_imgproc.cpp
@@ -73,13 +73,6 @@ GMat dilate3x3(const GMat& src, int iterations,
     return dilate(src, cv::Mat(), cv::Point(-1,-1), iterations, borderType, borderValue);
 }
 
-GMat morphologyEx(const GMat &src, const MorphTypes op, const Mat &kernel, const Point &anchor,
-                  const int iterations, const BorderTypes borderType, const Scalar &borderValue)
-{
-    return imgproc::GMorphologyEx::on(src, op, kernel, anchor, iterations,
-                                      borderType, borderValue);
-}
-
 GMat Sobel(const GMat& src, int ddepth, int dx, int dy, int ksize,
            double scale, double delta,
            int borderType, const Scalar& bordVal)
diff --git a/modules/gapi/src/backends/cpu/gcpuimgproc.cpp b/modules/gapi/src/backends/cpu/gcpuimgproc.cpp
index a3c4e1b60f..c07ed6785c 100644
--- a/modules/gapi/src/backends/cpu/gcpuimgproc.cpp
+++ b/modules/gapi/src/backends/cpu/gcpuimgproc.cpp
@@ -145,16 +145,6 @@ GAPI_OCV_KERNEL(GCPUDilate, cv::gapi::imgproc::GDilate)
     }
 };
 
-GAPI_OCV_KERNEL(GCPUMorphologyEx, cv::gapi::imgproc::GMorphologyEx)
-{
-    static void run(const cv::Mat &in, const cv::MorphTypes op, const cv::Mat &kernel,
-                    const cv::Point &anchor, const int iterations,
-                    const cv::BorderTypes borderType, const cv::Scalar &borderValue, cv::Mat &out)
-    {
-        cv::morphologyEx(in, out, op, kernel, anchor, iterations, borderType, borderValue);
-    }
-};
-
 GAPI_OCV_KERNEL(GCPUSobel, cv::gapi::imgproc::GSobel)
 {
     static void run(const cv::Mat& in, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType,
@@ -488,7 +478,6 @@ cv::gapi::GKernelPackage cv::gapi::imgproc::cpu::kernels()
         , GCPUMedianBlur
         , GCPUErode
         , GCPUDilate
-        , GCPUMorphologyEx
         , GCPUSobel
         , GCPUSobelXY
         , GCPULaplacian
diff --git a/modules/gapi/test/common/gapi_imgproc_tests.hpp b/modules/gapi/test/common/gapi_imgproc_tests.hpp
index d562b306c2..38a02985e7 100644
--- a/modules/gapi/test/common/gapi_imgproc_tests.hpp
+++ b/modules/gapi/test/common/gapi_imgproc_tests.hpp
@@ -46,8 +46,6 @@ GAPI_TEST_FIXTURE(Erode3x3Test, initMatrixRandN, FIXTURE_API(CompareMats,int), 2
 GAPI_TEST_FIXTURE(DilateTest, initMatrixRandN, FIXTURE_API(CompareMats,int,int), 3,
     cmpF, kernSize, kernType)
 GAPI_TEST_FIXTURE(Dilate3x3Test, initMatrixRandN, FIXTURE_API(CompareMats,int), 2, cmpF, numIters)
-GAPI_TEST_FIXTURE(MorphologyExTest, initMatrixRandN, FIXTURE_API(CompareMats,MorphTypes),
-                  2, cmpF, op)
 GAPI_TEST_FIXTURE(SobelTest, initMatrixRandN, FIXTURE_API(CompareMats,int,int,int), 4,
     cmpF, kernSize, dx, dy)
 GAPI_TEST_FIXTURE(SobelXYTest, initMatrixRandN, FIXTURE_API(CompareMats,int,int,int,int), 5,
diff --git a/modules/gapi/test/common/gapi_imgproc_tests_inl.hpp b/modules/gapi/test/common/gapi_imgproc_tests_inl.hpp
index c087733fa8..95728e87b7 100644
--- a/modules/gapi/test/common/gapi_imgproc_tests_inl.hpp
+++ b/modules/gapi/test/common/gapi_imgproc_tests_inl.hpp
@@ -290,29 +290,6 @@ TEST_P(Dilate3x3Test, AccuracyTest)
     }
 }
 
-TEST_P(MorphologyExTest, AccuracyTest)
-{
-    MorphShapes defShape = cv::MORPH_RECT;
-    int defKernSize = 3;
-    cv::Mat kernel = cv::getStructuringElement(defShape, cv::Size(defKernSize, defKernSize));
-
-    // G-API code //////////////////////////////////////////////////////////////
-    cv::GMat in;
-    auto out = cv::gapi::morphologyEx(in, op, kernel);
-
-    cv::GComputation c(in, out);
-    c.apply(in_mat1, out_mat_gapi, getCompileArgs());
-    // OpenCV code /////////////////////////////////////////////////////////////
-    {
-        cv::morphologyEx(in_mat1, out_mat_ocv, op, kernel);
-    }
-    // Comparison //////////////////////////////////////////////////////////////
-    {
-        EXPECT_TRUE(cmpF(out_mat_gapi, out_mat_ocv));
-        EXPECT_EQ(out_mat_gapi.size(), sz);
-    }
-}
-
 TEST_P(SobelTest, AccuracyTest)
 {
     // G-API code //////////////////////////////////////////////////////////////
diff --git a/modules/gapi/test/common/gapi_tests_common.hpp b/modules/gapi/test/common/gapi_tests_common.hpp
index bb045b83d1..113f3c73c0 100644
--- a/modules/gapi/test/common/gapi_tests_common.hpp
+++ b/modules/gapi/test/common/gapi_tests_common.hpp
@@ -848,25 +848,6 @@ inline std::ostream& operator<<(std::ostream& os, NormTypes op)
 #undef CASE
     return os;
 }
-
-inline std::ostream& operator<<(std::ostream& os, MorphTypes op)
-{
-#define CASE(v) case MorphTypes::v: os << #v; break
-    switch (op)
-    {
-        CASE(MORPH_ERODE);
-        CASE(MORPH_DILATE);
-        CASE(MORPH_OPEN);
-        CASE(MORPH_CLOSE);
-        CASE(MORPH_GRADIENT);
-        CASE(MORPH_TOPHAT);
-        CASE(MORPH_BLACKHAT);
-        CASE(MORPH_HITMISS);
-        default: GAPI_Assert(false && "unknown MorphTypes value");
-    }
-#undef CASE
-    return os;
-}
 }  // namespace cv
 
 #endif //OPENCV_GAPI_TESTS_COMMON_HPP
diff --git a/modules/gapi/test/cpu/gapi_imgproc_tests_cpu.cpp b/modules/gapi/test/cpu/gapi_imgproc_tests_cpu.cpp
index 7cba6b05db..e7f9667096 100644
--- a/modules/gapi/test/cpu/gapi_imgproc_tests_cpu.cpp
+++ b/modules/gapi/test/cpu/gapi_imgproc_tests_cpu.cpp
@@ -130,30 +130,6 @@ INSTANTIATE_TEST_CASE_P(Dilate3x3TestCPU, Dilate3x3Test,
                                 Values(AbsExact().to_compare_obj()),
                                 Values(1,2,4)));
 
-INSTANTIATE_TEST_CASE_P(MorphologyExTestCPU, MorphologyExTest,
-                        Combine(Values(CV_8UC1, CV_8UC3, CV_16UC1, CV_16SC1, CV_32FC1),
-                                Values(cv::Size(1280, 720),
-                                       cv::Size(640, 480)),
-                                Values(-1),
-                                Values(IMGPROC_CPU),
-                                Values(AbsExact().to_compare_obj()),
-                                Values(cv::MorphTypes::MORPH_ERODE,
-                                       cv::MorphTypes::MORPH_DILATE,
-                                       cv::MorphTypes::MORPH_OPEN,
-                                       cv::MorphTypes::MORPH_CLOSE,
-                                       cv::MorphTypes::MORPH_GRADIENT,
-                                       cv::MorphTypes::MORPH_TOPHAT,
-                                       cv::MorphTypes::MORPH_BLACKHAT)));
-
-INSTANTIATE_TEST_CASE_P(MorphologyExHitMissTestCPU, MorphologyExTest,
-                        Combine(Values(CV_8UC1),
-                                Values(cv::Size(1280, 720),
-                                       cv::Size(640, 480)),
-                                Values(-1),
-                                Values(IMGPROC_CPU),
-                                Values(AbsExact().to_compare_obj()),
-                                Values(cv::MorphTypes::MORPH_HITMISS)));
-
 INSTANTIATE_TEST_CASE_P(SobelTestCPU, SobelTest,
                         Combine(Values(CV_8UC1, CV_8UC3, CV_16UC1, CV_16SC1),
                                 Values(cv::Size(1280, 720),
diff --git a/modules/imgcodecs/src/bitstrm.cpp b/modules/imgcodecs/src/bitstrm.cpp
index 97df645a6d..50523b1949 100644
--- a/modules/imgcodecs/src/bitstrm.cpp
+++ b/modules/imgcodecs/src/bitstrm.cpp
@@ -99,7 +99,7 @@ void  RBaseStream::readBlock()
     {
         if( m_block_pos == 0 && m_current < m_end )
             return;
-        throw RBS_THROW_EOS;
+        abort(); // mashplant: throw RBS_THROW_EOS;
     }
 
     fseek( m_file, m_block_pos, SEEK_SET );
@@ -107,7 +107,7 @@ void  RBaseStream::readBlock()
     m_end = m_start + readed;
 
     if( readed == 0 || m_current >= m_end )
-        throw RBS_THROW_EOS;
+        abort(); // mashplant: throw RBS_THROW_EOS;
 }
 
 
diff --git a/modules/imgcodecs/src/exif.cpp b/modules/imgcodecs/src/exif.cpp
index 051999c0fa..113623d7e9 100644
--- a/modules/imgcodecs/src/exif.cpp
+++ b/modules/imgcodecs/src/exif.cpp
@@ -80,16 +80,17 @@ ExifReader::~ExifReader()
  */
 bool ExifReader::parse()
 {
-    try {
+    // mashplant:
+    // try {
         m_exif = getExif();
         if( !m_exif.empty() )
         {
             return true;
         }
         return false;
-    } catch (ExifParsingError&) {
-        return false;
-    }
+    // } catch (ExifParsingError&) {
+    //     return false;
+    // }
 }
 
 
@@ -151,11 +152,11 @@ std::map<int, ExifEntry_t > ExifReader::getExif()
             case COM:
                 bytesToSkip = getFieldSize();
                 if (bytesToSkip < markerSize) {
-                    throw ExifParsingError();
+                    abort(); // mashplant: throw ExifParsingError();
                 }
                 m_stream.seekg( static_cast<long>( bytesToSkip - markerSize ), m_stream.cur );
                 if ( m_stream.fail() ) {
-                    throw ExifParsingError();
+                    abort(); // mashplant: throw ExifParsingError();
                 }
                 break;
 
@@ -166,12 +167,12 @@ std::map<int, ExifEntry_t > ExifReader::getExif()
             case APP1: //actual Exif Marker
                 exifSize = getFieldSize();
                 if (exifSize <= offsetToTiffHeader) {
-                    throw ExifParsingError();
+                    abort(); // mashplant: throw ExifParsingError();
                 }
                 m_data.resize( exifSize - offsetToTiffHeader );
                 m_stream.seekg( static_cast<long>( offsetToTiffHeader ), m_stream.cur );
                 if ( m_stream.fail() ) {
-                    throw ExifParsingError();
+                    abort(); // mashplant: throw ExifParsingError();
                 }
                 m_stream.read( reinterpret_cast<char*>(&m_data[0]), exifSize - offsetToTiffHeader );
                 exifFound = true;
@@ -415,7 +416,7 @@ std::string ExifReader::getString(const size_t offset) const
         dataOffset = getU32( offset + 8 );
     }
     if (dataOffset > m_data.size() || dataOffset + size > m_data.size()) {
-        throw ExifParsingError();
+        abort(); // mashplant: throw ExifParsingError();
     }
     std::vector<uint8_t>::const_iterator it = m_data.begin() + dataOffset;
     std::string result( it, it + size ); //copy vector content into result
@@ -432,7 +433,7 @@ std::string ExifReader::getString(const size_t offset) const
 uint16_t ExifReader::getU16(const size_t offset) const
 {
     if (offset + 1 >= m_data.size())
-        throw ExifParsingError();
+        abort(); // mashplant: throw ExifParsingError();
 
     if( m_format == INTEL )
     {
@@ -450,7 +451,7 @@ uint16_t ExifReader::getU16(const size_t offset) const
 uint32_t ExifReader::getU32(const size_t offset) const
 {
     if (offset + 3 >= m_data.size())
-        throw ExifParsingError();
+        abort(); // mashplant: throw ExifParsingError();
 
     if( m_format == INTEL )
     {
diff --git a/modules/imgcodecs/src/grfmt_bmp.cpp b/modules/imgcodecs/src/grfmt_bmp.cpp
index 880a8cd105..58ba829a64 100644
--- a/modules/imgcodecs/src/grfmt_bmp.cpp
+++ b/modules/imgcodecs/src/grfmt_bmp.cpp
@@ -43,6 +43,9 @@
 #include "precomp.hpp"
 #include "grfmt_bmp.hpp"
 
+// mashplant:
+#if 0
+
 namespace cv
 {
 
@@ -89,8 +92,9 @@ bool  BmpDecoder::readHeader()
     else if( !m_strm.open( m_filename ))
         return false;
 
-    try
-    {
+    // mashplant:
+    // try
+    // {
         m_strm.skip( 10 );
         m_offset = m_strm.getDWord();
 
@@ -174,11 +178,11 @@ bool  BmpDecoder::readHeader()
                 result = true;
             }
         }
-    }
-    catch(...)
-    {
-        throw;
-    }
+    // }
+    // catch(...)
+    // {
+    //     throw;
+    // }
     // in 32 bit case alpha channel is used - so require CV_8UC4 type
     m_type = iscolor ? (m_bpp == 32 ? CV_8UC4 : CV_8UC3 ) : CV_8UC1;
     m_origin = m_height > 0 ? ORIGIN_BL : ORIGIN_TL;
@@ -230,8 +234,9 @@ bool  BmpDecoder::readData( Mat& img )
     }
     uchar *src = _src.data(), *bgr = _bgr.data();
 
-    try
-    {
+    // mashplant:
+    // try
+    // {
         m_strm.setPos( m_offset );
 
         switch( m_bpp )
@@ -494,11 +499,11 @@ decode_rle8_bad: ;
         default:
             CV_Error(cv::Error::StsError, "Invalid/unsupported mode");
         }
-    }
-    catch(...)
-    {
-        throw;
-    }
+    // }
+    // catch(...)
+    // {
+    //     throw;
+    // }
 
     return result;
 }
@@ -586,3 +591,5 @@ bool  BmpEncoder::write( const Mat& img, const std::vector<int>& )
 }
 
 }
+
+#endif
\ No newline at end of file
diff --git a/modules/imgcodecs/src/grfmt_bmp.hpp b/modules/imgcodecs/src/grfmt_bmp.hpp
index e94b8ff8b4..415ff4a763 100644
--- a/modules/imgcodecs/src/grfmt_bmp.hpp
+++ b/modules/imgcodecs/src/grfmt_bmp.hpp
@@ -45,6 +45,9 @@
 
 #include "grfmt_base.hpp"
 
+// mashplant:
+#if 0
+
 namespace cv
 {
 
@@ -102,4 +105,6 @@ public:
 
 }
 
+#endif
+
 #endif/*_GRFMT_BMP_H_*/
diff --git a/modules/imgcodecs/src/loadsave.cpp b/modules/imgcodecs/src/loadsave.cpp
index b28a861275..4f0e828969 100644
--- a/modules/imgcodecs/src/loadsave.cpp
+++ b/modules/imgcodecs/src/loadsave.cpp
@@ -131,8 +131,8 @@ struct ImageCodecInitializer
     ImageCodecInitializer()
     {
         /// BMP Support
-        decoders.push_back( makePtr<BmpDecoder>() );
-        encoders.push_back( makePtr<BmpEncoder>() );
+        // decoders.push_back( makePtr<BmpDecoder>() );
+        // encoders.push_back( makePtr<BmpEncoder>() );
 
     #ifdef HAVE_IMGCODEC_HDR
         decoders.push_back( makePtr<HdrDecoder>() );
@@ -454,22 +454,23 @@ imread_( const String& filename, int flags, Mat& mat )
     /// set the filename in the driver
     decoder->setSource( filename );
 
-    try
-    {
+    // mashplant:
+    // try
+    // {
         // read the header to make sure it succeeds
         if( !decoder->readHeader() )
             return 0;
-    }
-    catch (const cv::Exception& e)
-    {
-        std::cerr << "imread_('" << filename << "'): can't read header: " << e.what() << std::endl << std::flush;
-        return 0;
-    }
-    catch (...)
-    {
-        std::cerr << "imread_('" << filename << "'): can't read header: unknown exception" << std::endl << std::flush;
-        return 0;
-    }
+    // }
+    // catch (const cv::Exception& e)
+    // {
+    //     std::cerr << "imread_('" << filename << "'): can't read header: " << e.what() << std::endl << std::flush;
+    //     return 0;
+    // }
+    // catch (...)
+    // {
+    //     std::cerr << "imread_('" << filename << "'): can't read header: unknown exception" << std::endl << std::flush;
+    //     return 0;
+    // }
 
 
     // established the required input image size
@@ -493,19 +494,20 @@ imread_( const String& filename, int flags, Mat& mat )
 
     // read the image data
     bool success = false;
-    try
-    {
+    // mashplant:
+    // try
+    // {
         if (decoder->readData(mat))
             success = true;
-    }
-    catch (const cv::Exception& e)
-    {
-        std::cerr << "imread_('" << filename << "'): can't read data: " << e.what() << std::endl << std::flush;
-    }
-    catch (...)
-    {
-        std::cerr << "imread_('" << filename << "'): can't read data: unknown exception" << std::endl << std::flush;
-    }
+    // }
+    // catch (const cv::Exception& e)
+    // {
+    //     std::cerr << "imread_('" << filename << "'): can't read data: " << e.what() << std::endl << std::flush;
+    // }
+    // catch (...)
+    // {
+    //     std::cerr << "imread_('" << filename << "'): can't read data: unknown exception" << std::endl << std::flush;
+    // }
     if (!success)
     {
         mat.release();
@@ -529,102 +531,102 @@ imread_( const String& filename, int flags, Mat& mat )
 * @param[in] mats Reference to C++ vector<Mat> object to hold the images
 *
 */
-static bool
-imreadmulti_(const String& filename, int flags, std::vector<Mat>& mats)
-{
-    /// Search for the relevant decoder to handle the imagery
-    ImageDecoder decoder;
-
-#ifdef HAVE_GDAL
-    if (flags != IMREAD_UNCHANGED && (flags & IMREAD_LOAD_GDAL) == IMREAD_LOAD_GDAL){
-        decoder = GdalDecoder().newDecoder();
-    }
-    else{
-#endif
-        decoder = findDecoder(filename);
-#ifdef HAVE_GDAL
-    }
-#endif
-
-    /// if no decoder was found, return nothing.
-    if (!decoder){
-        return 0;
-    }
-
-    /// set the filename in the driver
-    decoder->setSource(filename);
-
-    // read the header to make sure it succeeds
-    try
-    {
-        // read the header to make sure it succeeds
-        if( !decoder->readHeader() )
-            return 0;
-    }
-    catch (const cv::Exception& e)
-    {
-        std::cerr << "imreadmulti_('" << filename << "'): can't read header: " << e.what() << std::endl << std::flush;
-        return 0;
-    }
-    catch (...)
-    {
-        std::cerr << "imreadmulti_('" << filename << "'): can't read header: unknown exception" << std::endl << std::flush;
-        return 0;
-    }
-
-    for (;;)
-    {
-        // grab the decoded type
-        int type = decoder->type();
-        if( (flags & IMREAD_LOAD_GDAL) != IMREAD_LOAD_GDAL && flags != IMREAD_UNCHANGED )
-        {
-            if ((flags & IMREAD_ANYDEPTH) == 0)
-                type = CV_MAKETYPE(CV_8U, CV_MAT_CN(type));
-
-            if ((flags & CV_LOAD_IMAGE_COLOR) != 0 ||
-                ((flags & IMREAD_ANYCOLOR) != 0 && CV_MAT_CN(type) > 1))
-                type = CV_MAKETYPE(CV_MAT_DEPTH(type), 3);
-            else
-                type = CV_MAKETYPE(CV_MAT_DEPTH(type), 1);
-        }
-
-        // established the required input image size
-        Size size = validateInputImageSize(Size(decoder->width(), decoder->height()));
-
-        // read the image data
-        Mat mat(size.height, size.width, type);
-        bool success = false;
-        try
-        {
-            if (decoder->readData(mat))
-                success = true;
-        }
-        catch (const cv::Exception& e)
-        {
-            std::cerr << "imreadmulti_('" << filename << "'): can't read data: " << e.what() << std::endl << std::flush;
-        }
-        catch (...)
-        {
-            std::cerr << "imreadmulti_('" << filename << "'): can't read data: unknown exception" << std::endl << std::flush;
-        }
-        if (!success)
-            break;
-
-        // optionally rotate the data if EXIF' orientation flag says so
-        if( (flags & IMREAD_IGNORE_ORIENTATION) == 0 && flags != IMREAD_UNCHANGED )
-        {
-            ApplyExifOrientation(filename, mat);
-        }
-
-        mats.push_back(mat);
-        if (!decoder->nextPage())
-        {
-            break;
-        }
-    }
-
-    return !mats.empty();
-}
+// static bool
+// imreadmulti_(const String& filename, int flags, std::vector<Mat>& mats)
+// {
+//     /// Search for the relevant decoder to handle the imagery
+//     ImageDecoder decoder;
+
+// #ifdef HAVE_GDAL
+//     if (flags != IMREAD_UNCHANGED && (flags & IMREAD_LOAD_GDAL) == IMREAD_LOAD_GDAL){
+//         decoder = GdalDecoder().newDecoder();
+//     }
+//     else{
+// #endif
+//         decoder = findDecoder(filename);
+// #ifdef HAVE_GDAL
+//     }
+// #endif
+
+//     /// if no decoder was found, return nothing.
+//     if (!decoder){
+//         return 0;
+//     }
+
+//     /// set the filename in the driver
+//     decoder->setSource(filename);
+
+//     // read the header to make sure it succeeds
+//     try
+//     {
+//         // read the header to make sure it succeeds
+//         if( !decoder->readHeader() )
+//             return 0;
+//     }
+//     catch (const cv::Exception& e)
+//     {
+//         std::cerr << "imreadmulti_('" << filename << "'): can't read header: " << e.what() << std::endl << std::flush;
+//         return 0;
+//     }
+//     catch (...)
+//     {
+//         std::cerr << "imreadmulti_('" << filename << "'): can't read header: unknown exception" << std::endl << std::flush;
+//         return 0;
+//     }
+
+//     for (;;)
+//     {
+//         // grab the decoded type
+//         int type = decoder->type();
+//         if( (flags & IMREAD_LOAD_GDAL) != IMREAD_LOAD_GDAL && flags != IMREAD_UNCHANGED )
+//         {
+//             if ((flags & IMREAD_ANYDEPTH) == 0)
+//                 type = CV_MAKETYPE(CV_8U, CV_MAT_CN(type));
+
+//             if ((flags & CV_LOAD_IMAGE_COLOR) != 0 ||
+//                 ((flags & IMREAD_ANYCOLOR) != 0 && CV_MAT_CN(type) > 1))
+//                 type = CV_MAKETYPE(CV_MAT_DEPTH(type), 3);
+//             else
+//                 type = CV_MAKETYPE(CV_MAT_DEPTH(type), 1);
+//         }
+
+//         // established the required input image size
+//         Size size = validateInputImageSize(Size(decoder->width(), decoder->height()));
+
+//         // read the image data
+//         Mat mat(size.height, size.width, type);
+//         bool success = false;
+//         try
+//         {
+//             if (decoder->readData(mat))
+//                 success = true;
+//         }
+//         catch (const cv::Exception& e)
+//         {
+//             std::cerr << "imreadmulti_('" << filename << "'): can't read data: " << e.what() << std::endl << std::flush;
+//         }
+//         catch (...)
+//         {
+//             std::cerr << "imreadmulti_('" << filename << "'): can't read data: unknown exception" << std::endl << std::flush;
+//         }
+//         if (!success)
+//             break;
+
+//         // optionally rotate the data if EXIF' orientation flag says so
+//         if( (flags & IMREAD_IGNORE_ORIENTATION) == 0 && flags != IMREAD_UNCHANGED )
+//         {
+//             ApplyExifOrientation(filename, mat);
+//         }
+
+//         mats.push_back(mat);
+//         if (!decoder->nextPage())
+//         {
+//             break;
+//         }
+//     }
+
+//     return !mats.empty();
+// }
 
 /**
  * Read an image
@@ -664,103 +666,104 @@ Mat imread( const String& filename, int flags )
 * @param[in] flags Flags you wish to set.
 *
 */
-bool imreadmulti(const String& filename, std::vector<Mat>& mats, int flags)
-{
-    CV_TRACE_FUNCTION();
-
-    return imreadmulti_(filename, flags, mats);
-}
-
-static bool imwrite_( const String& filename, const std::vector<Mat>& img_vec,
-                      const std::vector<int>& params, bool flipv )
-{
-    bool isMultiImg = img_vec.size() > 1;
-    std::vector<Mat> write_vec;
-
-    ImageEncoder encoder = findEncoder( filename );
-    if( !encoder )
-        CV_Error( Error::StsError, "could not find a writer for the specified extension" );
-
-    for (size_t page = 0; page < img_vec.size(); page++)
-    {
-        Mat image = img_vec[page];
-        CV_Assert(!image.empty());
-
-        CV_Assert( image.channels() == 1 || image.channels() == 3 || image.channels() == 4 );
-
-        Mat temp;
-        if( !encoder->isFormatSupported(image.depth()) )
-        {
-            CV_Assert( encoder->isFormatSupported(CV_8U) );
-            image.convertTo( temp, CV_8U );
-            image = temp;
-        }
-
-        if( flipv )
-        {
-            flip(image, temp, 0);
-            image = temp;
-        }
-
-        write_vec.push_back(image);
-    }
-
-    encoder->setDestination( filename );
-    CV_Assert(params.size() <= CV_IO_MAX_IMAGE_PARAMS*2);
-    bool code = false;
-    try
-    {
-        if (!isMultiImg)
-            code = encoder->write( write_vec[0], params );
-        else
-            code = encoder->writemulti( write_vec, params ); //to be implemented
-
-        if (!code)
-        {
-            FILE* f = fopen( filename.c_str(), "wb" );
-            if ( !f )
-            {
-                if (errno == EACCES)
-                {
-                    CV_LOG_WARNING(NULL, "imwrite_('" << filename << "'): can't open file for writing: permission denied");
-                }
-            }
-            else
-            {
-                fclose(f);
-                remove(filename.c_str());
-            }
-        }
-    }
-    catch (const cv::Exception& e)
-    {
-        std::cerr << "imwrite_('" << filename << "'): can't write data: " << e.what() << std::endl << std::flush;
-    }
-    catch (...)
-    {
-        std::cerr << "imwrite_('" << filename << "'): can't write data: unknown exception" << std::endl << std::flush;
-    }
-
-    //    CV_Assert( code );
-    return code;
-}
-
-bool imwrite( const String& filename, InputArray _img,
-              const std::vector<int>& params )
-{
-    CV_TRACE_FUNCTION();
-
-    CV_Assert(!_img.empty());
-
-    std::vector<Mat> img_vec;
-    if (_img.isMatVector() || _img.isUMatVector())
-        _img.getMatVector(img_vec);
-    else
-        img_vec.push_back(_img.getMat());
-
-    CV_Assert(!img_vec.empty());
-    return imwrite_(filename, img_vec, params, false);
-}
+// bool imreadmulti(const String& filename, std::vector<Mat>& mats, int flags)
+// {
+//     CV_TRACE_FUNCTION();
+
+//     return imreadmulti_(filename, flags, mats);
+// }
+
+// mashplant:
+// static bool imwrite_( const String& filename, const std::vector<Mat>& img_vec,
+//                       const std::vector<int>& params, bool flipv )
+// {
+//     bool isMultiImg = img_vec.size() > 1;
+//     std::vector<Mat> write_vec;
+
+//     ImageEncoder encoder = findEncoder( filename );
+//     if( !encoder )
+//         CV_Error( Error::StsError, "could not find a writer for the specified extension" );
+
+//     for (size_t page = 0; page < img_vec.size(); page++)
+//     {
+//         Mat image = img_vec[page];
+//         CV_Assert(!image.empty());
+
+//         CV_Assert( image.channels() == 1 || image.channels() == 3 || image.channels() == 4 );
+
+//         Mat temp;
+//         if( !encoder->isFormatSupported(image.depth()) )
+//         {
+//             CV_Assert( encoder->isFormatSupported(CV_8U) );
+//             image.convertTo( temp, CV_8U );
+//             image = temp;
+//         }
+
+//         if( flipv )
+//         {
+//             flip(image, temp, 0);
+//             image = temp;
+//         }
+
+//         write_vec.push_back(image);
+//     }
+
+//     encoder->setDestination( filename );
+//     CV_Assert(params.size() <= CV_IO_MAX_IMAGE_PARAMS*2);
+//     bool code = false;
+//     try
+//     {
+//         if (!isMultiImg)
+//             code = encoder->write( write_vec[0], params );
+//         else
+//             code = encoder->writemulti( write_vec, params ); //to be implemented
+
+//         if (!code)
+//         {
+//             FILE* f = fopen( filename.c_str(), "wb" );
+//             if ( !f )
+//             {
+//                 if (errno == EACCES)
+//                 {
+//                     CV_LOG_WARNING(NULL, "imwrite_('" << filename << "'): can't open file for writing: permission denied");
+//                 }
+//             }
+//             else
+//             {
+//                 fclose(f);
+//                 remove(filename.c_str());
+//             }
+//         }
+//     }
+//     catch (const cv::Exception& e)
+//     {
+//         std::cerr << "imwrite_('" << filename << "'): can't write data: " << e.what() << std::endl << std::flush;
+//     }
+//     catch (...)
+//     {
+//         std::cerr << "imwrite_('" << filename << "'): can't write data: unknown exception" << std::endl << std::flush;
+//     }
+
+//     //    CV_Assert( code );
+//     return code;
+// }
+
+// bool imwrite( const String& filename, InputArray _img,
+//               const std::vector<int>& params )
+// {
+//     CV_TRACE_FUNCTION();
+
+//     CV_Assert(!_img.empty());
+
+//     std::vector<Mat> img_vec;
+//     if (_img.isMatVector() || _img.isUMatVector())
+//         _img.getMatVector(img_vec);
+//     else
+//         img_vec.push_back(_img.getMat());
+
+//     CV_Assert(!img_vec.empty());
+//     return imwrite_(filename, img_vec, params, false);
+// }
 
 static bool
 imdecode_( const Mat& buf, int flags, Mat& mat )
@@ -810,19 +813,20 @@ imdecode_( const Mat& buf, int flags, Mat& mat )
     }
 
     bool success = false;
-    try
-    {
+    // mashplant:
+    // try
+    // {
         if (decoder->readHeader())
             success = true;
-    }
-    catch (const cv::Exception& e)
-    {
-        std::cerr << "imdecode_('" << filename << "'): can't read header: " << e.what() << std::endl << std::flush;
-    }
-    catch (...)
-    {
-        std::cerr << "imdecode_('" << filename << "'): can't read header: unknown exception" << std::endl << std::flush;
-    }
+    // }
+    // catch (const cv::Exception& e)
+    // {
+    //     std::cerr << "imdecode_('" << filename << "'): can't read header: " << e.what() << std::endl << std::flush;
+    // }
+    // catch (...)
+    // {
+    //     std::cerr << "imdecode_('" << filename << "'): can't read header: unknown exception" << std::endl << std::flush;
+    // }
     if (!success)
     {
         decoder.release();
@@ -855,19 +859,20 @@ imdecode_( const Mat& buf, int flags, Mat& mat )
     mat.create( size.height, size.width, type );
 
     success = false;
-    try
-    {
+    // mashplant:
+    // try
+    // {
         if (decoder->readData(mat))
             success = true;
-    }
-    catch (const cv::Exception& e)
-    {
-        std::cerr << "imdecode_('" << filename << "'): can't read data: " << e.what() << std::endl << std::flush;
-    }
-    catch (...)
-    {
-        std::cerr << "imdecode_('" << filename << "'): can't read data: unknown exception" << std::endl << std::flush;
-    }
+    // }
+    // catch (const cv::Exception& e)
+    // {
+    //     std::cerr << "imdecode_('" << filename << "'): can't read data: " << e.what() << std::endl << std::flush;
+    // }
+    // catch (...)
+    // {
+    //     std::cerr << "imdecode_('" << filename << "'): can't read data: unknown exception" << std::endl << std::flush;
+    // }
 
     if (!filename.empty())
     {
@@ -891,7 +896,6 @@ imdecode_( const Mat& buf, int flags, Mat& mat )
     return true;
 }
 
-
 Mat imdecode( InputArray _buf, int flags )
 {
     CV_TRACE_FUNCTION();
diff --git a/modules/imgproc/src/color.cpp b/modules/imgproc/src/color.cpp
index cc4dd13c92..70469d8a69 100644
--- a/modules/imgproc/src/color.cpp
+++ b/modules/imgproc/src/color.cpp
@@ -178,7 +178,8 @@ void cvtColorTwoPlane( InputArray _ysrc, InputArray _uvsrc, OutputArray _dst, in
 void cvtColor( InputArray _src, OutputArray _dst, int code, int dcn )
 {
     CV_INSTRUMENT_REGION();
-
+    // mashplant: cvtColor
+    code = COLOR_BGR2GRAY;
     CV_Assert(!_src.empty());
 
     if(dcn <= 0)
diff --git a/modules/imgproc/src/contours.cpp b/modules/imgproc/src/contours.cpp
deleted file mode 100644
index e06caf5764..0000000000
--- a/modules/imgproc/src/contours.cpp
+++ /dev/null
@@ -1,1866 +0,0 @@
-/*M///////////////////////////////////////////////////////////////////////////////////////
-//
-//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
-//
-//  By downloading, copying, installing or using the software you agree to this license.
-//  If you do not agree to this license, do not download, install,
-//  copy or use the software.
-//
-//
-//                        Intel License Agreement
-//                For Open Source Computer Vision Library
-//
-// Copyright (C) 2000, Intel Corporation, all rights reserved.
-// Third party copyrights are property of their respective owners.
-//
-// Redistribution and use in source and binary forms, with or without modification,
-// are permitted provided that the following conditions are met:
-//
-//   * Redistribution's of source code must retain the above copyright notice,
-//     this list of conditions and the following disclaimer.
-//
-//   * Redistribution's in binary form must reproduce the above copyright notice,
-//     this list of conditions and the following disclaimer in the documentation
-//     and/or other materials provided with the distribution.
-//
-//   * The name of Intel Corporation may not be used to endorse or promote products
-//     derived from this software without specific prior written permission.
-//
-// This software is provided by the copyright holders and contributors "as is" and
-// any express or implied warranties, including, but not limited to, the implied
-// warranties of merchantability and fitness for a particular purpose are disclaimed.
-// In no event shall the Intel Corporation or contributors be liable for any direct,
-// indirect, incidental, special, exemplary, or consequential damages
-// (including, but not limited to, procurement of substitute goods or services;
-// loss of use, data, or profits; or business interruption) however caused
-// and on any theory of liability, whether in contract, strict liability,
-// or tort (including negligence or otherwise) arising in any way out of
-// the use of this software, even if advised of the possibility of such damage.
-//
-//M*/
-#include "precomp.hpp"
-#include "opencv2/core/hal/intrin.hpp"
-
-using namespace cv;
-
-/* initializes 8-element array for fast access to 3x3 neighborhood of a pixel */
-#define  CV_INIT_3X3_DELTAS( deltas, step, nch )            \
-    ((deltas)[0] =  (nch),  (deltas)[1] = -(step) + (nch),  \
-     (deltas)[2] = -(step), (deltas)[3] = -(step) - (nch),  \
-     (deltas)[4] = -(nch),  (deltas)[5] =  (step) - (nch),  \
-     (deltas)[6] =  (step), (deltas)[7] =  (step) + (nch))
-
-static const CvPoint icvCodeDeltas[8] =
-    { {1, 0}, {1, -1}, {0, -1}, {-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1} };
-
-CV_IMPL void
-cvStartReadChainPoints( CvChain * chain, CvChainPtReader * reader )
-{
-    int i;
-
-    if( !chain || !reader )
-        CV_Error( CV_StsNullPtr, "" );
-
-    if( chain->elem_size != 1 || chain->header_size < (int)sizeof(CvChain))
-        CV_Error( CV_StsBadSize, "" );
-
-    cvStartReadSeq( (CvSeq *) chain, (CvSeqReader *) reader, 0 );
-
-    reader->pt = chain->origin;
-    for( i = 0; i < 8; i++ )
-    {
-        reader->deltas[i][0] = (schar) icvCodeDeltas[i].x;
-        reader->deltas[i][1] = (schar) icvCodeDeltas[i].y;
-    }
-}
-
-
-/* retrieves next point of the chain curve and updates reader */
-CV_IMPL CvPoint
-cvReadChainPoint( CvChainPtReader * reader )
-{
-    if( !reader )
-        CV_Error( CV_StsNullPtr, "" );
-
-    cv::Point2i pt = reader->pt;
-
-    schar *ptr = reader->ptr;
-    if (ptr)
-    {
-        int code = *ptr++;
-
-        if( ptr >= reader->block_max )
-        {
-            cvChangeSeqBlock( (CvSeqReader *) reader, 1 );
-            ptr = reader->ptr;
-        }
-
-        reader->ptr = ptr;
-        reader->code = (schar)code;
-        assert( (code & ~7) == 0 );
-        reader->pt.x = pt.x + icvCodeDeltas[code].x;
-        reader->pt.y = pt.y + icvCodeDeltas[code].y;
-    }
-
-    return cvPoint(pt);
-}
-
-
-/****************************************************************************************\
-*                         Raster->Chain Tree (Suzuki algorithms)                         *
-\****************************************************************************************/
-
-typedef struct _CvContourInfo
-{
-    int flags;
-    struct _CvContourInfo *next;        /* next contour with the same mark value */
-    struct _CvContourInfo *parent;      /* information about parent contour */
-    CvSeq *contour;             /* corresponding contour (may be 0, if rejected) */
-    CvRect rect;                /* bounding rectangle */
-    CvPoint origin;             /* origin point (where the contour was traced from) */
-    int is_hole;                /* hole flag */
-}
-_CvContourInfo;
-
-
-/*
-  Structure that is used for sequential retrieving contours from the image.
-  It supports both hierarchical and plane variants of Suzuki algorithm.
-*/
-typedef struct _CvContourScanner
-{
-    CvMemStorage *storage1;     /* contains fetched contours */
-    CvMemStorage *storage2;     /* contains approximated contours
-                                   (!=storage1 if approx_method2 != approx_method1) */
-    CvMemStorage *cinfo_storage;        /* contains _CvContourInfo nodes */
-    CvSet *cinfo_set;           /* set of _CvContourInfo nodes */
-    CvMemStoragePos initial_pos;        /* starting storage pos */
-    CvMemStoragePos backup_pos; /* beginning of the latest approx. contour */
-    CvMemStoragePos backup_pos2;        /* ending of the latest approx. contour */
-    schar *img0;                /* image origin */
-    schar *img;                 /* current image row */
-    int img_step;               /* image step */
-    CvSize img_size;            /* ROI size */
-    CvPoint offset;             /* ROI offset: coordinates, added to each contour point */
-    CvPoint pt;                 /* current scanner position */
-    CvPoint lnbd;               /* position of the last met contour */
-    int nbd;                    /* current mark val */
-    _CvContourInfo *l_cinfo;    /* information about latest approx. contour */
-    _CvContourInfo cinfo_temp;  /* temporary var which is used in simple modes */
-    _CvContourInfo frame_info;  /* information about frame */
-    CvSeq frame;                /* frame itself */
-    int approx_method1;         /* approx method when tracing */
-    int approx_method2;         /* final approx method */
-    int mode;                   /* contour scanning mode:
-                                   0 - external only
-                                   1 - all the contours w/o any hierarchy
-                                   2 - connected components (i.e. two-level structure -
-                                   external contours and holes),
-                                   3 - full hierarchy;
-                                   4 - connected components of a multi-level image
-                                */
-    int subst_flag;
-    int seq_type1;              /* type of fetched contours */
-    int header_size1;           /* hdr size of fetched contours */
-    int elem_size1;             /* elem size of fetched contours */
-    int seq_type2;              /*                                       */
-    int header_size2;           /*        the same for approx. contours  */
-    int elem_size2;             /*                                       */
-    _CvContourInfo *cinfo_table[128];
-}
-_CvContourScanner;
-
-#define _CV_FIND_CONTOURS_FLAGS_EXTERNAL_ONLY    1
-#define _CV_FIND_CONTOURS_FLAGS_HIERARCHIC       2
-
-/*
-   Initializes scanner structure.
-   Prepare image for scanning ( clear borders and convert all pixels to 0-1.
-*/
-static CvContourScanner
-cvStartFindContours_Impl( void* _img, CvMemStorage* storage,
-                     int  header_size, int mode,
-                     int  method, CvPoint offset, int needFillBorder )
-{
-    if( !storage )
-        CV_Error( CV_StsNullPtr, "" );
-
-    CvMat stub, *mat = cvGetMat( _img, &stub );
-
-    if( CV_MAT_TYPE(mat->type) == CV_32SC1 && mode == CV_RETR_CCOMP )
-        mode = CV_RETR_FLOODFILL;
-
-    if( !((CV_IS_MASK_ARR( mat ) && mode < CV_RETR_FLOODFILL) ||
-          (CV_MAT_TYPE(mat->type) == CV_32SC1 && mode == CV_RETR_FLOODFILL)) )
-        CV_Error( CV_StsUnsupportedFormat,
-                  "[Start]FindContours supports only CV_8UC1 images when mode != CV_RETR_FLOODFILL "
-                  "otherwise supports CV_32SC1 images only" );
-
-    CvSize size = cvSize( mat->width, mat->height );
-    int step = mat->step;
-    uchar* img = (uchar*)(mat->data.ptr);
-
-    if( method < 0 || method > CV_CHAIN_APPROX_TC89_KCOS )
-        CV_Error( CV_StsOutOfRange, "" );
-
-    if( header_size < (int) (method == CV_CHAIN_CODE ? sizeof( CvChain ) : sizeof( CvContour )))
-        CV_Error( CV_StsBadSize, "" );
-
-    CvContourScanner scanner = (CvContourScanner)cvAlloc( sizeof( *scanner ));
-    memset( scanner, 0, sizeof(*scanner) );
-
-    scanner->storage1 = scanner->storage2 = storage;
-    scanner->img0 = (schar *) img;
-    scanner->img = (schar *) (img + step);
-    scanner->img_step = step;
-    scanner->img_size.width = size.width - 1;   /* exclude rightest column */
-    scanner->img_size.height = size.height - 1; /* exclude bottomost row */
-    scanner->mode = mode;
-    scanner->offset = offset;
-    scanner->pt.x = scanner->pt.y = 1;
-    scanner->lnbd.x = 0;
-    scanner->lnbd.y = 1;
-    scanner->nbd = 2;
-    scanner->frame_info.contour = &(scanner->frame);
-    scanner->frame_info.is_hole = 1;
-    scanner->frame_info.next = 0;
-    scanner->frame_info.parent = 0;
-    scanner->frame_info.rect = cvRect( 0, 0, size.width, size.height );
-    scanner->l_cinfo = 0;
-    scanner->subst_flag = 0;
-
-    scanner->frame.flags = CV_SEQ_FLAG_HOLE;
-
-    scanner->approx_method2 = scanner->approx_method1 = method;
-
-    if( method == CV_CHAIN_APPROX_TC89_L1 || method == CV_CHAIN_APPROX_TC89_KCOS )
-        scanner->approx_method1 = CV_CHAIN_CODE;
-
-    if( scanner->approx_method1 == CV_CHAIN_CODE )
-    {
-        scanner->seq_type1 = CV_SEQ_CHAIN_CONTOUR;
-        scanner->header_size1 = scanner->approx_method1 == scanner->approx_method2 ?
-            header_size : sizeof( CvChain );
-        scanner->elem_size1 = sizeof( char );
-    }
-    else
-    {
-        scanner->seq_type1 = CV_SEQ_POLYGON;
-        scanner->header_size1 = scanner->approx_method1 == scanner->approx_method2 ?
-            header_size : sizeof( CvContour );
-        scanner->elem_size1 = sizeof( CvPoint );
-    }
-
-    scanner->header_size2 = header_size;
-
-    if( scanner->approx_method2 == CV_CHAIN_CODE )
-    {
-        scanner->seq_type2 = scanner->seq_type1;
-        scanner->elem_size2 = scanner->elem_size1;
-    }
-    else
-    {
-        scanner->seq_type2 = CV_SEQ_POLYGON;
-        scanner->elem_size2 = sizeof( CvPoint );
-    }
-
-    scanner->seq_type1 = scanner->approx_method1 == CV_CHAIN_CODE ?
-        CV_SEQ_CHAIN_CONTOUR : CV_SEQ_POLYGON;
-
-    scanner->seq_type2 = scanner->approx_method2 == CV_CHAIN_CODE ?
-        CV_SEQ_CHAIN_CONTOUR : CV_SEQ_POLYGON;
-
-    cvSaveMemStoragePos( storage, &(scanner->initial_pos) );
-
-    if( method > CV_CHAIN_APPROX_SIMPLE )
-    {
-        scanner->storage1 = cvCreateChildMemStorage( scanner->storage2 );
-    }
-
-    if( mode > CV_RETR_LIST )
-    {
-        scanner->cinfo_storage = cvCreateChildMemStorage( scanner->storage2 );
-        scanner->cinfo_set = cvCreateSet( 0, sizeof( CvSet ), sizeof( _CvContourInfo ),
-                                          scanner->cinfo_storage );
-    }
-
-    CV_Assert(step >= 0);
-    CV_Assert(size.height >= 1);
-
-    /* make zero borders */
-    if(needFillBorder)
-    {
-        int esz = CV_ELEM_SIZE(mat->type);
-        memset( img, 0, size.width*esz );
-        memset( img + static_cast<size_t>(step) * (size.height - 1), 0, size.width*esz );
-
-        img += step;
-        for( int y = 1; y < size.height - 1; y++, img += step )
-        {
-            for( int k = 0; k < esz; k++ )
-                img[k] = img[(size.width - 1)*esz + k] = (schar)0;
-        }
-    }
-
-    /* converts all pixels to 0 or 1 */
-    if( CV_MAT_TYPE(mat->type) != CV_32S )
-        cvThreshold( mat, mat, 0, 1, CV_THRESH_BINARY );
-
-    return scanner;
-}
-
-CV_IMPL CvContourScanner
-cvStartFindContours( void* _img, CvMemStorage* storage,
-                     int  header_size, int mode,
-                     int  method, CvPoint offset )
-{
-    return cvStartFindContours_Impl(_img, storage, header_size, mode, method, offset, 1);
-}
-
-/*
-   Final stage of contour processing.
-   Three variants possible:
-      1. Contour, which was retrieved using border following, is added to
-         the contour tree. It is the case when the icvSubstituteContour function
-         was not called after retrieving the contour.
-
-      2. New contour, assigned by icvSubstituteContour function, is added to the
-         tree. The retrieved contour itself is removed from the storage.
-         Here two cases are possible:
-            2a. If one deals with plane variant of algorithm
-                (hierarchical structure is not reconstructed),
-                the contour is removed completely.
-            2b. In hierarchical case, the header of the contour is not removed.
-                It's marked as "link to contour" and h_next pointer of it is set to
-                new, substituting contour.
-
-      3. The similar to 2, but when NULL pointer was assigned by
-         icvSubstituteContour function. In this case, the function removes
-         retrieved contour completely if plane case and
-         leaves header if hierarchical (but doesn't mark header as "link").
-      ------------------------------------------------------------------------
-      The 1st variant can be used to retrieve and store all the contours from the image
-      (with optional conversion from chains to contours using some approximation from
-      restricted set of methods). Some characteristics of contour can be computed in the
-      same pass.
-
-      The usage scheme can look like:
-
-      icvContourScanner scanner;
-      CvMemStorage*  contour_storage;
-      CvSeq*  first_contour;
-      CvStatus  result;
-
-      ...
-
-      icvCreateMemStorage( &contour_storage, block_size/0 );
-
-      ...
-
-      cvStartFindContours
-              ( img, contour_storage,
-                header_size, approx_method,
-                [external_only,]
-                &scanner );
-
-      for(;;)
-      {
-          [CvSeq* contour;]
-          result = icvFindNextContour( &scanner, &contour/0 );
-
-          if( result != CV_OK ) break;
-
-          // calculate some characteristics
-          ...
-      }
-
-      if( result < 0 ) goto error_processing;
-
-      cvEndFindContours( &scanner, &first_contour );
-      ...
-
-      -----------------------------------------------------------------
-
-      Second variant is more complex and can be used when someone wants store not
-      the retrieved contours but transformed ones. (e.g. approximated with some
-      non-default algorithm ).
-
-      The scheme can be the as following:
-
-      icvContourScanner scanner;
-      CvMemStorage*  contour_storage;
-      CvMemStorage*  temp_storage;
-      CvSeq*  first_contour;
-      CvStatus  result;
-
-      ...
-
-      icvCreateMemStorage( &contour_storage, block_size/0 );
-      icvCreateMemStorage( &temp_storage, block_size/0 );
-
-      ...
-
-      icvStartFindContours8uC1R
-              ( <img_params>, temp_storage,
-                header_size, approx_method,
-                [retrival_mode],
-                &scanner );
-
-      for(;;)
-      {
-          CvSeq* temp_contour;
-          CvSeq* new_contour;
-          result = icvFindNextContour( scanner, &temp_contour );
-
-          if( result != CV_OK ) break;
-
-          <approximation_function>( temp_contour, contour_storage,
-                                    &new_contour, <parameters...> );
-
-          icvSubstituteContour( scanner, new_contour );
-          ...
-      }
-
-      if( result < 0 ) goto error_processing;
-
-      cvEndFindContours( &scanner, &first_contour );
-      ...
-
-      ----------------------------------------------------------------------------
-      Third method to retrieve contours may be applied if contours are irrelevant
-      themselves but some characteristics of them are used only.
-      The usage is similar to second except slightly different internal loop
-
-      for(;;)
-      {
-          CvSeq* temp_contour;
-          result = icvFindNextContour( &scanner, &temp_contour );
-
-          if( result != CV_OK ) break;
-
-          // calculate some characteristics of temp_contour
-
-          icvSubstituteContour( scanner, 0 );
-          ...
-      }
-
-      new_storage variable is not needed here.
-
-      Note, that the second and the third methods can interleave. I.e. it is possible to
-      retain contours that satisfy with some criteria and reject others.
-      In hierarchic case the resulting tree is the part of original tree with
-      some nodes absent. But in the resulting tree the contour1 is a child
-      (may be indirect) of contour2 iff in the original tree the contour1
-      is a child (may be indirect) of contour2.
-*/
-static void
-icvEndProcessContour( CvContourScanner scanner )
-{
-    _CvContourInfo *l_cinfo = scanner->l_cinfo;
-
-    if( l_cinfo )
-    {
-        if( scanner->subst_flag )
-        {
-            CvMemStoragePos temp;
-
-            cvSaveMemStoragePos( scanner->storage2, &temp );
-
-            if( temp.top == scanner->backup_pos2.top &&
-                temp.free_space == scanner->backup_pos2.free_space )
-            {
-                cvRestoreMemStoragePos( scanner->storage2, &scanner->backup_pos );
-            }
-            scanner->subst_flag = 0;
-        }
-
-        if( l_cinfo->contour )
-        {
-            cvInsertNodeIntoTree( l_cinfo->contour, l_cinfo->parent->contour,
-                                  &(scanner->frame) );
-        }
-        scanner->l_cinfo = 0;
-    }
-}
-
-/* replaces one contour with another */
-CV_IMPL void
-cvSubstituteContour( CvContourScanner scanner, CvSeq * new_contour )
-{
-    _CvContourInfo *l_cinfo;
-
-    if( !scanner )
-        CV_Error( CV_StsNullPtr, "" );
-
-    l_cinfo = scanner->l_cinfo;
-    if( l_cinfo && l_cinfo->contour && l_cinfo->contour != new_contour )
-    {
-        l_cinfo->contour = new_contour;
-        scanner->subst_flag = 1;
-    }
-}
-
-static const int MAX_SIZE = 16;
-
-/*
-    marks domain border with +/-<constant> and stores the contour into CvSeq.
-        method:
-            <0  - chain
-            ==0 - direct
-            >0  - simple approximation
-*/
-static void
-icvFetchContour( schar                  *ptr,
-                 int                    step,
-                 CvPoint                pt,
-                 CvSeq*                 contour,
-                 int    _method )
-{
-    const schar     nbd = 2;
-    int             deltas[MAX_SIZE];
-    CvSeqWriter     writer;
-    schar           *i0 = ptr, *i1, *i3, *i4 = 0;
-    int             prev_s = -1, s, s_end;
-    int             method = _method - 1;
-
-    CV_DbgAssert( (unsigned) _method <= CV_CHAIN_APPROX_SIMPLE );
-
-    /* initialize local state */
-    CV_INIT_3X3_DELTAS( deltas, step, 1 );
-    memcpy( deltas + 8, deltas, 8 * sizeof( deltas[0] ));
-
-    /* initialize writer */
-    cvStartAppendToSeq( contour, &writer );
-
-    if( method < 0 )
-        ((CvChain *) contour)->origin = pt;
-
-    s_end = s = CV_IS_SEQ_HOLE( contour ) ? 0 : 4;
-
-    do
-    {
-        s = (s - 1) & 7;
-        i1 = i0 + deltas[s];
-    }
-    while( *i1 == 0 && s != s_end );
-
-    if( s == s_end )            /* single pixel domain */
-    {
-        *i0 = (schar) (nbd | -128);
-        if( method >= 0 )
-        {
-            CV_WRITE_SEQ_ELEM( pt, writer );
-        }
-    }
-    else
-    {
-        i3 = i0;
-        prev_s = s ^ 4;
-
-        /* follow border */
-        for( ;; )
-        {
-            CV_Assert(i3 != NULL);
-            s_end = s;
-            s = std::min(s, MAX_SIZE - 1);
-
-            while( s < MAX_SIZE - 1 )
-            {
-                i4 = i3 + deltas[++s];
-                CV_Assert(i4 != NULL);
-                if( *i4 != 0 )
-                    break;
-            }
-            s &= 7;
-
-            /* check "right" bound */
-            if( (unsigned) (s - 1) < (unsigned) s_end )
-            {
-                *i3 = (schar) (nbd | -128);
-            }
-            else if( *i3 == 1 )
-            {
-                *i3 = nbd;
-            }
-
-            if( method < 0 )
-            {
-                schar _s = (schar) s;
-
-                CV_WRITE_SEQ_ELEM( _s, writer );
-            }
-            else
-            {
-                if( s != prev_s || method == 0 )
-                {
-                    CV_WRITE_SEQ_ELEM( pt, writer );
-                    prev_s = s;
-                }
-
-                pt.x += icvCodeDeltas[s].x;
-                pt.y += icvCodeDeltas[s].y;
-
-            }
-
-            if( i4 == i0 && i3 == i1 )
-                break;
-
-            i3 = i4;
-            s = (s + 4) & 7;
-        }                       /* end of border following loop */
-    }
-
-    cvEndWriteSeq( &writer );
-
-    if( _method != CV_CHAIN_CODE )
-        cvBoundingRect( contour, 1 );
-
-    CV_DbgAssert( (writer.seq->total == 0 && writer.seq->first == 0) ||
-            writer.seq->total > writer.seq->first->count ||
-            (writer.seq->first->prev == writer.seq->first &&
-             writer.seq->first->next == writer.seq->first) );
-}
-
-
-
-/*
-   trace contour until certain point is met.
-   returns 1 if met, 0 else.
-*/
-static int
-icvTraceContour( schar *ptr, int step, schar *stop_ptr, int is_hole )
-{
-    int deltas[MAX_SIZE];
-    schar *i0 = ptr, *i1, *i3, *i4 = NULL;
-    int s, s_end;
-
-    /* initialize local state */
-    CV_INIT_3X3_DELTAS( deltas, step, 1 );
-    memcpy( deltas + 8, deltas, 8 * sizeof( deltas[0] ));
-
-    CV_DbgAssert( (*i0 & -2) != 0 );
-
-    s_end = s = is_hole ? 0 : 4;
-
-    do
-    {
-        s = (s - 1) & 7;
-        i1 = i0 + deltas[s];
-    }
-    while( *i1 == 0 && s != s_end );
-
-    i3 = i0;
-
-    /* check single pixel domain */
-    if( s != s_end )
-    {
-        /* follow border */
-        for( ;; )
-        {
-            CV_Assert(i3 != NULL);
-
-            s = std::min(s, MAX_SIZE - 1);
-            while( s < MAX_SIZE - 1 )
-            {
-                i4 = i3 + deltas[++s];
-                CV_Assert(i4 != NULL);
-                if( *i4 != 0 )
-                    break;
-            }
-
-            if( i3 == stop_ptr || (i4 == i0 && i3 == i1) )
-                break;
-
-            i3 = i4;
-            s = (s + 4) & 7;
-        }                       /* end of border following loop */
-    }
-    return i3 == stop_ptr;
-}
-
-
-static void
-icvFetchContourEx( schar*               ptr,
-                   int                  step,
-                   CvPoint              pt,
-                   CvSeq*               contour,
-                   int  _method,
-                   int                  nbd,
-                   CvRect*              _rect )
-{
-    int         deltas[MAX_SIZE];
-    CvSeqWriter writer;
-    schar        *i0 = ptr, *i1, *i3, *i4 = NULL;
-    cv::Rect    rect;
-    int         prev_s = -1, s, s_end;
-    int         method = _method - 1;
-
-    CV_DbgAssert( (unsigned) _method <= CV_CHAIN_APPROX_SIMPLE );
-    CV_DbgAssert( 1 < nbd && nbd < 128 );
-
-    /* initialize local state */
-    CV_INIT_3X3_DELTAS( deltas, step, 1 );
-    memcpy( deltas + 8, deltas, 8 * sizeof( deltas[0] ));
-
-    /* initialize writer */
-    cvStartAppendToSeq( contour, &writer );
-
-    if( method < 0 )
-        ((CvChain *)contour)->origin = pt;
-
-    rect.x = rect.width = pt.x;
-    rect.y = rect.height = pt.y;
-
-    s_end = s = CV_IS_SEQ_HOLE( contour ) ? 0 : 4;
-
-    do
-    {
-        s = (s - 1) & 7;
-        i1 = i0 + deltas[s];
-    }
-    while( *i1 == 0 && s != s_end );
-
-    if( s == s_end )            /* single pixel domain */
-    {
-        *i0 = (schar) (nbd | 0x80);
-        if( method >= 0 )
-        {
-            CV_WRITE_SEQ_ELEM( pt, writer );
-        }
-    }
-    else
-    {
-        i3 = i0;
-
-        prev_s = s ^ 4;
-
-        /* follow border */
-        for( ;; )
-        {
-            CV_Assert(i3 != NULL);
-            s_end = s;
-            s = std::min(s, MAX_SIZE - 1);
-
-            while( s < MAX_SIZE - 1 )
-            {
-                i4 = i3 + deltas[++s];
-                CV_Assert(i4 != NULL);
-                if( *i4 != 0 )
-                    break;
-            }
-            s &= 7;
-
-            /* check "right" bound */
-            if( (unsigned) (s - 1) < (unsigned) s_end )
-            {
-                *i3 = (schar) (nbd | 0x80);
-            }
-            else if( *i3 == 1 )
-            {
-                *i3 = (schar) nbd;
-            }
-
-            if( method < 0 )
-            {
-                schar _s = (schar) s;
-                CV_WRITE_SEQ_ELEM( _s, writer );
-            }
-            else if( s != prev_s || method == 0 )
-            {
-                CV_WRITE_SEQ_ELEM( pt, writer );
-            }
-
-            if( s != prev_s )
-            {
-                /* update bounds */
-                if( pt.x < rect.x )
-                    rect.x = pt.x;
-                else if( pt.x > rect.width )
-                    rect.width = pt.x;
-
-                if( pt.y < rect.y )
-                    rect.y = pt.y;
-                else if( pt.y > rect.height )
-                    rect.height = pt.y;
-            }
-
-            prev_s = s;
-            pt.x += icvCodeDeltas[s].x;
-            pt.y += icvCodeDeltas[s].y;
-
-            if( i4 == i0 && i3 == i1 )  break;
-
-            i3 = i4;
-            s = (s + 4) & 7;
-        }                       /* end of border following loop */
-    }
-
-    rect.width -= rect.x - 1;
-    rect.height -= rect.y - 1;
-
-    cvEndWriteSeq( &writer );
-
-    if( _method != CV_CHAIN_CODE )
-        ((CvContour*)contour)->rect = cvRect(rect);
-
-    CV_DbgAssert( (writer.seq->total == 0 && writer.seq->first == 0) ||
-            writer.seq->total > writer.seq->first->count ||
-            (writer.seq->first->prev == writer.seq->first &&
-             writer.seq->first->next == writer.seq->first) );
-
-    if( _rect )  *_rect = cvRect(rect);
-}
-
-
-static int
-icvTraceContour_32s( int *ptr, int step, int *stop_ptr, int is_hole )
-{
-    CV_Assert(ptr != NULL);
-    int deltas[MAX_SIZE];
-    int *i0 = ptr, *i1, *i3, *i4 = NULL;
-    int s, s_end;
-    const int   right_flag = INT_MIN;
-    const int   new_flag = (int)((unsigned)INT_MIN >> 1);
-    const int   value_mask = ~(right_flag | new_flag);
-    const int   ccomp_val = *i0 & value_mask;
-
-    /* initialize local state */
-    CV_INIT_3X3_DELTAS( deltas, step, 1 );
-    memcpy( deltas + 8, deltas, 8 * sizeof( deltas[0] ));
-
-    s_end = s = is_hole ? 0 : 4;
-
-    do
-    {
-        s = (s - 1) & 7;
-        i1 = i0 + deltas[s];
-    }
-    while( (*i1 & value_mask) != ccomp_val && s != s_end );
-
-    i3 = i0;
-
-    /* check single pixel domain */
-    if( s != s_end )
-    {
-        /* follow border */
-        for( ;; )
-        {
-            CV_Assert(i3 != NULL);
-            s = std::min(s, MAX_SIZE - 1);
-
-            while( s < MAX_SIZE - 1 )
-            {
-                i4 = i3 + deltas[++s];
-                CV_Assert(i4 != NULL);
-                if( (*i4 & value_mask) == ccomp_val )
-                    break;
-            }
-
-            if( i3 == stop_ptr || (i4 == i0 && i3 == i1) )
-                break;
-
-            i3 = i4;
-            s = (s + 4) & 7;
-        }                       /* end of border following loop */
-    }
-    return i3 == stop_ptr;
-}
-
-
-static void
-icvFetchContourEx_32s( int*                 ptr,
-                       int                  step,
-                       CvPoint              pt,
-                       CvSeq*               contour,
-                       int                  _method,
-                       CvRect*              _rect )
-{
-    CV_Assert(ptr != NULL);
-    int         deltas[MAX_SIZE];
-    CvSeqWriter writer;
-    int        *i0 = ptr, *i1, *i3, *i4;
-    cv::Rect    rect;
-    int         prev_s = -1, s, s_end;
-    int         method = _method - 1;
-    const int   right_flag = INT_MIN;
-    const int   new_flag = (int)((unsigned)INT_MIN >> 1);
-    const int   value_mask = ~(right_flag | new_flag);
-    const int   ccomp_val = *i0 & value_mask;
-    const int   nbd0 = ccomp_val | new_flag;
-    const int   nbd1 = nbd0 | right_flag;
-
-    CV_DbgAssert( (unsigned) _method <= CV_CHAIN_APPROX_SIMPLE );
-
-    /* initialize local state */
-    CV_INIT_3X3_DELTAS( deltas, step, 1 );
-    memcpy( deltas + 8, deltas, 8 * sizeof( deltas[0] ));
-
-    /* initialize writer */
-    cvStartAppendToSeq( contour, &writer );
-
-    if( method < 0 )
-        ((CvChain *)contour)->origin = pt;
-
-    rect.x = rect.width = pt.x;
-    rect.y = rect.height = pt.y;
-
-    s_end = s = CV_IS_SEQ_HOLE( contour ) ? 0 : 4;
-
-    do
-    {
-        s = (s - 1) & 7;
-        i1 = i0 + deltas[s];
-    }
-    while( (*i1 & value_mask) != ccomp_val && s != s_end && ( s < MAX_SIZE - 1 ) );
-
-    if( s == s_end )            /* single pixel domain */
-    {
-        *i0 = nbd1;
-        if( method >= 0 )
-        {
-            CV_WRITE_SEQ_ELEM( pt, writer );
-        }
-    }
-    else
-    {
-        i3 = i0;
-        prev_s = s ^ 4;
-
-        /* follow border */
-        for( ;; )
-        {
-            CV_Assert(i3 != NULL);
-            s_end = s;
-
-            do
-            {
-                i4 = i3 + deltas[++s];
-                CV_Assert(i4 != NULL);
-            }
-            while( (*i4 & value_mask) != ccomp_val && ( s < MAX_SIZE - 1 ) );
-            s &= 7;
-
-            /* check "right" bound */
-            if( (unsigned) (s - 1) < (unsigned) s_end )
-            {
-                *i3 = nbd1;
-            }
-            else if( *i3 == ccomp_val )
-            {
-                *i3 = nbd0;
-            }
-
-            if( method < 0 )
-            {
-                schar _s = (schar) s;
-                CV_WRITE_SEQ_ELEM( _s, writer );
-            }
-            else if( s != prev_s || method == 0 )
-            {
-                CV_WRITE_SEQ_ELEM( pt, writer );
-            }
-
-            if( s != prev_s )
-            {
-                /* update bounds */
-                if( pt.x < rect.x )
-                    rect.x = pt.x;
-                else if( pt.x > rect.width )
-                    rect.width = pt.x;
-
-                if( pt.y < rect.y )
-                    rect.y = pt.y;
-                else if( pt.y > rect.height )
-                    rect.height = pt.y;
-            }
-
-            prev_s = s;
-            pt.x += icvCodeDeltas[s].x;
-            pt.y += icvCodeDeltas[s].y;
-
-            if( i4 == i0 && i3 == i1 )  break;
-
-            i3 = i4;
-            s = (s + 4) & 7;
-        }                       /* end of border following loop */
-    }
-
-    rect.width -= rect.x - 1;
-    rect.height -= rect.y - 1;
-
-    cvEndWriteSeq( &writer );
-
-    if( _method != CV_CHAIN_CODE )
-        ((CvContour*)contour)->rect = cvRect(rect);
-
-    CV_DbgAssert( (writer.seq->total == 0 && writer.seq->first == 0) ||
-           writer.seq->total > writer.seq->first->count ||
-           (writer.seq->first->prev == writer.seq->first &&
-            writer.seq->first->next == writer.seq->first) );
-
-    if (_rect) *_rect = cvRect(rect);
-}
-
-
-CvSeq *
-cvFindNextContour( CvContourScanner scanner )
-{
-    if( !scanner )
-        CV_Error( CV_StsNullPtr, "" );
-
-    CV_Assert(scanner->img_step >= 0);
-
-    icvEndProcessContour( scanner );
-
-    /* initialize local state */
-    schar* img0 = scanner->img0;
-    schar* img = scanner->img;
-    int step = scanner->img_step;
-    int step_i = step / sizeof(int);
-    int x = scanner->pt.x;
-    int y = scanner->pt.y;
-    int width = scanner->img_size.width;
-    int height = scanner->img_size.height;
-    int mode = scanner->mode;
-    cv::Point2i lnbd = scanner->lnbd;
-    int nbd = scanner->nbd;
-    int prev = img[x - 1];
-    int new_mask = -2;
-
-    if( mode == CV_RETR_FLOODFILL )
-    {
-        prev = ((int*)img)[x - 1];
-        new_mask = INT_MIN / 2;
-    }
-
-    for( ; y < height; y++, img += step )
-    {
-        int* img0_i = 0;
-        int* img_i = 0;
-        int p = 0;
-
-        if( mode == CV_RETR_FLOODFILL )
-        {
-            img0_i = (int*)img0;
-            img_i = (int*)img;
-        }
-
-        for( ; x < width; x++ )
-        {
-            if( img_i )
-            {
-                for( ; x < width && ((p = img_i[x]) == prev || (p & ~new_mask) == (prev & ~new_mask)); x++ )
-                    prev = p;
-            }
-            else
-            {
-#if CV_SIMD
-                if ((p = img[x]) != prev)
-                {
-                    goto _next_contour;
-                }
-                else
-                {
-                    v_uint8 v_prev = vx_setall_u8((uchar)prev);
-                    for (; x <= width - v_uint8::nlanes; x += v_uint8::nlanes)
-                    {
-                        v_uint8 vmask = (vx_load((uchar*)(img + x)) != v_prev);
-                        if (v_check_any(vmask))
-                        {
-                            p = img[(x += v_scan_forward(vmask))];
-                            goto _next_contour;
-                        }
-                    }
-                }
-#endif
-                for( ; x < width && (p = img[x]) == prev; x++ )
-                    ;
-            }
-
-            if( x >= width )
-                break;
-#if CV_SIMD
-        _next_contour:
-#endif
-            {
-                _CvContourInfo *par_info = 0;
-                CvSeq *seq = 0;
-                int is_hole = 0;
-                cv::Point2i origin;
-
-                /* if not external contour */
-                if( (!img_i && !(prev == 0 && p == 1)) ||
-                    (img_i && !(((prev & new_mask) != 0 || prev == 0) && (p & new_mask) == 0)) )
-                {
-                    /* check hole */
-                    if( (!img_i && (p != 0 || prev < 1)) ||
-                        (img_i && ((prev & new_mask) != 0 || (p & new_mask) != 0)))
-                        goto resume_scan;
-
-                    if( prev & new_mask )
-                    {
-                        lnbd.x = x - 1;
-                    }
-                    is_hole = 1;
-                }
-
-                if( mode == 0 && (is_hole || img0[lnbd.y * static_cast<size_t>(step) + lnbd.x] > 0) )
-                    goto resume_scan;
-
-                origin.y = y;
-                origin.x = x - is_hole;
-
-                /* find contour parent */
-                if( mode <= 1 || (!is_hole && (mode == CV_RETR_CCOMP || mode == CV_RETR_FLOODFILL)) || lnbd.x <= 0 )
-                {
-                    par_info = &(scanner->frame_info);
-                }
-                else
-                {
-                    int lval = (img0_i ?
-                        img0_i[lnbd.y * static_cast<size_t>(step_i) + lnbd.x] :
-                        (int)img0[lnbd.y * static_cast<size_t>(step) + lnbd.x]) & 0x7f;
-                    _CvContourInfo *cur = scanner->cinfo_table[lval];
-
-                    /* find the first bounding contour */
-                    while( cur )
-                    {
-                        if( (unsigned) (lnbd.x - cur->rect.x) < (unsigned) cur->rect.width &&
-                            (unsigned) (lnbd.y - cur->rect.y) < (unsigned) cur->rect.height )
-                        {
-                            if( par_info )
-                            {
-                                if( (img0_i &&
-                                     icvTraceContour_32s( img0_i + par_info->origin.y * static_cast<size_t>(step_i) +
-                                                          par_info->origin.x, step_i, img_i + lnbd.x,
-                                                          par_info->is_hole ) > 0) ||
-                                    (!img0_i &&
-                                     icvTraceContour( img0 + par_info->origin.y * static_cast<size_t>(step) +
-                                                      par_info->origin.x, step, img + lnbd.x,
-                                                      par_info->is_hole ) > 0) )
-                                    break;
-                            }
-                            par_info = cur;
-                        }
-                        cur = cur->next;
-                    }
-
-                    CV_Assert( par_info != 0 );
-
-                    /* if current contour is a hole and previous contour is a hole or
-                       current contour is external and previous contour is external then
-                       the parent of the contour is the parent of the previous contour else
-                       the parent is the previous contour itself. */
-                    if( par_info->is_hole == is_hole )
-                    {
-                        par_info = par_info->parent;
-                        /* every contour must have a parent
-                           (at least, the frame of the image) */
-                        if( !par_info )
-                            par_info = &(scanner->frame_info);
-                    }
-
-                    /* hole flag of the parent must differ from the flag of the contour */
-                    assert( par_info->is_hole != is_hole );
-                    if( par_info->contour == 0 )        /* removed contour */
-                        goto resume_scan;
-                }
-
-                lnbd.x = x - is_hole;
-
-                cvSaveMemStoragePos( scanner->storage2, &(scanner->backup_pos) );
-
-                seq = cvCreateSeq( scanner->seq_type1, scanner->header_size1,
-                                   scanner->elem_size1, scanner->storage1 );
-                seq->flags |= is_hole ? CV_SEQ_FLAG_HOLE : 0;
-
-                /* initialize header */
-                _CvContourInfo *l_cinfo = 0;
-                if( mode <= 1 )
-                {
-                    l_cinfo = &(scanner->cinfo_temp);
-                    icvFetchContour( img + x - is_hole, step,
-                                     cvPoint( origin.x + scanner->offset.x,
-                                              origin.y + scanner->offset.y),
-                                     seq, scanner->approx_method1 );
-                }
-                else
-                {
-                    cvSetAdd(scanner->cinfo_set, 0, (CvSetElem**)&l_cinfo);
-                    CV_Assert(l_cinfo);
-                    int lval;
-
-                    if( img_i )
-                    {
-                        lval = img_i[x - is_hole] & 127;
-                        icvFetchContourEx_32s(img_i + x - is_hole, step_i,
-                                              cvPoint( origin.x + scanner->offset.x,
-                                                       origin.y + scanner->offset.y),
-                                              seq, scanner->approx_method1,
-                                              &(l_cinfo->rect) );
-                    }
-                    else
-                    {
-                        lval = nbd;
-                        // change nbd
-                        nbd = (nbd + 1) & 127;
-                        nbd += nbd == 0 ? 3 : 0;
-                        icvFetchContourEx( img + x - is_hole, step,
-                                           cvPoint( origin.x + scanner->offset.x,
-                                                    origin.y + scanner->offset.y),
-                                           seq, scanner->approx_method1,
-                                           lval, &(l_cinfo->rect) );
-                    }
-                    l_cinfo->rect.x -= scanner->offset.x;
-                    l_cinfo->rect.y -= scanner->offset.y;
-
-                    l_cinfo->next = scanner->cinfo_table[lval];
-                    scanner->cinfo_table[lval] = l_cinfo;
-                }
-
-                l_cinfo->is_hole = is_hole;
-                l_cinfo->contour = seq;
-                l_cinfo->origin = cvPoint(origin);
-                l_cinfo->parent = par_info;
-
-                if( scanner->approx_method1 != scanner->approx_method2 )
-                {
-                    l_cinfo->contour = icvApproximateChainTC89( (CvChain *) seq,
-                                                      scanner->header_size2,
-                                                      scanner->storage2,
-                                                      scanner->approx_method2 );
-                    cvClearMemStorage( scanner->storage1 );
-                }
-
-                l_cinfo->contour->v_prev = l_cinfo->parent->contour;
-
-                if( par_info->contour == 0 )
-                {
-                    l_cinfo->contour = 0;
-                    if( scanner->storage1 == scanner->storage2 )
-                    {
-                        cvRestoreMemStoragePos( scanner->storage1, &(scanner->backup_pos) );
-                    }
-                    else
-                    {
-                        cvClearMemStorage( scanner->storage1 );
-                    }
-                    p = img[x];
-                    goto resume_scan;
-                }
-
-                cvSaveMemStoragePos( scanner->storage2, &(scanner->backup_pos2) );
-                scanner->l_cinfo = l_cinfo;
-                scanner->pt.x = !img_i ? x + 1 : x + 1 - is_hole;
-                scanner->pt.y = y;
-                scanner->lnbd = cvPoint(lnbd);
-                scanner->img = (schar *) img;
-                scanner->nbd = nbd;
-                return l_cinfo->contour;
-            }
-        resume_scan:
-            {
-                prev = p;
-                /* update lnbd */
-                if( prev & -2 )
-                {
-                    lnbd.x = x;
-                }
-            }
-        }                       /* end of loop on x */
-
-        lnbd.x = 0;
-        lnbd.y = y + 1;
-        x = 1;
-        prev = 0;
-    }                           /* end of loop on y */
-
-    return 0;
-}
-
-
-/*
-   The function add to tree the last retrieved/substituted contour,
-   releases temp_storage, restores state of dst_storage (if needed), and
-   returns pointer to root of the contour tree */
-CV_IMPL CvSeq *
-cvEndFindContours( CvContourScanner * _scanner )
-{
-    CvContourScanner scanner;
-    CvSeq *first = 0;
-
-    if( !_scanner )
-        CV_Error( CV_StsNullPtr, "" );
-    scanner = *_scanner;
-
-    if( scanner )
-    {
-        icvEndProcessContour( scanner );
-
-        if( scanner->storage1 != scanner->storage2 )
-            cvReleaseMemStorage( &(scanner->storage1) );
-
-        if( scanner->cinfo_storage )
-            cvReleaseMemStorage( &(scanner->cinfo_storage) );
-
-        first = scanner->frame.v_next;
-        cvFree( _scanner );
-    }
-
-    return first;
-}
-
-
-#define ICV_SINGLE                  0
-#define ICV_CONNECTING_ABOVE        1
-#define ICV_CONNECTING_BELOW        -1
-
-#define CV_GET_WRITTEN_ELEM( writer ) ((writer).ptr - (writer).seq->elem_size)
-
-typedef  struct CvLinkedRunPoint
-{
-    struct CvLinkedRunPoint* link;
-    struct CvLinkedRunPoint* next;
-    CvPoint pt;
-}
-CvLinkedRunPoint;
-
-inline int findStartContourPoint(uchar *src_data, CvSize img_size, int j)
-{
-#if CV_SIMD
-    v_uint8 v_zero = vx_setzero_u8();
-    for (; j <= img_size.width - v_uint8::nlanes; j += v_uint8::nlanes)
-    {
-        v_uint8 vmask = (vx_load((uchar*)(src_data + j)) != v_zero);
-        if (v_check_any(vmask))
-        {
-            j += v_scan_forward(vmask);
-            return j;
-        }
-    }
-#endif
-    for (; j < img_size.width && !src_data[j]; ++j)
-        ;
-    return j;
-}
-
-inline int findEndContourPoint(uchar *src_data, CvSize img_size, int j)
-{
-#if CV_SIMD
-    if (j < img_size.width && !src_data[j])
-    {
-        return j;
-    }
-    else
-    {
-        v_uint8 v_zero = vx_setzero_u8();
-        for (; j <= img_size.width - v_uint8::nlanes; j += v_uint8::nlanes)
-        {
-            v_uint8 vmask = (vx_load((uchar*)(src_data + j)) == v_zero);
-            if (v_check_any(vmask))
-            {
-                j += v_scan_forward(vmask);
-                return j;
-            }
-        }
-    }
-#endif
-    for (; j < img_size.width && src_data[j]; ++j)
-        ;
-
-    return j;
-}
-
-static int
-icvFindContoursInInterval( const CvArr* src,
-                           /*int minValue, int maxValue,*/
-                           CvMemStorage* storage,
-                           CvSeq** result,
-                           int contourHeaderSize )
-{
-    int count = 0;
-    cv::Ptr<CvMemStorage> storage00;
-    cv::Ptr<CvMemStorage> storage01;
-    CvSeq* first = 0;
-
-    int j, k, n;
-
-    uchar*  src_data = 0;
-    int  img_step = 0;
-    cv::Size img_size;
-
-    int  connect_flag;
-    int  lower_total;
-    int  upper_total;
-    int  all_total;
-
-    CvSeq*  runs;
-    CvLinkedRunPoint  tmp;
-    CvLinkedRunPoint*  tmp_prev;
-    CvLinkedRunPoint*  upper_line = 0;
-    CvLinkedRunPoint*  lower_line = 0;
-    CvLinkedRunPoint*  last_elem;
-
-    CvLinkedRunPoint*  upper_run = 0;
-    CvLinkedRunPoint*  lower_run = 0;
-    CvLinkedRunPoint*  prev_point = 0;
-
-    CvSeqWriter  writer_ext;
-    CvSeqWriter  writer_int;
-    CvSeqWriter  writer;
-    CvSeqReader  reader;
-
-    CvSeq* external_contours;
-    CvSeq* internal_contours;
-    CvSeq* prev = 0;
-
-    if( !storage )
-        CV_Error( CV_StsNullPtr, "NULL storage pointer" );
-
-    if( !result )
-        CV_Error( CV_StsNullPtr, "NULL double CvSeq pointer" );
-
-    if( contourHeaderSize < (int)sizeof(CvContour))
-        CV_Error( CV_StsBadSize, "Contour header size must be >= sizeof(CvContour)" );
-
-    storage00.reset(cvCreateChildMemStorage(storage));
-    storage01.reset(cvCreateChildMemStorage(storage));
-
-    CvMat stub, *mat;
-
-    mat = cvGetMat( src, &stub );
-    if( !CV_IS_MASK_ARR(mat))
-        CV_Error( CV_StsBadArg, "Input array must be 8uC1 or 8sC1" );
-    src_data = mat->data.ptr;
-    img_step = mat->step;
-    img_size = cvGetMatSize(mat);
-
-    // Create temporary sequences
-    runs = cvCreateSeq(0, sizeof(CvSeq), sizeof(CvLinkedRunPoint), storage00 );
-    cvStartAppendToSeq( runs, &writer );
-
-    cvStartWriteSeq( 0, sizeof(CvSeq), sizeof(CvLinkedRunPoint*), storage01, &writer_ext );
-    cvStartWriteSeq( 0, sizeof(CvSeq), sizeof(CvLinkedRunPoint*), storage01, &writer_int );
-
-    tmp_prev = &(tmp);
-    tmp_prev->next = 0;
-    tmp_prev->link = 0;
-
-    // First line. None of runs is binded
-    tmp.pt.x = 0;
-    tmp.pt.y = 0;
-    CV_WRITE_SEQ_ELEM( tmp, writer );
-    upper_line = (CvLinkedRunPoint*)CV_GET_WRITTEN_ELEM( writer );
-
-    tmp_prev = upper_line;
-    for( j = 0; j < img_size.width; )
-    {
-        j = findStartContourPoint(src_data, cvSize(img_size), j);
-
-        if( j == img_size.width )
-            break;
-
-        tmp.pt.x = j;
-        CV_WRITE_SEQ_ELEM( tmp, writer );
-        tmp_prev->next = (CvLinkedRunPoint*)CV_GET_WRITTEN_ELEM( writer );
-        tmp_prev = tmp_prev->next;
-
-        j = findEndContourPoint(src_data, cvSize(img_size), j + 1);
-
-        tmp.pt.x = j - 1;
-        CV_WRITE_SEQ_ELEM( tmp, writer );
-        tmp_prev->next = (CvLinkedRunPoint*)CV_GET_WRITTEN_ELEM( writer );
-        tmp_prev->link = tmp_prev->next;
-        // First point of contour
-        CV_WRITE_SEQ_ELEM( tmp_prev, writer_ext );
-        tmp_prev = tmp_prev->next;
-    }
-    cvFlushSeqWriter( &writer );
-    upper_line = upper_line->next;
-    upper_total = runs->total - 1;
-    last_elem = tmp_prev;
-    tmp_prev->next = 0;
-
-    for( int i = 1; i < img_size.height; i++ )
-    {
-//------// Find runs in next line
-        src_data += img_step;
-        tmp.pt.y = i;
-        all_total = runs->total;
-        for( j = 0; j < img_size.width; )
-        {
-            j = findStartContourPoint(src_data, cvSize(img_size), j);
-
-            if( j == img_size.width ) break;
-
-            tmp.pt.x = j;
-            CV_WRITE_SEQ_ELEM( tmp, writer );
-            tmp_prev->next = (CvLinkedRunPoint*)CV_GET_WRITTEN_ELEM( writer );
-            tmp_prev = tmp_prev->next;
-
-            j = findEndContourPoint(src_data, cvSize(img_size), j + 1);
-
-            tmp.pt.x = j - 1;
-            CV_WRITE_SEQ_ELEM( tmp, writer );
-            tmp_prev = tmp_prev->next = (CvLinkedRunPoint*)CV_GET_WRITTEN_ELEM( writer );
-        }//j
-        cvFlushSeqWriter( &writer );
-        lower_line = last_elem->next;
-        lower_total = runs->total - all_total;
-        last_elem = tmp_prev;
-        tmp_prev->next = 0;
-//------//
-//------// Find links between runs of lower_line and upper_line
-        upper_run = upper_line;
-        lower_run = lower_line;
-        connect_flag = ICV_SINGLE;
-
-        for( k = 0, n = 0; k < upper_total/2 && n < lower_total/2; )
-        {
-            switch( connect_flag )
-            {
-            case ICV_SINGLE:
-                if( upper_run->next->pt.x < lower_run->next->pt.x )
-                {
-                    if( upper_run->next->pt.x >= lower_run->pt.x  -1 )
-                    {
-                        lower_run->link = upper_run;
-                        connect_flag = ICV_CONNECTING_ABOVE;
-                        prev_point = upper_run->next;
-                    }
-                    else
-                        upper_run->next->link = upper_run;
-                    k++;
-                    upper_run = upper_run->next->next;
-                }
-                else
-                {
-                    if( upper_run->pt.x <= lower_run->next->pt.x  +1 )
-                    {
-                        lower_run->link = upper_run;
-                        connect_flag = ICV_CONNECTING_BELOW;
-                        prev_point = lower_run->next;
-                    }
-                    else
-                    {
-                        lower_run->link = lower_run->next;
-                        // First point of contour
-                        CV_WRITE_SEQ_ELEM( lower_run, writer_ext );
-                    }
-                    n++;
-                    lower_run = lower_run->next->next;
-                }
-                break;
-            case ICV_CONNECTING_ABOVE:
-                if( upper_run->pt.x > lower_run->next->pt.x +1 )
-                {
-                    prev_point->link = lower_run->next;
-                    connect_flag = ICV_SINGLE;
-                    n++;
-                    lower_run = lower_run->next->next;
-                }
-                else
-                {
-                    prev_point->link = upper_run;
-                    if( upper_run->next->pt.x < lower_run->next->pt.x )
-                    {
-                        k++;
-                        prev_point = upper_run->next;
-                        upper_run = upper_run->next->next;
-                    }
-                    else
-                    {
-                        connect_flag = ICV_CONNECTING_BELOW;
-                        prev_point = lower_run->next;
-                        n++;
-                        lower_run = lower_run->next->next;
-                    }
-                }
-                break;
-            case ICV_CONNECTING_BELOW:
-                if( lower_run->pt.x > upper_run->next->pt.x +1 )
-                {
-                    upper_run->next->link = prev_point;
-                    connect_flag = ICV_SINGLE;
-                    k++;
-                    upper_run = upper_run->next->next;
-                }
-                else
-                {
-                    // First point of contour
-                    CV_WRITE_SEQ_ELEM( lower_run, writer_int );
-
-                    lower_run->link = prev_point;
-                    if( lower_run->next->pt.x < upper_run->next->pt.x )
-                    {
-                        n++;
-                        prev_point = lower_run->next;
-                        lower_run = lower_run->next->next;
-                    }
-                    else
-                    {
-                        connect_flag = ICV_CONNECTING_ABOVE;
-                        k++;
-                        prev_point = upper_run->next;
-                        upper_run = upper_run->next->next;
-                    }
-                }
-                break;
-            }
-        }// k, n
-
-        for( ; n < lower_total/2; n++ )
-        {
-            if( connect_flag != ICV_SINGLE )
-            {
-                prev_point->link = lower_run->next;
-                connect_flag = ICV_SINGLE;
-                lower_run = lower_run->next->next;
-                continue;
-            }
-            lower_run->link = lower_run->next;
-
-            //First point of contour
-            CV_WRITE_SEQ_ELEM( lower_run, writer_ext );
-
-            lower_run = lower_run->next->next;
-        }
-
-        for( ; k < upper_total/2; k++ )
-        {
-            if( connect_flag != ICV_SINGLE )
-            {
-                upper_run->next->link = prev_point;
-                connect_flag = ICV_SINGLE;
-                upper_run = upper_run->next->next;
-                continue;
-            }
-            upper_run->next->link = upper_run;
-            upper_run = upper_run->next->next;
-        }
-        upper_line = lower_line;
-        upper_total = lower_total;
-    }//i
-
-    upper_run = upper_line;
-
-    //the last line of image
-    for( k = 0; k < upper_total/2; k++ )
-    {
-        upper_run->next->link = upper_run;
-        upper_run = upper_run->next->next;
-    }
-
-//------//
-//------//Find end read contours
-    external_contours = cvEndWriteSeq( &writer_ext );
-    internal_contours = cvEndWriteSeq( &writer_int );
-
-    for( k = 0; k < 2; k++ )
-    {
-        CvSeq* contours = k == 0 ? external_contours : internal_contours;
-
-        cvStartReadSeq( contours, &reader );
-
-        for( j = 0; j < contours->total; j++, count++ )
-        {
-            CvLinkedRunPoint* p_temp;
-            CvLinkedRunPoint* p00;
-            CvLinkedRunPoint* p01;
-            CvSeq* contour;
-
-            CV_READ_SEQ_ELEM( p00, reader );
-            p01 = p00;
-
-            if( !p00->link )
-                continue;
-
-            cvStartWriteSeq( CV_SEQ_ELTYPE_POINT | CV_SEQ_POLYLINE | CV_SEQ_FLAG_CLOSED,
-                             contourHeaderSize, sizeof(CvPoint), storage, &writer );
-            do
-            {
-                CV_WRITE_SEQ_ELEM( p00->pt, writer );
-                p_temp = p00;
-                p00 = p00->link;
-                p_temp->link = 0;
-            }
-            while( p00 != p01 );
-
-            contour = cvEndWriteSeq( &writer );
-            cvBoundingRect( contour, 1 );
-
-            if( k != 0 )
-                contour->flags |= CV_SEQ_FLAG_HOLE;
-
-            if( !first )
-                prev = first = contour;
-            else
-            {
-                contour->h_prev = prev;
-                prev = prev->h_next = contour;
-            }
-        }
-    }
-
-    if( !first )
-        count = -1;
-
-    if( result )
-        *result = first;
-
-    return count;
-}
-
-static int
-cvFindContours_Impl( void*  img,  CvMemStorage*  storage,
-                CvSeq**  firstContour, int  cntHeaderSize,
-                int  mode,
-                int  method, CvPoint offset, int needFillBorder )
-{
-    CvContourScanner scanner = 0;
-    CvSeq *contour = 0;
-    int count = -1;
-
-    if( !firstContour )
-        CV_Error( CV_StsNullPtr, "NULL double CvSeq pointer" );
-
-    *firstContour = 0;
-
-    if( method == CV_LINK_RUNS )
-    {
-        if( offset.x != 0 || offset.y != 0 )
-            CV_Error( CV_StsOutOfRange,
-            "Nonzero offset is not supported in CV_LINK_RUNS yet" );
-
-        count = icvFindContoursInInterval( img, storage, firstContour, cntHeaderSize );
-    }
-    else
-    {
-        try
-        {
-            scanner = cvStartFindContours_Impl( img, storage, cntHeaderSize, mode, method, offset,
-                                            needFillBorder);
-
-            do
-            {
-                count++;
-                contour = cvFindNextContour( scanner );
-            }
-            while( contour != 0 );
-        }
-        catch(...)
-        {
-            if( scanner )
-                cvEndFindContours(&scanner);
-            throw;
-        }
-
-        *firstContour = cvEndFindContours( &scanner );
-    }
-
-    return count;
-}
-
-/*F///////////////////////////////////////////////////////////////////////////////////////
-//    Name: cvFindContours
-//    Purpose:
-//      Finds all the contours on the bi-level image.
-//    Context:
-//    Parameters:
-//      img  - source image.
-//             Non-zero pixels are considered as 1-pixels
-//             and zero pixels as 0-pixels.
-//      step - full width of source image in bytes.
-//      size - width and height of the image in pixels
-//      storage - pointer to storage where will the output contours be placed.
-//      header_size - header size of resulting contours
-//      mode - mode of contour retrieval.
-//      method - method of approximation that is applied to contours
-//      first_contour - pointer to first contour pointer
-//    Returns:
-//      CV_OK or error code
-//    Notes:
-//F*/
-CV_IMPL int
-cvFindContours( void*  img,  CvMemStorage*  storage,
-                CvSeq**  firstContour, int  cntHeaderSize,
-                int  mode,
-                int  method, CvPoint offset )
-{
-    return cvFindContours_Impl(img, storage, firstContour, cntHeaderSize, mode, method, offset, 1);
-}
-
-void cv::findContours( InputArray _image, OutputArrayOfArrays _contours,
-                   OutputArray _hierarchy, int mode, int method, Point offset )
-{
-    CV_INSTRUMENT_REGION();
-
-    // Sanity check: output must be of type vector<vector<Point>>
-    CV_Assert((_contours.kind() == _InputArray::STD_VECTOR_VECTOR || _contours.kind() == _InputArray::STD_VECTOR_MAT ||
-                _contours.kind() == _InputArray::STD_VECTOR_UMAT));
-
-    CV_Assert(_contours.empty() || (_contours.channels() == 2 && _contours.depth() == CV_32S));
-
-    Mat image0 = _image.getMat(), image;
-    Point offset0(0, 0);
-    if(method != CV_LINK_RUNS)
-    {
-        offset0 = Point(-1, -1);
-        copyMakeBorder(image0, image, 1, 1, 1, 1, BORDER_CONSTANT | BORDER_ISOLATED, Scalar(0));
-    }
-    else
-    {
-        image = image0;
-    }
-    MemStorage storage(cvCreateMemStorage());
-    CvMat _cimage = cvMat(image);
-    CvSeq* _ccontours = 0;
-    if( _hierarchy.needed() )
-        _hierarchy.clear();
-    cvFindContours_Impl(&_cimage, storage, &_ccontours, sizeof(CvContour), mode, method, cvPoint(offset0 + offset), 0);
-    if( !_ccontours )
-    {
-        _contours.clear();
-        return;
-    }
-    Seq<CvSeq*> all_contours(cvTreeToNodeSeq( _ccontours, sizeof(CvSeq), storage ));
-    int i, total = (int)all_contours.size();
-    _contours.create(total, 1, 0, -1, true);
-    SeqIterator<CvSeq*> it = all_contours.begin();
-    for( i = 0; i < total; i++, ++it )
-    {
-        CvSeq* c = *it;
-        ((CvContour*)c)->color = (int)i;
-        _contours.create((int)c->total, 1, CV_32SC2, i, true);
-        Mat ci = _contours.getMat(i);
-        CV_Assert( ci.isContinuous() );
-        cvCvtSeqToArray(c, ci.ptr());
-    }
-
-    if( _hierarchy.needed() )
-    {
-        _hierarchy.create(1, total, CV_32SC4, -1, true);
-        Vec4i* hierarchy = _hierarchy.getMat().ptr<Vec4i>();
-
-        it = all_contours.begin();
-        for( i = 0; i < total; i++, ++it )
-        {
-            CvSeq* c = *it;
-            int h_next = c->h_next ? ((CvContour*)c->h_next)->color : -1;
-            int h_prev = c->h_prev ? ((CvContour*)c->h_prev)->color : -1;
-            int v_next = c->v_next ? ((CvContour*)c->v_next)->color : -1;
-            int v_prev = c->v_prev ? ((CvContour*)c->v_prev)->color : -1;
-            hierarchy[i] = Vec4i(h_next, h_prev, v_next, v_prev);
-        }
-    }
-}
-
-void cv::findContours( InputArray _image, OutputArrayOfArrays _contours,
-                       int mode, int method, Point offset)
-{
-    CV_INSTRUMENT_REGION();
-
-    findContours(_image, _contours, noArray(), mode, method, offset);
-}
-
-/* End of file. */
diff --git a/modules/imgproc/src/resize.cpp b/modules/imgproc/src/resize.cpp
index 4f82bddfa0..c234fd6bdd 100644
--- a/modules/imgproc/src/resize.cpp
+++ b/modules/imgproc/src/resize.cpp
@@ -3671,6 +3671,8 @@ void resize(int src_type,
             uchar * dst_data, size_t dst_step, int dst_width, int dst_height,
             double inv_scale_x, double inv_scale_y, int interpolation)
 {
+    // mashplant: resize
+    interpolation = INTER_LINEAR;
     CV_INSTRUMENT_REGION();
 
     CV_Assert((dst_width > 0 && dst_height > 0) || (inv_scale_x > 0 && inv_scale_y > 0));
@@ -4084,7 +4086,6 @@ void cv::resize( InputArray _src, OutputArray _dst, Size dsize,
         src.copyTo(dst);
         return;
     }
-
     hal::resize(src.type(), src.data, src.step, src.cols, src.rows, dst.data, dst.step, dst.cols, dst.rows, inv_scale_x, inv_scale_y, interpolation);
 }
 
diff --git a/modules/imgproc/src/templmatch.cpp b/modules/imgproc/src/templmatch.cpp
index 7e34832fe5..168813d968 100644
--- a/modules/imgproc/src/templmatch.cpp
+++ b/modules/imgproc/src/templmatch.cpp
@@ -905,6 +905,7 @@ static void matchTemplateMask( InputArray _img, InputArray _templ, OutputArray _
 
 static void common_matchTemplate( Mat& img, Mat& templ, Mat& result, int method, int cn )
 {
+    method = TM_CCORR_NORMED;
     if( method == CV_TM_CCORR )
         return;
 
@@ -1162,7 +1163,9 @@ void cv::matchTemplate( InputArray _img, InputArray _templ, OutputArray _result,
     CV_Assert( CV_TM_SQDIFF <= method && method <= CV_TM_CCOEFF_NORMED );
     CV_Assert( (depth == CV_8U || depth == CV_32F) && type == _templ.type() && _img.dims() <= 2 );
 
-    if (!_mask.empty())
+    // mashplant: matchTemplate
+    // if (!_mask.empty())
+    if (false)
     {
         cv::matchTemplateMask(_img, _templ, _result, method, _mask);
         return;
diff --git a/modules/videoio/src/backend_plugin.cpp b/modules/videoio/src/backend_plugin.cpp
index 92c18e8e7b..f3439e00e5 100644
--- a/modules/videoio/src/backend_plugin.cpp
+++ b/modules/videoio/src/backend_plugin.cpp
@@ -274,14 +274,15 @@ protected:
     void initBackend()
     {
         AutoLock lock(getInitializationMutex());
-        try {
+        // mashplant:
+        // try {
             if (!initialized)
                 loadPlugin();
-        }
-        catch (...)
-        {
-            CV_LOG_INFO(NULL, "Video I/O: exception during plugin loading: " << baseName_ << ". SKIP");
-        }
+        // }
+        // catch (...)
+        // {
+        //     CV_LOG_INFO(NULL, "Video I/O: exception during plugin loading: " << baseName_ << ". SKIP");
+        // }
         initialized = true;
     }
     void loadPlugin();
@@ -378,8 +379,9 @@ void PluginBackendFactory::loadPlugin()
         Ptr<DynamicLib> lib = makePtr<DynamicLib>(plugin);
         if (!lib->isLoaded())
             continue;
-        try
-        {
+        // mashplant:
+        // try
+        // {
             Ptr<PluginBackend> pluginBackend = makePtr<PluginBackend>(lib);
             if (pluginBackend && pluginBackend->plugin_api_)
             {
@@ -395,11 +397,11 @@ void PluginBackendFactory::loadPlugin()
                     return;
                 }
             }
-        }
-        catch (...)
-        {
-            CV_LOG_WARNING(NULL, "Video I/O: exception during plugin initialization: " << toPrintablePath(plugin) << ". SKIP");
-        }
+        // }
+        // catch (...)
+        // {
+        //     CV_LOG_WARNING(NULL, "Video I/O: exception during plugin initialization: " << toPrintablePath(plugin) << ". SKIP");
+        // }
     }
 }
 
@@ -574,44 +576,47 @@ public:
 
 Ptr<IVideoCapture> PluginBackend::createCapture(int camera) const
 {
-    try
-    {
+    // mashplant:
+    // try
+    // {
         if (plugin_api_)
             return PluginCapture::create(plugin_api_, std::string(), camera); //.staticCast<IVideoCapture>();
-    }
-    catch (...)
-    {
-        CV_LOG_DEBUG(NULL, "Video I/O: can't create camera capture: " << camera);
-    }
+    // }
+    // catch (...)
+    // {
+    //     CV_LOG_DEBUG(NULL, "Video I/O: can't create camera capture: " << camera);
+    // }
     return Ptr<IVideoCapture>();
 }
 
 Ptr<IVideoCapture> PluginBackend::createCapture(const std::string &filename) const
 {
-    try
-    {
+    // mashplant:
+    // try
+    // {
         if (plugin_api_)
             return PluginCapture::create(plugin_api_, filename, 0); //.staticCast<IVideoCapture>();
-    }
-    catch (...)
-    {
-        CV_LOG_DEBUG(NULL, "Video I/O: can't open file capture: " << filename);
-    }
+    // }
+    // catch (...)
+    // {
+    //     CV_LOG_DEBUG(NULL, "Video I/O: can't open file capture: " << filename);
+    // }
     return Ptr<IVideoCapture>();
 }
 
 Ptr<IVideoWriter> PluginBackend::createWriter(const std::string& filename, int fourcc, double fps,
                                               const cv::Size& sz, const VideoWriterParameters& params) const
 {
-    try
-    {
+    // mashplant:
+    // try
+    // {
         if (plugin_api_)
             return PluginWriter::create(plugin_api_, filename, fourcc, fps, sz, params); //.staticCast<IVideoWriter>();
-    }
-    catch (...)
-    {
-        CV_LOG_DEBUG(NULL, "Video I/O: can't open writer: " << filename);
-    }
+    // }
+    // catch (...)
+    // {
+    //     CV_LOG_DEBUG(NULL, "Video I/O: can't open writer: " << filename);
+    // }
     return Ptr<IVideoWriter>();
 }
 
diff --git a/modules/videoio/src/cap.cpp b/modules/videoio/src/cap.cpp
index 77a2c3671e..da9ace0f80 100644
--- a/modules/videoio/src/cap.cpp
+++ b/modules/videoio/src/cap.cpp
@@ -110,8 +110,9 @@ bool VideoCapture::open(const String& filename, int apiPreference)
             const Ptr<IBackend> backend = info.backendFactory->getBackend();
             if (!backend.empty())
             {
-                try
-                {
+                // mashplant:
+                // try
+                // {
                     icap = backend->createCapture(filename);
                     if (!icap.empty())
                     {
@@ -130,36 +131,36 @@ bool VideoCapture::open(const String& filename, int apiPreference)
                                              cv::format("VIDEOIO(%s): can't create capture",
                                                         info.name));
                     }
-                }
-                catch (const cv::Exception& e)
-                {
-                    if (throwOnFail && apiPreference != CAP_ANY)
-                    {
-                        throw;
-                    }
-                    CV_LOG_ERROR(NULL,
-                                 cv::format("VIDEOIO(%s): raised OpenCV exception:\n\n%s\n",
-                                            info.name, e.what()));
-                }
-                catch (const std::exception& e)
-                {
-                    if (throwOnFail && apiPreference != CAP_ANY)
-                    {
-                        throw;
-                    }
-                    CV_LOG_ERROR(NULL, cv::format("VIDEOIO(%s): raised C++ exception:\n\n%s\n",
-                                                  info.name, e.what()));
-                }
-                catch (...)
-                {
-                    if (throwOnFail && apiPreference != CAP_ANY)
-                    {
-                        throw;
-                    }
-                    CV_LOG_ERROR(NULL,
-                                 cv::format("VIDEOIO(%s): raised unknown C++ exception!\n\n",
-                                            info.name));
-                }
+                // }
+                // catch (const cv::Exception& e)
+                // {
+                //     if (throwOnFail && apiPreference != CAP_ANY)
+                //     {
+                //         throw;
+                //     }
+                //     CV_LOG_ERROR(NULL,
+                //                  cv::format("VIDEOIO(%s): raised OpenCV exception:\n\n%s\n",
+                //                             info.name, e.what()));
+                // }
+                // catch (const std::exception& e)
+                // {
+                //     if (throwOnFail && apiPreference != CAP_ANY)
+                //     {
+                //         throw;
+                //     }
+                //     CV_LOG_ERROR(NULL, cv::format("VIDEOIO(%s): raised C++ exception:\n\n%s\n",
+                //                                   info.name, e.what()));
+                // }
+                // catch (...)
+                // {
+                //     if (throwOnFail && apiPreference != CAP_ANY)
+                //     {
+                //         throw;
+                //     }
+                //     CV_LOG_ERROR(NULL,
+                //                  cv::format("VIDEOIO(%s): raised unknown C++ exception!\n\n",
+                //                             info.name));
+                // }
             }
             else
             {
@@ -214,8 +215,9 @@ bool VideoCapture::open(int cameraNum, int apiPreference)
             const Ptr<IBackend> backend = info.backendFactory->getBackend();
             if (!backend.empty())
             {
-                try
-                {
+                // mashplant:
+                // try
+                // {
                     icap = backend->createCapture(cameraNum);
                     if (!icap.empty())
                     {
@@ -234,36 +236,36 @@ bool VideoCapture::open(int cameraNum, int apiPreference)
                                              cv::format("VIDEOIO(%s): can't create capture",
                                                         info.name));
                     }
-                }
-                catch (const cv::Exception& e)
-                {
-                    if (throwOnFail && apiPreference != CAP_ANY)
-                    {
-                        throw;
-                    }
-                    CV_LOG_ERROR(NULL,
-                                 cv::format("VIDEOIO(%s): raised OpenCV exception:\n\n%s\n",
-                                            info.name, e.what()));
-                }
-                catch (const std::exception& e)
-                {
-                    if (throwOnFail && apiPreference != CAP_ANY)
-                    {
-                        throw;
-                    }
-                    CV_LOG_ERROR(NULL, cv::format("VIDEOIO(%s): raised C++ exception:\n\n%s\n",
-                                                  info.name, e.what()));
-                }
-                catch (...)
-                {
-                    if (throwOnFail && apiPreference != CAP_ANY)
-                    {
-                        throw;
-                    }
-                    CV_LOG_ERROR(NULL,
-                                 cv::format("VIDEOIO(%s): raised unknown C++ exception!\n\n",
-                                            info.name));
-                }
+                // }
+                // catch (const cv::Exception& e)
+                // {
+                //     if (throwOnFail && apiPreference != CAP_ANY)
+                //     {
+                //         throw;
+                //     }
+                //     CV_LOG_ERROR(NULL,
+                //                  cv::format("VIDEOIO(%s): raised OpenCV exception:\n\n%s\n",
+                //                             info.name, e.what()));
+                // }
+                // catch (const std::exception& e)
+                // {
+                //     if (throwOnFail && apiPreference != CAP_ANY)
+                //     {
+                //         throw;
+                //     }
+                //     CV_LOG_ERROR(NULL, cv::format("VIDEOIO(%s): raised C++ exception:\n\n%s\n",
+                //                                   info.name, e.what()));
+                // }
+                // catch (...)
+                // {
+                //     if (throwOnFail && apiPreference != CAP_ANY)
+                //     {
+                //         throw;
+                //     }
+                //     CV_LOG_ERROR(NULL,
+                //                  cv::format("VIDEOIO(%s): raised unknown C++ exception!\n\n",
+                //                             info.name));
+                // }
             }
             else
             {
@@ -526,8 +528,9 @@ bool VideoWriter::open(const String& filename, int apiPreference, int fourcc, do
             const Ptr<IBackend> backend = info.backendFactory->getBackend();
             if (!backend.empty())
             {
-                try
-                {
+                // mashplant:
+                // try
+                // {
                     iwriter = backend->createWriter(filename, fourcc, fps, frameSize, parameters);
                     if (!iwriter.empty())
                     {
@@ -555,24 +558,24 @@ bool VideoWriter::open(const String& filename, int apiPreference, int fourcc, do
                         CV_WRITER_LOG_DEBUG(NULL, cv::format("VIDEOIO(%s): can't create writer",
                                                              info.name));
                     }
-                }
-                catch (const cv::Exception& e)
-                {
-                    CV_LOG_ERROR(NULL,
-                                 cv::format("VIDEOIO(%s): raised OpenCV exception:\n\n%s\n",
-                                            info.name, e.what()));
-                }
-                catch (const std::exception& e)
-                {
-                    CV_LOG_ERROR(NULL, cv::format("VIDEOIO(%s): raised C++ exception:\n\n%s\n",
-                                                  info.name, e.what()));
-                }
-                catch (...)
-                {
-                    CV_LOG_ERROR(NULL,
-                                 cv::format("VIDEOIO(%s): raised unknown C++ exception!\n\n",
-                                            info.name));
-                }
+                // }
+                // catch (const cv::Exception& e)
+                // {
+                //     CV_LOG_ERROR(NULL,
+                //                  cv::format("VIDEOIO(%s): raised OpenCV exception:\n\n%s\n",
+                //                             info.name, e.what()));
+                // }
+                // catch (const std::exception& e)
+                // {
+                //     CV_LOG_ERROR(NULL, cv::format("VIDEOIO(%s): raised C++ exception:\n\n%s\n",
+                //                                   info.name, e.what()));
+                // }
+                // catch (...)
+                // {
+                //     CV_LOG_ERROR(NULL,
+                //                  cv::format("VIDEOIO(%s): raised unknown C++ exception!\n\n",
+                //                             info.name));
+                // }
             }
             else
             {
diff --git a/modules/videoio/src/cap_images.cpp b/modules/videoio/src/cap_images.cpp
index b506dd1c06..c93e24cdbf 100644
--- a/modules/videoio/src/cap_images.cpp
+++ b/modules/videoio/src/cap_images.cpp
@@ -348,103 +348,104 @@ Ptr<IVideoCapture> create_Images_capture(const std::string &filename)
 // image sequence writer
 //
 //
-class CvVideoWriter_Images CV_FINAL : public CvVideoWriter
-{
-public:
-    CvVideoWriter_Images()
-    {
-        filename_pattern.clear();
-        currentframe = 0;
-    }
-    virtual ~CvVideoWriter_Images() { close(); }
-
-    virtual bool open( const char* _filename );
-    virtual void close();
-    virtual bool setProperty( int, double ); // FIXIT doesn't work: IVideoWriter interface only!
-    virtual bool writeFrame( const IplImage* ) CV_OVERRIDE;
-
-    int getCaptureDomain() const CV_OVERRIDE { return cv::CAP_IMAGES; }
-protected:
-    std::string filename_pattern;
-    unsigned currentframe;
-    std::vector<int> params;
-};
-
-bool CvVideoWriter_Images::writeFrame( const IplImage* image )
-{
-    CV_Assert(!filename_pattern.empty());
-    cv::String filename = cv::format(filename_pattern.c_str(), (int)currentframe);
-    CV_Assert(!filename.empty());
-
-    std::vector<int> image_params = params;
-    image_params.push_back(0); // append parameters 'stop' mark
-    image_params.push_back(0);
-
-    cv::Mat img = cv::cvarrToMat(image);
-    bool ret = cv::imwrite(filename, img, image_params);
-
-    currentframe++;
-
-    return ret;
-}
-
-void CvVideoWriter_Images::close()
-{
-    filename_pattern.clear();
-    currentframe = 0;
-    params.clear();
-}
-
-
-bool CvVideoWriter_Images::open( const char* _filename )
-{
-    unsigned offset = 0;
-    close();
-
-    CV_Assert(_filename);
-    filename_pattern = icvExtractPattern(_filename, &offset);
-    CV_Assert(!filename_pattern.empty());
-
-    cv::String filename = cv::format(filename_pattern.c_str(), (int)currentframe);
-    if (!cv::haveImageWriter(filename))
-    {
-        close();
-        return false;
-    }
-
-    currentframe = offset;
-    params.clear();
-    return true;
-}
-
-
-bool CvVideoWriter_Images::setProperty( int id, double value )
-{
-    if (id >= cv::CAP_PROP_IMAGES_BASE && id < cv::CAP_PROP_IMAGES_LAST)
-    {
-        params.push_back( id - cv::CAP_PROP_IMAGES_BASE );
-        params.push_back( static_cast<int>( value ) );
-        return true;
-    }
-    return false; // not supported
-}
+// mashplant:
+// class CvVideoWriter_Images CV_FINAL : public CvVideoWriter
+// {
+// public:
+//     CvVideoWriter_Images()
+//     {
+//         filename_pattern.clear();
+//         currentframe = 0;
+//     }
+//     virtual ~CvVideoWriter_Images() { close(); }
+
+//     virtual bool open( const char* _filename );
+//     virtual void close();
+//     virtual bool setProperty( int, double ); // FIXIT doesn't work: IVideoWriter interface only!
+//     virtual bool writeFrame( const IplImage* ) CV_OVERRIDE;
+
+//     int getCaptureDomain() const CV_OVERRIDE { return cv::CAP_IMAGES; }
+// protected:
+//     std::string filename_pattern;
+//     unsigned currentframe;
+//     std::vector<int> params;
+// };
+
+// bool CvVideoWriter_Images::writeFrame( const IplImage* image )
+// {
+//     CV_Assert(!filename_pattern.empty());
+//     cv::String filename = cv::format(filename_pattern.c_str(), (int)currentframe);
+//     CV_Assert(!filename.empty());
+
+//     std::vector<int> image_params = params;
+//     image_params.push_back(0); // append parameters 'stop' mark
+//     image_params.push_back(0);
+
+//     cv::Mat img = cv::cvarrToMat(image);
+//     bool ret = cv::imwrite(filename, img, image_params);
+
+//     currentframe++;
+
+//     return ret;
+// }
+
+// void CvVideoWriter_Images::close()
+// {
+//     filename_pattern.clear();
+//     currentframe = 0;
+//     params.clear();
+// }
+
+
+// bool CvVideoWriter_Images::open( const char* _filename )
+// {
+//     unsigned offset = 0;
+//     close();
+
+//     CV_Assert(_filename);
+//     filename_pattern = icvExtractPattern(_filename, &offset);
+//     CV_Assert(!filename_pattern.empty());
+
+//     cv::String filename = cv::format(filename_pattern.c_str(), (int)currentframe);
+//     if (!cv::haveImageWriter(filename))
+//     {
+//         close();
+//         return false;
+//     }
+
+//     currentframe = offset;
+//     params.clear();
+//     return true;
+// }
+
+
+// bool CvVideoWriter_Images::setProperty( int id, double value )
+// {
+//     if (id >= cv::CAP_PROP_IMAGES_BASE && id < cv::CAP_PROP_IMAGES_LAST)
+//     {
+//         params.push_back( id - cv::CAP_PROP_IMAGES_BASE );
+//         params.push_back( static_cast<int>( value ) );
+//         return true;
+//     }
+//     return false; // not supported
+// }
 
 Ptr<IVideoWriter> create_Images_writer(const std::string &filename, int, double, const Size &,
     const cv::VideoWriterParameters&)
 {
-    CvVideoWriter_Images *writer = new CvVideoWriter_Images;
-
-    try
-    {
-        if( writer->open( filename.c_str() ))
-            return makePtr<LegacyWriter>(writer);
-        delete writer;
-    }
-    catch (...)
-    {
-        delete writer;
-        throw;
-    }
+    // CvVideoWriter_Images *writer = new CvVideoWriter_Images;
+
+    // try
+    // {
+    //     if( writer->open( filename.c_str() ))
+    //         return makePtr<LegacyWriter>(writer);
+    //     delete writer;
+    // }
+    // catch (...)
+    // {
+    //     delete writer;
+    //     throw;
+    // }
 
     return 0;
 }
diff --git a/modules/videoio/src/cap_v4l.cpp b/modules/videoio/src/cap_v4l.cpp
index 3f37a97b92..49a59f1339 100644
--- a/modules/videoio/src/cap_v4l.cpp
+++ b/modules/videoio/src/cap_v4l.cpp
@@ -435,16 +435,17 @@ CvCaptureCAM_V4L::CvCaptureCAM_V4L() :
 
 CvCaptureCAM_V4L::~CvCaptureCAM_V4L()
 {
-    try
-    {
+    // mashplant:
+    // try
+    // {
         closeDevice();
-    }
-    catch (...)
-    {
-        CV_LOG_WARNING(NULL, "VIDEOIO(V4L2): unable properly close device: " << deviceName);
-        if (deviceHandle != -1)
-            close(deviceHandle);
-    }
+    // }
+    // catch (...)
+    // {
+    //     CV_LOG_WARNING(NULL, "VIDEOIO(V4L2): unable properly close device: " << deviceName);
+    //     if (deviceHandle != -1)
+    //         close(deviceHandle);
+    // }
 }
 
 void CvCaptureCAM_V4L::closeDevice()
@@ -2227,12 +2228,12 @@ bool VideoCapture_V4L_waitAny(const std::vector<VideoCapture>& streams, CV_OUT s
     for (size_t i = 0; i < N; ++i)
     {
         IVideoCapture* iCap = internal::VideoCapturePrivateAccessor::getIVideoCapture(streams[i]);
-        LegacyCapture* legacyCapture = dynamic_cast<LegacyCapture*>(iCap);
+        LegacyCapture* legacyCapture = static_cast<LegacyCapture*>(iCap); // mashplant: dynamic_cast->static_cast
         CV_Assert(legacyCapture);
         CvCapture* cvCap = legacyCapture->getCvCapture();
         CV_Assert(cvCap);
 
-        CvCaptureCAM_V4L *ptr_CvCaptureCAM_V4L = dynamic_cast<CvCaptureCAM_V4L*>(cvCap);
+        CvCaptureCAM_V4L *ptr_CvCaptureCAM_V4L = static_cast<CvCaptureCAM_V4L*>(cvCap); // mashplant: dynamic_cast->static_cast
         CV_Assert(ptr_CvCaptureCAM_V4L);
         capPtr[i] = ptr_CvCaptureCAM_V4L;
     }
diff --git a/modules/videoio/src/container_avi.cpp b/modules/videoio/src/container_avi.cpp
index 2fb2ee14f8..376703ca23 100644
--- a/modules/videoio/src/container_avi.cpp
+++ b/modules/videoio/src/container_avi.cpp
@@ -22,7 +22,9 @@ inline D safe_int_cast(S val, const char * msg = 0)
     if (!in_range_r || !in_range_l)
     {
         if (!msg)
-            CV_Error_(Error::StsOutOfRange, ("Can not convert integer values (%s -> %s), value 0x%jx is out of range", typeid(S).name(), typeid(D).name(), (uintmax_t)val));
+            // mashplant:
+            // CV_Error_(Error::StsOutOfRange, ("Can not convert integer values (%s -> %s), value 0x%jx is out of range", typeid(S).name(), typeid(D).name(), (uintmax_t)val));
+            CV_Error_(Error::StsOutOfRange, ("Can not convert integer values, value 0x%jx is out of range", (uintmax_t)val));
         else
             CV_Error(Error::StsOutOfRange, msg);
     }
diff --git a/platforms/linux/arm-musleabi.toolchain.cmake b/platforms/linux/arm-musleabi.toolchain.cmake
new file mode 100644
index 0000000000..6e5b066cf0
--- /dev/null
+++ b/platforms/linux/arm-musleabi.toolchain.cmake
@@ -0,0 +1,101 @@
+set(GCC_COMPILER_VERSION "" CACHE STRING "GCC Compiler version")
+set(GNU_MACHINE "arm-linux-musleabi" CACHE STRING "MUSL compiler triple")
+include("${CMAKE_CURRENT_LIST_DIR}/arm.toolchain.cmake")
+
+if(COMMAND toolchain_save_config)
+  return() # prevent recursive call
+endif()
+
+set(CMAKE_SYSTEM_NAME Linux)
+set(CMAKE_SYSTEM_VERSION 1)
+if(NOT DEFINED CMAKE_SYSTEM_PROCESSOR)
+  set(CMAKE_SYSTEM_PROCESSOR arm)
+else()
+  #message("CMAKE_SYSTEM_PROCESSOR=${CMAKE_SYSTEM_PROCESSOR}")
+endif()
+
+include("${CMAKE_CURRENT_LIST_DIR}/gnu.toolchain.cmake")
+
+if(CMAKE_SYSTEM_PROCESSOR STREQUAL arm AND NOT ARM_IGNORE_FP)
+  set(FLOAT_ABI_SUFFIX "")
+  if(NOT SOFTFP)
+    set(FLOAT_ABI_SUFFIX "hf")
+  endif()
+endif()
+
+if(NOT "x${GCC_COMPILER_VERSION}" STREQUAL "x")
+  set(__GCC_VER_SUFFIX "-${GCC_COMPILER_VERSION}")
+endif()
+
+if(NOT DEFINED CMAKE_C_COMPILER)
+  find_program(CMAKE_C_COMPILER NAMES ${GNU_MACHINE}${FLOAT_ABI_SUFFIX}-gcc${__GCC_VER_SUFFIX})
+else()
+  #message(WARNING "CMAKE_C_COMPILER=${CMAKE_C_COMPILER} is defined")
+endif()
+if(NOT DEFINED CMAKE_CXX_COMPILER)
+  find_program(CMAKE_CXX_COMPILER NAMES ${GNU_MACHINE}${FLOAT_ABI_SUFFIX}-g++${__GCC_VER_SUFFIX})
+else()
+  #message(WARNING "CMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER} is defined")
+endif()
+if(NOT DEFINED CMAKE_LINKER)
+  find_program(CMAKE_LINKER NAMES ${GNU_MACHINE}${FLOAT_ABI_SUFFIX}-ld${__GCC_VER_SUFFIX} ${GNU_MACHINE}${FLOAT_ABI_SUFFIX}-ld)
+else()
+  #message(WARNING "CMAKE_LINKER=${CMAKE_LINKER} is defined")
+endif()
+if(NOT DEFINED CMAKE_AR)
+  find_program(CMAKE_AR NAMES ${GNU_MACHINE}${FLOAT_ABI_SUFFIX}-ar${__GCC_VER_SUFFIX} ${GNU_MACHINE}${FLOAT_ABI_SUFFIX}-ar)
+else()
+  #message(WARNING "CMAKE_AR=${CMAKE_AR} is defined")
+endif()
+
+if(NOT DEFINED ARM_LINUX_SYSROOT AND DEFINED GNU_MACHINE)
+  set(ARM_LINUX_SYSROOT /usr/${GNU_MACHINE}${FLOAT_ABI_SUFFIX})
+endif()
+
+if(NOT DEFINED CMAKE_CXX_FLAGS)
+  set(CMAKE_CXX_FLAGS           "" CACHE INTERNAL "")
+  set(CMAKE_C_FLAGS             "" CACHE INTERNAL "")
+  set(CMAKE_SHARED_LINKER_FLAGS "" CACHE INTERNAL "")
+  set(CMAKE_MODULE_LINKER_FLAGS "" CACHE INTERNAL "")
+  set(CMAKE_EXE_LINKER_FLAGS    "" CACHE INTERNAL "")
+
+  set(CMAKE_CXX_FLAGS           "${CMAKE_CXX_FLAGS} -fdata-sections -Wa,--noexecstack -fsigned-char -Wno-psabi")
+  set(CMAKE_C_FLAGS             "${CMAKE_C_FLAGS} -fdata-sections -Wa,--noexecstack -fsigned-char -Wno-psabi")
+  if(CMAKE_SYSTEM_PROCESSOR STREQUAL arm)
+    set(CMAKE_CXX_FLAGS           "${CMAKE_CXX_FLAGS}")
+    set(CMAKE_C_FLAGS             "${CMAKE_C_FLAGS}")
+    set(CMAKE_EXE_LINKER_FLAGS    "${CMAKE_EXE_LINKER_FLAGS} -Wl,-z,nocopyreloc")
+  endif()
+  if(CMAKE_SYSTEM_PROCESSOR STREQUAL arm)
+    set(ARM_LINKER_FLAGS "-Wl,--fix-cortex-a8 -Wl,--no-undefined -Wl,--gc-sections -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now")
+  elseif(CMAKE_SYSTEM_PROCESSOR STREQUAL aarch64)
+    set(ARM_LINKER_FLAGS "-Wl,--no-undefined -Wl,--gc-sections -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now")
+  endif()
+  set(CMAKE_SHARED_LINKER_FLAGS "${ARM_LINKER_FLAGS} ${CMAKE_SHARED_LINKER_FLAGS}")
+  set(CMAKE_MODULE_LINKER_FLAGS "${ARM_LINKER_FLAGS} ${CMAKE_MODULE_LINKER_FLAGS}")
+  set(CMAKE_EXE_LINKER_FLAGS    "${ARM_LINKER_FLAGS} ${CMAKE_EXE_LINKER_FLAGS}")
+else()
+  #message(WARNING "CMAKE_CXX_FLAGS='${CMAKE_CXX_FLAGS}' is defined")
+endif()
+
+if(USE_NEON)
+  message(WARNING "You use obsolete variable USE_NEON to enable NEON instruction set. Use -DENABLE_NEON=ON instead." )
+  set(ENABLE_NEON TRUE)
+elseif(USE_VFPV3)
+  message(WARNING "You use obsolete variable USE_VFPV3 to enable VFPV3 instruction set. Use -DENABLE_VFPV3=ON instead." )
+  set(ENABLE_VFPV3 TRUE)
+endif()
+
+set(CMAKE_FIND_ROOT_PATH ${CMAKE_FIND_ROOT_PATH} ${ARM_LINUX_SYSROOT})
+
+if(EXISTS ${CUDA_TOOLKIT_ROOT_DIR})
+  set(CMAKE_FIND_ROOT_PATH ${CMAKE_FIND_ROOT_PATH} ${CUDA_TOOLKIT_ROOT_DIR})
+endif()
+
+set(TOOLCHAIN_CONFIG_VARS ${TOOLCHAIN_CONFIG_VARS}
+    ARM_LINUX_SYSROOT
+    ENABLE_NEON
+    ENABLE_VFPV3
+    CUDA_TOOLKIT_ROOT_DIR
+)
+toolchain_save_config()
diff --git a/platforms/linux/arm.toolchain.cmake b/platforms/linux/arm.toolchain.cmake
index 184997fba5..07a3d054d0 100644
--- a/platforms/linux/arm.toolchain.cmake
+++ b/platforms/linux/arm.toolchain.cmake
@@ -58,9 +58,10 @@ if(NOT DEFINED CMAKE_CXX_FLAGS)
   set(CMAKE_CXX_FLAGS           "${CMAKE_CXX_FLAGS} -fdata-sections -Wa,--noexecstack -fsigned-char -Wno-psabi")
   set(CMAKE_C_FLAGS             "${CMAKE_C_FLAGS} -fdata-sections -Wa,--noexecstack -fsigned-char -Wno-psabi")
   if(CMAKE_SYSTEM_PROCESSOR STREQUAL arm)
-    set(CMAKE_CXX_FLAGS           "-mthumb ${CMAKE_CXX_FLAGS}")
-    set(CMAKE_C_FLAGS             "-mthumb ${CMAKE_C_FLAGS}")
-    set(CMAKE_EXE_LINKER_FLAGS    "${CMAKE_EXE_LINKER_FLAGS} -Wl,-z,nocopyreloc")
+    # mashplant:
+    set(CMAKE_CXX_FLAGS           "-fno-exceptions -fno-rtti ${CMAKE_CXX_FLAGS}")
+    set(CMAKE_C_FLAGS             "-fno-exceptions ${CMAKE_C_FLAGS}")
+    set(CMAKE_EXE_LINKER_FLAGS    "${CMAKE_EXE_LINKER_FLAGS} -Wl,-z,nocopyreloc -fno-exceptions -fno-rtti")
   endif()
   if(CMAKE_SYSTEM_PROCESSOR STREQUAL arm)
     set(ARM_LINKER_FLAGS "-Wl,--fix-cortex-a8 -Wl,--no-undefined -Wl,--gc-sections -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now")
-- 
2.17.1

